        if (Dp(t[s])) {
          const e = t[s];
          (t[s] = null === (n = e.next) || void 0 === n ? void 0 : n.bind(e)),
            (t[s + 1] = null === (r = e.error) || void 0 === r ? void 0 : r.bind(e)),
            (t[s + 2] = null === (i = e.complete) || void 0 === i ? void 0 : i.bind(e));
        }
        let c, l, h;
        if (e instanceof Tp)
          (l = bp(e.firestore, Mp)),
            (h = ua(e._key.path)),
            (c = {
              next: n => {
                t[s] && t[s](_m(l, e, n));
              },
              error: t[s + 1],
              complete: t[s + 2]
            });
        else {
          const n = bp(e, Ap);
          (l = bp(n.firestore, Mp)), (h = n._query);
          const r = new um(l);
          (c = {
            next: e => {
              t[s] && t[s](new im(l, r, n, e));
            },
            error: t[s + 1],
            complete: t[s + 2]
          }),
            kg(e._query);
        }
        return (function (e, t, n, r) {
          const i = new $d(r),
            o = new Kf(t, i, n);
          return (
            e.asyncQueue.enqueueAndForget(async () => qf(await rp(e), o)),
            () => {
              i.Dc(), e.asyncQueue.enqueueAndForget(async () => zf(await rp(e), o));
            }
          );
        })(Fp(l), h, a, c);
      }
      function wm(e, t) {
        return lp(Fp((e = bp(e, Mp))), Dp(t) ? t : { next: t });
      }
      function bm(e, t) {
        return (function (e, t) {
          const n = new hi();
          return e.asyncQueue.enqueueAndForget(async () => ud(await tp(e), t, n)), n.promise;
        })(Fp(e), t);
      }
      function _m(e, t, n) {
        const r = n.docs.get(t._key),
          i = new um(e);
        return new nm(e, i, t._key, r, new tm(n.hasPendingWrites, n.fromCache), t.converter);
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const Im = { maxAttempts: 5 };
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Em {
        constructor(e, t) {
          (this._firestore = e), (this._commitHandler = t), (this._mutations = []), (this._committed = !1), (this._dataReader = sg(e));
        }
        set(e, t, n) {
          this._verifyNotCommitted();
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'WriteBatch.set', r._key, i, null !== r.converter, n);
          return this._mutations.push(o.toMutation(r._key, nu.none())), this;
        }
        update(e, t, n, ...r) {
          this._verifyNotCommitted();
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'WriteBatch.update', i._key, t, n, r)
                : pg(this._dataReader, 'WriteBatch.update', i._key, t)),
            this._mutations.push(o.toMutation(i._key, nu.exists(!0))),
            this
          );
        }
        delete(e) {
          this._verifyNotCommitted();
          const t = Sm(e, this._firestore);
          return (this._mutations = this._mutations.concat(new gu(t._key, nu.none()))), this;
        }
        commit() {
          return (
            this._verifyNotCommitted(), (this._committed = !0), this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
          );
        }
        _verifyNotCommitted() {
          if (this._committed) throw new li(ci.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() has been called.');
        }
      }
      function Sm(e, t) {
        if ((e = (0, u.m9)(e)).firestore !== t)
          throw new li(ci.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');
        return e;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tm extends class {
        constructor(e, t) {
          (this._firestore = e), (this._transaction = t), (this._dataReader = sg(e));
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new em(this._firestore);
          return this._transaction.lookup([t._key]).then(e => {
            if (!e || 1 !== e.length) return oi();
            const r = e[0];
            if (r.isFoundDocument()) return new Ag(this._firestore, n, r.key, r, t.converter);
            if (r.isNoDocument()) return new Ag(this._firestore, n, t._key, null, t.converter);
            throw oi();
          });
        }
        set(e, t, n) {
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'Transaction.set', r._key, i, null !== r.converter, n);
          return this._transaction.set(r._key, o), this;
        }
        update(e, t, n, ...r) {
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'Transaction.update', i._key, t, n, r)
                : pg(this._dataReader, 'Transaction.update', i._key, t)),
            this._transaction.update(i._key, o),
            this
          );
        }
        delete(e) {
          const t = Sm(e, this._firestore);
          return this._transaction.delete(t._key), this;
        }
      } {
        constructor(e, t) {
          super(e, t), (this._firestore = e);
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new um(this._firestore);
          return super.get(e).then(e => new nm(this._firestore, n, t._key, e._document, new tm(!1, !1), t.converter));
        }
      }
      function Am(e, t, n) {
        e = bp(e, Mp);
        const r = Object.assign(Object.assign({}, Im), n);
        return (
          (function (e) {
            if (e.maxAttempts < 1) throw new li(ci.INVALID_ARGUMENT, 'Max attempts must be at least 1');
          })(r),
          (function (e, t, n) {
            const r = new hi();
            return (
              e.asyncQueue.enqueueAndForget(async () => {
                const i = await np(e);
                new Gd(e.asyncQueue, i, n, t, r).run();
              }),
              r.promise
            );
          })(Fp(e), n => t(new Tm(e, n)), r)
        );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function xm() {
        return new ug('deleteField');
      }
      function Cm() {
        return new lg('serverTimestamp');
      }
      function km(...e) {
        return new hg('arrayUnion', e);
      }
      function Om(...e) {
        return new fg('arrayRemove', e);
      }
      function Nm(e) {
        return new dg('increment', e);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ !(function (e, t = !0) {
        !(function (e) {
          Xr = e;
        })(o.SDK_VERSION),
          (0, o._registerComponent)(
            new s.wA(
              'firestore',
              (e, { instanceIdentifier: n, options: r }) => {
                const i = e.getProvider('app').getImmediate(),
                  o = new Mp(
                    new gi(e.getProvider('auth-internal')),
                    new wi(e.getProvider('app-check-internal')),
                    (function (e, t) {
                      if (!Object.prototype.hasOwnProperty.apply(e.options, ['projectId']))
                        throw new li(ci.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
                      return new rs(e.options.projectId, t);
                    })(i, n),
                    i
                  );
                return (r = Object.assign({ useFetchStreams: t }, r)), o._setSettings(r), o;
              },
              'PUBLIC'
            ).setMultipleInstances(!0)
          ),
          (0, o.registerVersion)(Qr, '3.13.0', e),
          (0, o.registerVersion)(Qr, '3.13.0', 'esm2017');
      })();
      const Rm = '@firebase/firestore-compat',
        Pm = '0.3.12';
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function Dm(e, t) {
        if (void 0 === t) return { merge: !1 };
        if (void 0 !== t.mergeFields && void 0 !== t.merge)
          throw new li('invalid-argument', `Invalid options passed to function ${e}(): You cannot specify both "merge" and "mergeFields".`);
        return t;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Lm() {
        if ('undefined' === typeof Uint8Array) throw new li('unimplemented', 'Uint8Arrays are not available in this environment.');
      }
      function jm() {
        if (!Ho()) throw new li('unimplemented', 'Blobs are unavailable in Firestore in this environment.');
      }
      class Mm {
        constructor(e) {
          this._delegate = e;
        }
        static fromBase64String(e) {
          return jm(), new Mm(Yp.fromBase64String(e));
        }
        static fromUint8Array(e) {
          return Lm(), new Mm(Yp.fromUint8Array(e));
        }
        toBase64() {
          return jm(), this._delegate.toBase64();
        }
        toUint8Array() {
          return Lm(), this._delegate.toUint8Array();
        }
        isEqual(e) {
          return this._delegate.isEqual(e._delegate);
        }
        toString() {
          return 'Blob(base64: ' + this.toBase64() + ')';
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Fm(e) {
        return Um(e, ['next', 'error', 'complete']);
      }
      function Um(e, t) {
        if ('object' !== typeof e || null === e) return !1;
        const n = e;
        for (const r of t) if (r in n && 'function' === typeof n[r]) return !0;
        return !1;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Vm {
        enableIndexedDbPersistence(e, t) {
          return Vp(e._delegate, { forceOwnership: t });
        }
        enableMultiTabIndexedDbPersistence(e) {
          return Bp(e._delegate);
        }
        clearIndexedDbPersistence(e) {
          return qp(e._delegate);
        }
      }
      class Bm {
        constructor(e, t, n) {
          (this._delegate = t),
            (this._persistenceProvider = n),
            (this.INTERNAL = { delete: () => this.terminate() }),
            e instanceof rs || (this._appCompat = e);
        }
        get _databaseId() {
          return this._delegate._databaseId;
        }
        settings(e) {
          const t = this._delegate._getSettings();
          e.merge ||
            t.host === e.host ||
            ri('You are overriding the original host. If you did not intend to override your settings, use {merge: true}.'),
            e.merge && ((e = Object.assign(Object.assign({}, t), e)), delete e.merge),
            this._delegate._setSettings(e);
        }
        useEmulator(e, t, n = {}) {
          Sp(this._delegate, e, t, n);
        }
        enableNetwork() {
          return Gp(this._delegate);
        }
        disableNetwork() {
          return Wp(this._delegate);
        }
        enablePersistence(e) {
          let t = !1,
            n = !1;
          return (
            e && ((t = !!e.synchronizeTabs), (n = !!e.experimentalForceOwningTab), mp('synchronizeTabs', t, 'experimentalForceOwningTab', n)),
            t ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, n)
          );
        }
        clearPersistence() {
          return this._persistenceProvider.clearIndexedDbPersistence(this);
        }
        terminate() {
          return (
            this._appCompat && (this._appCompat._removeServiceInstance('firestore-compat'), this._appCompat._removeServiceInstance('firestore')),
            this._delegate._delete()
          );
        }
        waitForPendingWrites() {
          return zp(this._delegate);
        }
        onSnapshotsInSync(e) {
          return wm(this._delegate, e);
        }
        get app() {
          if (!this._appCompat) throw new li('failed-precondition', "Firestore was not initialized using the Firebase SDK. 'app' is not available");
          return this._appCompat;
        }
        collection(e) {
          try {
            return new nv(this, Cp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collection()', 'Firestore.collection()');
          }
        }
        doc(e) {
          try {
            return new Hm(this, Op(this._delegate, e));
          } catch (t) {
            throw Km(t, 'doc()', 'Firestore.doc()');
          }
        }
        collectionGroup(e) {
          try {
            return new Zm(this, kp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collectionGroup()', 'Firestore.collectionGroup()');
          }
        }
        runTransaction(e) {
          return Am(this._delegate, t => e(new zm(this, t)));
        }
        batch() {
          return Fp(this._delegate), new Gm(new Em(this._delegate, e => bm(this._delegate, e)));
        }
        loadBundle(e) {
          return Hp(this._delegate, e);
        }
        namedQuery(e) {
          return Kp(this._delegate, e).then(e => (e ? new Zm(this, e) : null));
        }
      }
      class $m extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Mm(new Yp(e));
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return Hm.forKey(t, this.firestore, null);
        }
      }
      function qm(e) {
        ei(e);
      }
      class zm {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t), (this._userDataWriter = new $m(e));
        }
        get(e) {
          const t = rv(e);
          return this._delegate
            .get(t)
            .then(
              e => new Xm(this._firestore, new nm(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, t.converter))
            );
        }
        set(e, t, n) {
          const r = rv(e);
          return n ? (Dm('Transaction.set', n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this;
        }
        update(e, t, n, ...r) {
          const i = rv(e);
          return 2 === arguments.length ? this._delegate.update(i, t) : this._delegate.update(i, t, n, ...r), this;
        }
        delete(e) {
          const t = rv(e);
          return this._delegate.delete(t), this;
        }
      }
      class Gm {
        constructor(e) {
          this._delegate = e;
        }
        set(e, t, n) {
          const r = rv(e);
          return n ? (Dm('WriteBatch.set', n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this;
        }
        update(e, t, n, ...r) {
          const i = rv(e);
          return 2 === arguments.length ? this._delegate.update(i, t) : this._delegate.update(i, t, n, ...r), this;
        }
        delete(e) {
          const t = rv(e);
          return this._delegate.delete(t), this;
        }
        commit() {
          return this._delegate.commit();
        }
      }
      class Wm {
        constructor(e, t, n) {
          (this._firestore = e), (this._userDataWriter = t), (this._delegate = n);
        }
        fromFirestore(e, t) {
          const n = new rm(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, null);
          return this._delegate.fromFirestore(new Jm(this._firestore, n), null !== t && void 0 !== t ? t : {});
        }
        toFirestore(e, t) {
          return t ? this._delegate.toFirestore(e, t) : this._delegate.toFirestore(e);
        }
        static getInstance(e, t) {
          const n = Wm.INSTANCES;
          let r = n.get(e);
          r || ((r = new WeakMap()), n.set(e, r));
          let i = r.get(t);
          return i || ((i = new Wm(e, new $m(e), t)), r.set(t, i)), i;
        }
      }
      Wm.INSTANCES = new WeakMap();
      class Hm {
        constructor(e, t) {
          (this.firestore = e), (this._delegate = t), (this._userDataWriter = new $m(e));
        }
        static forPath(e, t, n) {
          if (e.length % 2 !== 0)
            throw new li(
              'invalid-argument',
              `Invalid document reference. Document references must have an even number of segments, but ${e.canonicalString()} has ${e.length}`
            );
          return new Hm(t, new Tp(t._delegate, n, new Ni(e)));
        }
        static forKey(e, t, n) {
          return new Hm(t, new Tp(t._delegate, n, e));
        }
        get id() {
          return this._delegate.id;
        }
        get parent() {
          return new nv(this.firestore, this._delegate.parent);
        }
        get path() {
          return this._delegate.path;
        }
        collection(e) {
          try {
            return new nv(this.firestore, Cp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collection()', 'DocumentReference.collection()');
          }
        }
        isEqual(e) {
          return (e = (0, u.m9)(e)), e instanceof Tp && Np(this._delegate, e);
        }
        set(e, t) {
          t = Dm('DocumentReference.set', t);
          try {
            return t ? pm(this._delegate, e, t) : pm(this._delegate, e);
          } catch (n) {
            throw Km(n, 'setDoc()', 'DocumentReference.set()');
          }
        }
        update(e, t, ...n) {
          try {
            return 1 === arguments.length ? gm(this._delegate, e) : gm(this._delegate, e, t, ...n);
          } catch (r) {
            throw Km(r, 'updateDoc()', 'DocumentReference.update()');
          }
        }
        delete() {
          return mm(this._delegate);
        }
        onSnapshot(...e) {
          const t = Qm(e),
            n = Ym(
              e,
              e =>
                new Xm(
                  this.firestore,
                  new nm(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter)
                )
            );
          return ym(this._delegate, t, n);
        }
        get(e) {
          let t;
          return (
            (t =
              'cache' === (null === e || void 0 === e ? void 0 : e.source)
                ? cm(this._delegate)
                : 'server' === (null === e || void 0 === e ? void 0 : e.source)
                  ? lm(this._delegate)
                  : am(this._delegate)),
            t.then(
              e =>
                new Xm(
                  this.firestore,
                  new nm(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter)
                )
            )
          );
        }
        withConverter(e) {
          return new Hm(this.firestore, e ? this._delegate.withConverter(Wm.getInstance(this.firestore, e)) : this._delegate.withConverter(null));
        }
      }
      function Km(e, t, n) {
        return (e.message = e.message.replace(t, n)), e;
      }
      function Qm(e) {
        for (const t of e) if ('object' === typeof t && !Fm(t)) return t;
        return {};
      }
      function Ym(e, t) {
        var n, r;
        let i;
        return (
          (i = Fm(e[0])
            ? e[0]
            : Fm(e[1])
              ? e[1]
              : 'function' === typeof e[0]
                ? { next: e[0], error: e[1], complete: e[2] }
                : { next: e[1], error: e[2], complete: e[3] }),
          {
            next: e => {
              i.next && i.next(t(e));
            },
            error: null === (n = i.error) || void 0 === n ? void 0 : n.bind(i),
            complete: null === (r = i.complete) || void 0 === r ? void 0 : r.bind(i)
          }
        );
      }
      class Xm {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t);
        }
        get ref() {
          return new Hm(this._firestore, this._delegate.ref);
        }
        get id() {
          return this._delegate.id;
        }
        get metadata() {
          return this._delegate.metadata;
        }
        get exists() {
          return this._delegate.exists();
        }
        data(e) {
          return this._delegate.data(e);
        }
        get(e, t) {
          return this._delegate.get(e, t);
        }
        isEqual(e) {
          return sm(this._delegate, e._delegate);
        }
      }
      class Jm extends Xm {
        data(e) {
          const t = this._delegate.data(e);
          return ai(void 0 !== t, 'Document in a QueryDocumentSnapshot should exist'), t;
        }
      }
      class Zm {
        constructor(e, t) {
          (this.firestore = e), (this._delegate = t), (this._userDataWriter = new $m(e));
        }
        where(e, t, n) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Dg(e, t, n)));
          } catch (r) {
            throw Km(r, /(orderBy|where)\(\)/, 'Query.$1()');
          }
        }
        orderBy(e, t) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Mg(e, t)));
          } catch (n) {
            throw Km(n, /(orderBy|where)\(\)/, 'Query.$1()');
          }
        }
        limit(e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Ug(e)));
          } catch (t) {
            throw Km(t, 'limit()', 'Query.limit()');
          }
        }
        limitToLast(e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Vg(e)));
          } catch (t) {
            throw Km(t, 'limitToLast()', 'Query.limitToLast()');
          }
        }
        startAt(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, $g(...e)));
          } catch (t) {
            throw Km(t, 'startAt()', 'Query.startAt()');
          }
        }
        startAfter(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, qg(...e)));
          } catch (t) {
            throw Km(t, 'startAfter()', 'Query.startAfter()');
          }
        }
        endBefore(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Gg(...e)));
          } catch (t) {
            throw Km(t, 'endBefore()', 'Query.endBefore()');
          }
        }
        endAt(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Wg(...e)));
          } catch (t) {
            throw Km(t, 'endAt()', 'Query.endAt()');
          }
        }
        isEqual(e) {
          return Rp(this._delegate, e._delegate);
        }
        get(e) {
          let t;
          return (
            (t =
              'cache' === (null === e || void 0 === e ? void 0 : e.source)
                ? fm(this._delegate)
                : 'server' === (null === e || void 0 === e ? void 0 : e.source)
                  ? dm(this._delegate)
                  : hm(this._delegate)),
            t.then(e => new tv(this.firestore, new im(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot)))
          );
        }
        onSnapshot(...e) {
          const t = Qm(e),
            n = Ym(e, e => new tv(this.firestore, new im(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot)));
          return ym(this._delegate, t, n);
        }
        withConverter(e) {
          return new Zm(this.firestore, e ? this._delegate.withConverter(Wm.getInstance(this.firestore, e)) : this._delegate.withConverter(null));
        }
      }
      class ev {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t);
        }
        get type() {
          return this._delegate.type;
        }
        get doc() {
          return new Jm(this._firestore, this._delegate.doc);
        }
        get oldIndex() {
          return this._delegate.oldIndex;
        }
        get newIndex() {
          return this._delegate.newIndex;
        }
      }
      class tv {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t);
        }
        get query() {
          return new Zm(this._firestore, this._delegate.query);
        }
        get metadata() {
          return this._delegate.metadata;
        }
        get size() {
          return this._delegate.size;
        }
        get empty() {
          return this._delegate.empty;
        }
        get docs() {
          return this._delegate.docs.map(e => new Jm(this._firestore, e));
        }
        docChanges(e) {
          return this._delegate.docChanges(e).map(e => new ev(this._firestore, e));
        }
        forEach(e, t) {
          this._delegate.forEach(n => {
            e.call(t, new Jm(this._firestore, n));
          });
        }
        isEqual(e) {
          return sm(this._delegate, e._delegate);
        }
      }
      class nv extends Zm {
        constructor(e, t) {
          super(e, t), (this.firestore = e), (this._delegate = t);
        }
        get id() {
          return this._delegate.id;
        }
        get path() {
          return this._delegate.path;
        }
        get parent() {
          const e = this._delegate.parent;
          return e ? new Hm(this.firestore, e) : null;
        }
        doc(e) {
          try {
            return new Hm(this.firestore, void 0 === e ? Op(this._delegate) : Op(this._delegate, e));
          } catch (t) {
            throw Km(t, 'doc()', 'CollectionReference.doc()');
          }
        }
        add(e) {
          return vm(this._delegate, e).then(e => new Hm(this.firestore, e));
        }
        isEqual(e) {
          return Np(this._delegate, e._delegate);
        }
        withConverter(e) {
          return new nv(this.firestore, e ? this._delegate.withConverter(Wm.getInstance(this.firestore, e)) : this._delegate.withConverter(null));
        }
      }
      function rv(e) {
        return bp(e, Tp);
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class iv {
        constructor(...e) {
          this._delegate = new Xp(...e);
        }
        static documentId() {
          return new iv(Oi.keyField().canonicalString());
        }
        isEqual(e) {
          return (e = (0, u.m9)(e)), e instanceof Xp && this._delegate._internalPath.isEqual(e._internalPath);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ov {
        constructor(e) {
          this._delegate = e;
        }
        static serverTimestamp() {
          const e = Cm();
          return (e._methodName = 'FieldValue.serverTimestamp'), new ov(e);
        }
        static delete() {
          const e = xm();
          return (e._methodName = 'FieldValue.delete'), new ov(e);
        }
        static arrayUnion(...e) {
          const t = km(...e);
          return (t._methodName = 'FieldValue.arrayUnion'), new ov(t);
        }
        static arrayRemove(...e) {
          const t = Om(...e);
          return (t._methodName = 'FieldValue.arrayRemove'), new ov(t);
        }
        static increment(e) {
          const t = Nm(e);
          return (t._methodName = 'FieldValue.increment'), new ov(t);
        }
        isEqual(e) {
          return this._delegate.isEqual(e._delegate);
        }
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const sv = {
        Firestore: Bm,
        GeoPoint: Zp,
        Timestamp: Ti,
        Blob: Mm,
        Transaction: zm,
        WriteBatch: Gm,
        DocumentReference: Hm,
        DocumentSnapshot: Xm,
        Query: Zm,
        QueryDocumentSnapshot: Jm,
        QuerySnapshot: tv,
        CollectionReference: nv,
        FieldPath: iv,
        FieldValue: ov,
        setLogLevel: qm,
        CACHE_SIZE_UNLIMITED: jp
      };
      function av(e, t) {
        e.INTERNAL.registerComponent(
          new s.wA(
            'firestore-compat',
            e => {
              const n = e.getProvider('app-compat').getImmediate(),
                r = e.getProvider('firestore').getImmediate();
              return t(n, r);
            },
            'PUBLIC'
          ).setServiceProps(Object.assign({}, sv))
        );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function uv(e) {
        av(e, (e, t) => new Bm(e, t, new Vm())), e.registerVersion(Rm, Pm);
      }
      uv(i.Z);
    }
  }
]);