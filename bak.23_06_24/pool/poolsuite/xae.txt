                            return !!this.h && this.h.isActive(this);
                        }),
                        (r = hr.prototype),
                        (r.Ba = function() {}),
                        (r.Aa = function() {}),
                        (r.za = function() {}),
                        (r.ya = function() {}),
                        (r.isActive = function() {
                            return !0;
                        }),
                        (r.Va = function() {}),
                        (fr.prototype.g = function(e, t) {
                            return new dr(e, t);
                        }),
                        I(dr, Ie),
                            (dr.prototype.m = function() {
                                (this.g.h = this.j), this.A && (this.g.J = !0);
                                var e = this.g,
                                    t = this.l,
                                    n = this.h || void 0;
                                ot(0), (e.Y = t), (e.na = n || {}), (e.G = e.aa), (e.I = cr(e, null, e.Y)), Qn(e);
                            }),
                            (dr.prototype.close = function() {
                                Wn(this.g);
                            }),
                            (dr.prototype.u = function(e) {
                                var t = this.g;
                                if ('string' === typeof e) {
                                    var n = {};
                                    (n.__data__ = e), (e = n);
                                } else this.v && ((n = {}), (n.__data__ = Te(e)), (e = n));
                                t.j.push(new un(t.fb++, e)), 3 == t.H && Qn(t);
                            }),
                            (dr.prototype.N = function() {
                                (this.g.h = null), delete this.j, Wn(this.g), delete this.g, dr.$.N.call(this);
                            }),
                            I(pr, gt),
                            I(gr, mt),
                            I(mr, hr),
                            (mr.prototype.Ba = function() {
                                Ee(this.g, 'a');
                            }),
                            (mr.prototype.Aa = function(e) {
                                Ee(this.g, new pr(e));
                            }),
                            (mr.prototype.za = function(e) {
                                Ee(this.g, new gr());
                            }),
                            (mr.prototype.ya = function() {
                                Ee(this.g, 'b');
                            }),
                            I(yr, vr),
                            (yr.prototype.reset = function() {
                                (this.g[0] = 1732584193), (this.g[1] = 4023233417), (this.g[2] = 2562383102), (this.g[3] = 271733878), (this.i = this.h = 0);
                            }),
                            (yr.prototype.j = function(e, t) {
                                void 0 === t && (t = e.length);
                                for (var n = t - this.blockSize, r = this.m, i = this.h, o = 0; o < t;) {
                                    if (0 == i)
                                        for (; o <= n;) wr(this, e, o), (o += this.blockSize);
                                    if ('string' === typeof e) {
                                        for (; o < t;)
                                            if (((r[i++] = e.charCodeAt(o++)), i == this.blockSize)) {
                                                wr(this, r), (i = 0);
                                                break;
                                            }
                                    } else
                                        for (; o < t;)
                                            if (((r[i++] = e[o++]), i == this.blockSize)) {
                                                wr(this, r), (i = 0);
                                                break;
                                            }
                                }
                                (this.h = i), (this.i += t);
                            }),
                            (yr.prototype.l = function() {
                                var e = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
                                e[0] = 128;
                                for (var t = 1; t < e.length - 8; ++t) e[t] = 0;
                                var n = 8 * this.i;
                                for (t = e.length - 8; t < e.length; ++t)(e[t] = 255 & n), (n /= 256);
                                for (this.j(e), e = Array(16), t = n = 0; 4 > t; ++t)
                                    for (var r = 0; 32 > r; r += 8) e[n++] = (this.g[t] >>> r) & 255;
                                return e;
                            });
                        var _r = {};

                        function Ir(e) {
                            return -128 <= e && 128 > e ?
                                D(e, function(e) {
                                    return new br([0 | e], 0 > e ? -1 : 0);
                                }) :
                                new br([0 | e], 0 > e ? -1 : 0);
                        }

                        function Er(e) {
                            if (isNaN(e) || !isFinite(e)) return Ar;
                            if (0 > e) return Nr(Er(-e));
                            for (var t = [], n = 1, r = 0; e >= n; r++)(t[r] = (e / n) | 0), (n *= Tr);
                            return new br(t, 0);
                        }

                        function Sr(e, t) {
                            if (0 == e.length) throw Error('number format error: empty string');
                            if (((t = t || 10), 2 > t || 36 < t)) throw Error('radix out of range: ' + t);
                            if ('-' == e.charAt(0)) return Nr(Sr(e.substring(1), t));
                            if (0 <= e.indexOf('-')) throw Error('number format error: interior "-" character');
                            for (var n = Er(Math.pow(t, 8)), r = Ar, i = 0; i < e.length; i += 8) {
                                var o = Math.min(8, e.length - i),
                                    s = parseInt(e.substring(i, i + o), t);
                                8 > o ? ((o = Er(Math.pow(t, o))), (r = r.R(o).add(Er(s)))) : ((r = r.R(n)), (r = r.add(Er(s))));
                            }
                            return r;
                        }
                        var Tr = 4294967296,
                            Ar = Ir(0),
                            xr = Ir(1),
                            Cr = Ir(16777216);

                        function kr(e) {
                            if (0 != e.h) return !1;
                            for (var t = 0; t < e.g.length; t++)
                                if (0 != e.g[t]) return !1;
                            return !0;
                        }

                        function Or(e) {
                            return -1 == e.h;
                        }

                        function Nr(e) {
                            for (var t = e.g.length, n = [], r = 0; r < t; r++) n[r] = ~e.g[r];
                            return new br(n, ~e.h).add(xr);
                        }

                        function Rr(e, t) {
                            return e.add(Nr(t));
                        }

                        function Pr(e, t) {
                            for (;
                                (65535 & e[t]) != e[t];)(e[t + 1] += e[t] >>> 16), (e[t] &= 65535), t++;
                        }

                        function Dr(e, t) {
                            (this.g = e), (this.h = t);
                        }

                        function Lr(e, t) {
                            if (kr(t)) throw Error('division by zero');
                            if (kr(e)) return new Dr(Ar, Ar);
                            if (Or(e)) return (t = Lr(Nr(e), t)), new Dr(Nr(t.g), Nr(t.h));
                            if (Or(t)) return (t = Lr(e, Nr(t))), new Dr(Nr(t.g), t.h);
                            if (30 < e.g.length) {
                                if (Or(e) || Or(t)) throw Error('slowDivide_ only works with positive integers.');
                                for (var n = xr, r = t; 0 >= r.X(e);)(n = jr(n)), (r = jr(r));
                                var i = Mr(n, 1),
                                    o = Mr(r, 1);
                                for (r = Mr(r, 2), n = Mr(n, 2); !kr(r);) {
                                    var s = o.add(r);
                                    0 >= s.X(e) && ((i = i.add(n)), (o = s)), (r = Mr(r, 1)), (n = Mr(n, 1));
                                }
                                return (t = Rr(e, i.R(t))), new Dr(i, t);
                            }
                            for (i = Ar; 0 <= e.X(t);) {
                                for (
                                    n = Math.max(1, Math.floor(e.ea() / t.ea())),
                                    r = Math.ceil(Math.log(n) / Math.LN2),
                                    r = 48 >= r ? 1 : Math.pow(2, r - 48),
                                    o = Er(n),
                                    s = o.R(t); Or(s) || 0 < s.X(e);

                                )
                                    (n -= r), (o = Er(n)), (s = o.R(t));
                                kr(o) && (o = xr), (i = i.add(o)), (e = Rr(e, s));
                            }
                            return new Dr(i, e);
                        }

                        function jr(e) {
                            for (var t = e.g.length + 1, n = [], r = 0; r < t; r++) n[r] = (e.D(r) << 1) | (e.D(r - 1) >>> 31);
                            return new br(n, e.h);
                        }

                        function Mr(e, t) {
                            var n = t >> 5;
                            t %= 32;
                            for (var r = e.g.length - n, i = [], o = 0; o < r; o++) i[o] = 0 < t ? (e.D(o + n) >>> t) | (e.D(o + n + 1) << (32 - t)) : e.D(o + n);
                            return new br(i, e.h);
                        }
                        (r = br.prototype),
                        (r.ea = function() {
                            if (Or(this)) return -Nr(this).ea();
                            for (var e = 0, t = 1, n = 0; n < this.g.length; n++) {
                                var r = this.D(n);
                                (e += (0 <= r ? r : Tr + r) * t), (t *= Tr);
                            }
                            return e;
                        }),
                        (r.toString = function(e) {
                            if (((e = e || 10), 2 > e || 36 < e)) throw Error('radix out of range: ' + e);
                            if (kr(this)) return '0';
                            if (Or(this)) return '-' + Nr(this).toString(e);
                            for (var t = Er(Math.pow(e, 6)), n = this, r = '';;) {
                                var i = Lr(n, t).g;
                                n = Rr(n, i.R(t));
                                var o = ((0 < n.g.length ? n.g[0] : n.h) >>> 0).toString(e);
                                if (((n = i), kr(n))) return o + r;
                                for (; 6 > o.length;) o = '0' + o;
                                r = o + r;
                            }
                        }),
                        (r.D = function(e) {
                            return 0 > e ? 0 : e < this.g.length ? this.g[e] : this.h;
                        }),
                        (r.X = function(e) {
                            return (e = Rr(this, e)), Or(e) ? -1 : kr(e) ? 0 : 1;
                        }),
                        (r.abs = function() {
                            return Or(this) ? Nr(this) : this;
                        }),
                        (r.add = function(e) {
                            for (var t = Math.max(this.g.length, e.g.length), n = [], r = 0, i = 0; i <= t; i++) {
                                var o = r + (65535 & this.D(i)) + (65535 & e.D(i)),
                                    s = (o >>> 16) + (this.D(i) >>> 16) + (e.D(i) >>> 16);
                                (r = s >>> 16), (o &= 65535), (s &= 65535), (n[i] = (s << 16) | o);
                            }
                            return new br(n, -2147483648 & n[n.length - 1] ? -1 : 0);
                        }),
                        (r.R = function(e) {
                            if (kr(this) || kr(e)) return Ar;
                            if (Or(this)) return Or(e) ? Nr(this).R(Nr(e)) : Nr(Nr(this).R(e));
                            if (Or(e)) return Nr(this.R(Nr(e)));
                            if (0 > this.X(Cr) && 0 > e.X(Cr)) return Er(this.ea() * e.ea());
                            for (var t = this.g.length + e.g.length, n = [], r = 0; r < 2 * t; r++) n[r] = 0;
                            for (r = 0; r < this.g.length; r++)
                                for (var i = 0; i < e.g.length; i++) {
                                    var o = this.D(r) >>> 16,
                                        s = 65535 & this.D(r),
                                        a = e.D(i) >>> 16,
                                        u = 65535 & e.D(i);
                                    (n[2 * r + 2 * i] += s * u),
                                    Pr(n, 2 * r + 2 * i),
                                        (n[2 * r + 2 * i + 1] += o * u),
                                        Pr(n, 2 * r + 2 * i + 1),
                                        (n[2 * r + 2 * i + 1] += s * a),
                                        Pr(n, 2 * r + 2 * i + 1),
                                        (n[2 * r + 2 * i + 2] += o * a),
                                        Pr(n, 2 * r + 2 * i + 2);
                                }
                            for (r = 0; r < t; r++) n[r] = (n[2 * r + 1] << 16) | n[2 * r];
                            for (r = t; r < 2 * t; r++) n[r] = 0;
                            return new br(n, 0);
                        }),
                        (r.gb = function(e) {
                            return Lr(this, e).h;
                        }),
                        (r.and = function(e) {
                            for (var t = Math.max(this.g.length, e.g.length), n = [], r = 0; r < t; r++) n[r] = this.D(r) & e.D(r);
                            return new br(n, this.h & e.h);
                        }),
                        (r.or = function(e) {
                            for (var t = Math.max(this.g.length, e.g.length), n = [], r = 0; r < t; r++) n[r] = this.D(r) | e.D(r);
                            return new br(n, this.h | e.h);
                        }),
                        (r.xor = function(e) {
                            for (var t = Math.max(this.g.length, e.g.length), n = [], r = 0; r < t; r++) n[r] = this.D(r) ^ e.D(r);
                            return new br(n, this.h ^ e.h);
                        }),
                        (fr.prototype.createWebChannel = fr.prototype.g),
                        (dr.prototype.send = dr.prototype.u),
                        (dr.prototype.open = dr.prototype.m),
                        (dr.prototype.close = dr.prototype.close),
                        (ut.NO_ERROR = 0),
                        (ut.TIMEOUT = 8),
                        (ut.HTTP_ERROR = 6),
                        (ct.COMPLETE = 'complete'),
                        (ft.EventType = pt),
                        (pt.OPEN = 'a'),
                        (pt.CLOSE = 'b'),
                        (pt.ERROR = 'c'),
                        (pt.MESSAGE = 'd'),
                        (Ie.prototype.listen = Ie.prototype.O),
                        (kn.prototype.listenOnce = kn.prototype.P),
                        (kn.prototype.getLastError = kn.prototype.Sa),
                        (kn.prototype.getLastErrorCode = kn.prototype.Ia),
                        (kn.prototype.getStatus = kn.prototype.da),
                        (kn.prototype.getResponseJson = kn.prototype.Wa),
                        (kn.prototype.getResponseText = kn.prototype.ja),
                        (kn.prototype.send = kn.prototype.ha),
                        (kn.prototype.setWithCredentials = kn.prototype.Oa),
                        (yr.prototype.digest = yr.prototype.l),
                        (yr.prototype.reset = yr.prototype.reset),
                        (yr.prototype.update = yr.prototype.j),
                        (br.prototype.add = br.prototype.add),
                        (br.prototype.multiply = br.prototype.R),
                        (br.prototype.modulo = br.prototype.gb),
                        (br.prototype.compare = br.prototype.X),
                        (br.prototype.toNumber = br.prototype.ea),
                        (br.prototype.toString = br.prototype.toString),
                        (br.prototype.getBits = br.prototype.D),
                        (br.fromNumber = Er),
                        (br.fromString = Sr);
                        var Fr = (l.createWebChannelTransport = function() {
                                return new fr();
                            }),
                            Ur = (l.getStatEventTarget = function() {
                                return tt();
                            }),
                            Vr = (l.ErrorCode = ut),
                            Br = (l.EventType = ct),
                            $r = (l.Event = Ze),
                            qr = (l.Stat = {
                                xb: 0,
                                Ab: 1,
                                Bb: 2,
                                Ub: 3,
                                Zb: 4,
                                Wb: 5,
                                Xb: 6,
                                Vb: 7,
                                Tb: 8,
                                Yb: 9,
                                PROXY: 10,
                                NOPROXY: 11,
                                Rb: 12,
                                Nb: 13,
                                Ob: 14,
                                Mb: 15,
                                Pb: 16,
                                Qb: 17,
                                tb: 18,
                                sb: 19,
                                ub: 20
                            }),
                            zr = (l.FetchXmlHttpFactory = In),
                            Gr = (l.WebChannel = ft),
                            Wr = (l.XhrIo = kn),
                            Hr = (l.Md5 = yr),
                            Kr = (l.Integer = br);
                        const Qr = '@firebase/firestore';
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Yr {
                            constructor(e) {
                                this.uid = e;
                            }
                            isAuthenticated() {
                                return null != this.uid;
                            }
                            toKey() {
                                return this.isAuthenticated() ? 'uid:' + this.uid : 'anonymous-user';
                            }
                            isEqual(e) {
                                return e.uid === this.uid;
                            }
                        }
                        (Yr.UNAUTHENTICATED = new Yr(null)),
                        (Yr.GOOGLE_CREDENTIALS = new Yr('google-credentials-uid')),
                        (Yr.FIRST_PARTY = new Yr('first-party-uid')),
                        (Yr.MOCK_USER = new Yr('mock-user'));
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        let Xr = '9.23.0';
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        const Jr = new a.Yd('@firebase/firestore');

                        function Zr() {
                            return Jr.logLevel;
                        }

                        function ei(e) {
                            Jr.setLogLevel(e);
                        }

                        function ti(e, ...t) {
                            if (Jr.logLevel <= a['in'].DEBUG) {
                                const n = t.map(ii);
                                Jr.debug(`Firestore (${Xr}): ${e}`, ...n);
                            }
                        }

                        function ni(e, ...t) {
                            if (Jr.logLevel <= a['in'].ERROR) {
                                const n = t.map(ii);
                                Jr.error(`Firestore (${Xr}): ${e}`, ...n);
                            }
                        }

                        function ri(e, ...t) {
                            if (Jr.logLevel <= a['in'].WARN) {
                                const n = t.map(ii);
                                Jr.warn(`Firestore (${Xr}): ${e}`, ...n);
                            }
                        }

                        function ii(e) {
                            if ('string' == typeof e) return e;
                            try {
                                return (t = e), JSON.stringify(t);
                            } catch (t) {
                                return e;
                            }
                            /**
                             * @license
                             * Copyright 2020 Google LLC
                             *
                             * Licensed under the Apache License, Version 2.0 (the "License");
                             * you may not use this file except in compliance with the License.
                             * You may obtain a copy of the License at
                             *
                             *   http://www.apache.org/licenses/LICENSE-2.0
                             *
                             * Unless required by applicable law or agreed to in writing, software
                             * distributed under the License is distributed on an "AS IS" BASIS,
                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                             * See the License for the specific language governing permissions and
                             * limitations under the License.
                             */
                            var t;
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        function oi(e = 'Unexpected state') {
                            const t = `FIRESTORE (${Xr}) INTERNAL ASSERTION FAILED: ` + e;
                            throw (ni(t), new Error(t));
                        }

                        function si(e, t) {
                            e || oi();
                        }

                        function ai(e, t) {
                            e || oi();
                        }

                        function ui(e, t) {
                            return e;
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        const ci = {
                            OK: 'ok',
                            CANCELLED: 'cancelled',
                            UNKNOWN: 'unknown',
                            INVALID_ARGUMENT: 'invalid-argument',
                            DEADLINE_EXCEEDED: 'deadline-exceeded',
                            NOT_FOUND: 'not-found',
                            ALREADY_EXISTS: 'already-exists',
                            PERMISSION_DENIED: 'permission-denied',
                            UNAUTHENTICATED: 'unauthenticated',
                            RESOURCE_EXHAUSTED: 'resource-exhausted',
                            FAILED_PRECONDITION: 'failed-precondition',
                            ABORTED: 'aborted',
                            OUT_OF_RANGE: 'out-of-range',
                            UNIMPLEMENTED: 'unimplemented',
                            INTERNAL: 'internal',
                            UNAVAILABLE: 'unavailable',
                            DATA_LOSS: 'data-loss'
                        };
                        class li extends u.ZR {
                                constructor(e, t) {
                                    super(e, t), (this.code = e), (this.message = t), (this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`);
                                }
                            }
                            /**
                             * @license
                             * Copyright 2017 Google LLC
                             *
                             * Licensed under the Apache License, Version 2.0 (the "License");
                             * you may not use this file except in compliance with the License.
                             * You may obtain a copy of the License at
                             *
                             *   http://www.apache.org/licenses/LICENSE-2.0
                             *
                             * Unless required by applicable law or agreed to in writing, software
                             * distributed under the License is distributed on an "AS IS" BASIS,
                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                             * See the License for the specific language governing permissions and
                             * limitations under the License.
                             */
                        class hi {
                            constructor() {
                                this.promise = new Promise((e, t) => {
                                    (this.resolve = e), (this.reject = t);
                                });
                            }
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class fi {
                            constructor(e, t) {
                                (this.user = t), (this.type = 'OAuth'), (this.headers = new Map()), this.headers.set('Authorization', `Bearer ${e}`);
                            }
                        }
                        class di {
                            getToken() {
                                return Promise.resolve(null);
                            }
                            invalidateToken() {}
                            start(e, t) {
                                e.enqueueRetryable(() => t(Yr.UNAUTHENTICATED));
                            }
                            shutdown() {}
                        }
                        class pi {
                            constructor(e) {
                                (this.token = e), (this.changeListener = null);
                            }
                            getToken() {
                                return Promise.resolve(this.token);
                            }
                            invalidateToken() {}
                            start(e, t) {
                                (this.changeListener = t), e.enqueueRetryable(() => t(this.token.user));
                            }
                            shutdown() {
                                this.changeListener = null;
                            }
                        }
                        class gi {
                            constructor(e) {
                                (this.t = e), (this.currentUser = Yr.UNAUTHENTICATED), (this.i = 0), (this.forceRefresh = !1), (this.auth = null);
                            }
                            start(e, t) {
                                let n = this.i;
                                const r = e => (this.i !== n ? ((n = this.i), t(e)) : Promise.resolve());
                                let i = new hi();
                                this.o = () => {
                                    this.i++, (this.currentUser = this.u()), i.resolve(), (i = new hi()), e.enqueueRetryable(() => r(this.currentUser));
                                };
                                const o = () => {
                                        const t = i;
                                        e.enqueueRetryable(async() => {
                                            await t.promise, await r(this.currentUser);
                                        });
                                    },
                                    s = e => {
                                        ti('FirebaseAuthCredentialsProvider', 'Auth detected'), (this.auth = e), this.auth.addAuthTokenListener(this.o), o();
                                    };
                                this.t.onInit(e => s(e)),
                                    setTimeout(() => {
                                        if (!this.auth) {
                                            const e = this.t.getImmediate({ optional: !0 });
                                            e ? s(e) : (ti('FirebaseAuthCredentialsProvider', 'Auth not yet detected'), i.resolve(), (i = new hi()));
                                        }
                                    }, 0),
                                    o();
                            }
                            getToken() {
                                const e = this.i,
                                    t = this.forceRefresh;
                                return (
                                    (this.forceRefresh = !1),
                                    this.auth ?
                                    this.auth
                                    .getToken(t)
                                    .then(t =>
                                        this.i !== e ?
                                        (ti('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.'), this.getToken()) :
                                        t ?
                                        (si('string' == typeof t.accessToken), new fi(t.accessToken, this.currentUser)) :
                                        null
                                    ) :
                                    Promise.resolve(null)
                                );
                            }
                            invalidateToken() {
                                this.forceRefresh = !0;
                            }
                            shutdown() {
                                this.auth && this.auth.removeAuthTokenListener(this.o);
                            }
                            u() {
                                const e = this.auth && this.auth.getUid();
                                return si(null === e || 'string' == typeof e), new Yr(e);
                            }
                        }
                        class mi {
                            constructor(e, t, n) {
                                (this.h = e), (this.l = t), (this.m = n), (this.type = 'FirstParty'), (this.user = Yr.FIRST_PARTY), (this.g = new Map());
                            }
                            p() {
                                return this.m ? this.m() : null;
                            }
                            get headers() {
                                this.g.set('X-Goog-AuthUser', this.h);
                                const e = this.p();
                                return e && this.g.set('Authorization', e), this.l && this.g.set('X-Goog-Iam-Authorization-Token', this.l), this.g;
                            }
                        }
                        class vi {
                            constructor(e, t, n) {
                                (this.h = e), (this.l = t), (this.m = n);
                            }
                            getToken() {
                                return Promise.resolve(new mi(this.h, this.l, this.m));
                            }
                            start(e, t) {
                                e.enqueueRetryable(() => t(Yr.FIRST_PARTY));
                            }
                            shutdown() {}
                            invalidateToken() {}
                        }
                        class yi {
                            constructor(e) {
                                (this.value = e),
                                (this.type = 'AppCheck'),
                                (this.headers = new Map()),
                                e && e.length > 0 && this.headers.set('x-firebase-appcheck', this.value);
                            }
                        }
                        class wi {
                            constructor(e) {
                                (this.I = e), (this.forceRefresh = !1), (this.appCheck = null), (this.T = null);
                            }
                            start(e, t) {
                                const n = e => {
                                    null != e.error &&
                                        ti('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`);
                                    const n = e.token !== this.T;
                                    return (
                                        (this.T = e.token), ti('FirebaseAppCheckTokenProvider', `Received ${n ? 'new' : 'existing'} token.`), n ? t(e.token) : Promise.resolve()
                                    );
                                };
                                this.o = t => {
                                    e.enqueueRetryable(() => n(t));
                                };
                                const r = e => {
                                    ti('FirebaseAppCheckTokenProvider', 'AppCheck detected'), (this.appCheck = e), this.appCheck.addTokenListener(this.o);
                                };
                                this.I.onInit(e => r(e)),
                                    setTimeout(() => {
                                        if (!this.appCheck) {
                                            const e = this.I.getImmediate({ optional: !0 });
                                            e ? r(e) : ti('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');
                                        }
                                    }, 0);
                            }
                            getToken() {
                                const e = this.forceRefresh;
                                return (
                                    (this.forceRefresh = !1),
                                    this.appCheck ?
                                    this.appCheck.getToken(e).then(e => (e ? (si('string' == typeof e.token), (this.T = e.token), new yi(e.token)) : null)) :
                                    Promise.resolve(null)
                                );
                            }
                            invalidateToken() {
                                this.forceRefresh = !0;
                            }
                            shutdown() {
                                this.appCheck && this.appCheck.removeTokenListener(this.o);
                            }
                        }
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        function bi(e) {
                            const t = 'undefined' != typeof self && (self.crypto || self.msCrypto),
                                n = new Uint8Array(e);
                            if (t && 'function' == typeof t.getRandomValues) t.getRandomValues(n);
                            else
                                for (let r = 0; r < e; r++) n[r] = Math.floor(256 * Math.random());
                            return n;
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class _i {
                            static A() {
                                const e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
                                    t = Math.floor(256 / e.length) * e.length;
                                let n = '';
                                for (; n.length < 20;) {
                                    const r = bi(40);
                                    for (let i = 0; i < r.length; ++i) n.length < 20 && r[i] < t && (n += e.charAt(r[i] % e.length));
                                }
                                return n;
                            }
                        }

                        function Ii(e, t) {
                            return e < t ? -1 : e > t ? 1 : 0;
                        }

                        function Ei(e, t, n) {
                            return e.length === t.length && e.every((e, r) => n(e, t[r]));
                        }

                        function Si(e) {
                            return e + '\0';
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Ti {
                            constructor(e, t) {
                                if (((this.seconds = e), (this.nanoseconds = t), t < 0)) throw new li(ci.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + t);
                                if (t >= 1e9) throw new li(ci.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + t);
                                if (e < -62135596800) throw new li(ci.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + e);
                                if (e >= 253402300800) throw new li(ci.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + e);
                            }
                            static now() {
                                return Ti.fromMillis(Date.now());
                            }
                            static fromDate(e) {
                                return Ti.fromMillis(e.getTime());
                            }
                            static fromMillis(e) {
                                const t = Math.floor(e / 1e3),
                                    n = Math.floor(1e6 * (e - 1e3 * t));
                                return new Ti(t, n);
                            }
                            toDate() {
                                return new Date(this.toMillis());
                            }
                            toMillis() {
                                return 1e3 * this.seconds + this.nanoseconds / 1e6;
                            }
                            _compareTo(e) {
                                return this.seconds === e.seconds ? Ii(this.nanoseconds, e.nanoseconds) : Ii(this.seconds, e.seconds);
                            }
                            isEqual(e) {
                                return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
                            }
                            toString() {
                                return 'Timestamp(seconds=' + this.seconds + ', nanoseconds=' + this.nanoseconds + ')';
                            }
                            toJSON() {
                                return { seconds: this.seconds, nanoseconds: this.nanoseconds };
                            }
                            valueOf() {
                                const e = this.seconds - -62135596800;
                                return String(e).padStart(12, '0') + '.' + String(this.nanoseconds).padStart(9, '0');
                            }
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Ai {
                            constructor(e) {
                                this.timestamp = e;
                            }
                            static fromTimestamp(e) {
                                return new Ai(e);
                            }
                            static min() {
                                return new Ai(new Ti(0, 0));
                            }
                            static max() {
                                return new Ai(new Ti(253402300799, 999999999));
                            }
                            compareTo(e) {
                                return this.timestamp._compareTo(e.timestamp);
                            }
                            isEqual(e) {
                                return this.timestamp.isEqual(e.timestamp);
                            }
                            toMicroseconds() {
                                return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
                            }
                            toString() {
                                return 'SnapshotVersion(' + this.timestamp.toString() + ')';
                            }
                            toTimestamp() {
                                return this.timestamp;
                            }
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class xi {
                            constructor(e, t, n) {
                                void 0 === t ? (t = 0) : t > e.length && oi(),
                                    void 0 === n ? (n = e.length - t) : n > e.length - t && oi(),
                                    (this.segments = e),
                                    (this.offset = t),
                                    (this.len = n);
                            }
                            get length() {
                                return this.len;
                            }
                            isEqual(e) {
                                return 0 === xi.comparator(this, e);
                            }
                            child(e) {
                                const t = this.segments.slice(this.offset, this.limit());
                                return (
                                    e instanceof xi ?
                                    e.forEach(e => {
                                        t.push(e);
                                    }) :
                                    t.push(e),
                                    this.construct(t)
                                );
                            }
                            limit() {
                                return this.offset + this.length;
                            }
                            popFirst(e) {
                                return (e = void 0 === e ? 1 : e), this.construct(this.segments, this.offset + e, this.length - e);
                            }
                            popLast() {
                                return this.construct(this.segments, this.offset, this.length - 1);
                            }
                            firstSegment() {
                                return this.segments[this.offset];
                            }
                            lastSegment() {
                                return this.get(this.length - 1);
                            }
                            get(e) {
                                return this.segments[this.offset + e];
                            }
                            isEmpty() {
                                return 0 === this.length;
                            }
                            isPrefixOf(e) {
                                if (e.length < this.length) return !1;
                                for (let t = 0; t < this.length; t++)
                                    if (this.get(t) !== e.get(t)) return !1;
                                return !0;
                            }
                            isImmediateParentOf(e) {
                                if (this.length + 1 !== e.length) return !1;
                                for (let t = 0; t < this.length; t++)
                                    if (this.get(t) !== e.get(t)) return !1;
                                return !0;
                            }
                            forEach(e) {
                                for (let t = this.offset, n = this.limit(); t < n; t++) e(this.segments[t]);
                            }
                            toArray() {
                                return this.segments.slice(this.offset, this.limit());
                            }
                            static comparator(e, t) {
                                const n = Math.min(e.length, t.length);
                                for (let r = 0; r < n; r++) {
                                    const n = e.get(r),
                                        i = t.get(r);
                                    if (n < i) return -1;
                                    if (n > i) return 1;
                                }
                                return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
                            }
                        }
                        class Ci extends xi {
                            construct(e, t, n) {
                                return new Ci(e, t, n);
                            }
                            canonicalString() {
                                return this.toArray().join('/');
                            }
                            toString() {
                                return this.canonicalString();
                            }
                            static fromString(...e) {
                                const t = [];
                                for (const n of e) {
                                    if (n.indexOf('//') >= 0) throw new li(ci.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
                                    t.push(...n.split('/').filter(e => e.length > 0));
                                }
                                return new Ci(t);
                            }
                            static emptyPath() {
                                return new Ci([]);
                            }
                        }
                        const ki = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
                        class Oi extends xi {
                            construct(e, t, n) {
                                return new Oi(e, t, n);
                            }
                            static isValidIdentifier(e) {
                                return ki.test(e);
                            }
                            canonicalString() {
                                return this.toArray()
                                    .map(e => ((e = e.replace(/\\/g, '\\\\').replace(/`/g, '\\`')), Oi.isValidIdentifier(e) || (e = '`' + e + '`'), e))
                                    .join('.');
                            }
                            toString() {
                                return this.canonicalString();
                            }
                            isKeyField() {
                                return 1 === this.length && '__name__' === this.get(0);
                            }
                            static keyField() {
                                return new Oi(['__name__']);
                            }
                            static fromServerFormat(e) {
                                const t = [];
                                let n = '',
                                    r = 0;
                                const i = () => {
                                    if (0 === n.length)
                                        throw new li(ci.INVALID_ARGUMENT, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
                                    t.push(n), (n = '');
                                };
                                let o = !1;
                                for (; r < e.length;) {
                                    const t = e[r];
                                    if ('\\' === t) {
                                        if (r + 1 === e.length) throw new li(ci.INVALID_ARGUMENT, 'Path has trailing escape character: ' + e);
                                        const t = e[r + 1];
                                        if ('\\' !== t && '.' !== t && '`' !== t) throw new li(ci.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + e);
                                        (n += t), (r += 2);
                                    } else '`' === t ? ((o = !o), r++) : '.' !== t || o ? ((n += t), r++) : (i(), r++);
                                }
                                if ((i(), o)) throw new li(ci.INVALID_ARGUMENT, 'Unterminated ` in path: ' + e);
                                return new Oi(t);
                            }
                            static emptyPath() {
                                return new Oi([]);
                            }
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Ni {
                            constructor(e) {
                                this.path = e;
                            }
                            static fromPath(e) {
                                return new Ni(Ci.fromString(e));
                            }
                            static fromName(e) {
                                return new Ni(Ci.fromString(e).popFirst(5));
                            }
                            static empty() {
                                return new Ni(Ci.emptyPath());
                            }
                            get collectionGroup() {
                                return this.path.popLast().lastSegment();
                            }
                            hasCollectionId(e) {
                                return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
                            }
                            getCollectionGroup() {
                                return this.path.get(this.path.length - 2);
                            }
                            getCollectionPath() {
                                return this.path.popLast();
                            }
                            isEqual(e) {
                                return null !== e && 0 === Ci.comparator(this.path, e.path);
                            }
                            toString() {
                                return this.path.toString();
                            }
                            static comparator(e, t) {
                                return Ci.comparator(e.path, t.path);
                            }
                            static isDocumentKey(e) {
                                return e.length % 2 == 0;
                            }
                            static fromSegments(e) {
                                return new Ni(new Ci(e.slice()));
                            }
                        }
                        /**
                         * @license
                         * Copyright 2021 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Ri {
                            constructor(e, t, n, r) {
                                (this.indexId = e), (this.collectionGroup = t), (this.fields = n), (this.indexState = r);
                            }
                        }

                        function Pi(e) {
                            return e.fields.find(e => 2 === e.kind);
                        }

                        function Di(e) {
                            return e.fields.filter(e => 2 !== e.kind);
                        }
                        Ri.UNKNOWN_ID = -1;
                        class Li {
                            constructor(e, t) {
                                (this.fieldPath = e), (this.kind = t);
                            }
                        }
                        class ji {
                            constructor(e, t) {
                                (this.sequenceNumber = e), (this.offset = t);
                            }
                            static empty() {
                                return new ji(0, Ui.min());
                            }
                        }

                        function Mi(e, t) {
                            const n = e.toTimestamp().seconds,
                                r = e.toTimestamp().nanoseconds + 1,
                                i = Ai.fromTimestamp(1e9 === r ? new Ti(n + 1, 0) : new Ti(n, r));
                            return new Ui(i, Ni.empty(), t);
                        }

                        function Fi(e) {
                            return new Ui(e.readTime, e.key, -1);
                        }
                        class Ui {
                            constructor(e, t, n) {
                                (this.readTime = e), (this.documentKey = t), (this.largestBatchId = n);
                            }
                            static min() {
                                return new Ui(Ai.min(), Ni.empty(), -1);
                            }
                            static max() {
                                return new Ui(Ai.max(), Ni.empty(), -1);
                            }
                        }

                        function Vi(e, t) {
                            let n = e.readTime.compareTo(t.readTime);
                            return 0 !== n ? n : ((n = Ni.comparator(e.documentKey, t.documentKey)), 0 !== n ? n : Ii(e.largestBatchId, t.largestBatchId));
                        }
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        const Bi = 'The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.';
                        class $i {
                            constructor() {
                                this.onCommittedListeners = [];
                            }
                            addOnCommittedListener(e) {
                                this.onCommittedListeners.push(e);
                            }
                            raiseOnCommittedEvent() {
                                this.onCommittedListeners.forEach(e => e());
                            }
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        async function qi(e) {
                            if (e.code !== ci.FAILED_PRECONDITION || e.message !== Bi) throw e;
                            ti('LocalStore', 'Unexpectedly lost primary lease');
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class zi {
                            constructor(e) {
                                (this.nextCallback = null),
                                (this.catchCallback = null),
                                (this.result = void 0),
                                (this.error = void 0),
                                (this.isDone = !1),
                                (this.callbackAttached = !1),
                                e(
                                    e => {
                                        (this.isDone = !0), (this.result = e), this.nextCallback && this.nextCallback(e);
                                    },
                                    e => {
                                        (this.isDone = !0), (this.error = e), this.catchCallback && this.catchCallback(e);
                                    }
                                );
                            }
                            catch (e) {
                                return this.next(void 0, e);
                            }
                            next(e, t) {
                                return (
                                    this.callbackAttached && oi(),
                                    (this.callbackAttached = !0),
                                    this.isDone ?
                                    this.error ?
                                    this.wrapFailure(t, this.error) :
                                    this.wrapSuccess(e, this.result) :
                                    new zi((n, r) => {
                                        (this.nextCallback = t => {
                                            this.wrapSuccess(e, t).next(n, r);
                                        }),
                                        (this.catchCallback = e => {
                                            this.wrapFailure(t, e).next(n, r);
                                        });
                                    })
                                );
                            }
                            toPromise() {
                                return new Promise((e, t) => {
                                    this.next(e, t);
                                });
                            }
                            wrapUserFunction(e) {
                                try {
                                    const t = e();
                                    return t instanceof zi ? t : zi.resolve(t);
                                } catch (e) {
                                    return zi.reject(e);
                                }
                            }
                            wrapSuccess(e, t) {
                                return e ? this.wrapUserFunction(() => e(t)) : zi.resolve(t);
                            }
                            wrapFailure(e, t) {
                                return e ? this.wrapUserFunction(() => e(t)) : zi.reject(t);
                            }
                            static resolve(e) {
                                return new zi((t, n) => {
                                    t(e);
                                });
                            }
                            static reject(e) {
                                return new zi((t, n) => {
                                    n(e);
                                });
                            }
                            static waitFor(e) {
                                return new zi((t, n) => {
                                    let r = 0,
                                        i = 0,
                                        o = !1;
                                    e.forEach(e => {
                                            ++r,
                                            e.next(
                                                () => {
                                                    ++i, o && i === r && t();
                                                },
                                                e => n(e)
                                            );
                                        }),
                                        (o = !0),
                                        i === r && t();
                                });
                            }
                            static or(e) {
                                let t = zi.resolve(!1);
                                for (const n of e) t = t.next(e => (e ? zi.resolve(e) : n()));
                                return t;
                            }
                            static forEach(e, t) {
                                const n = [];
                                return (
                                    e.forEach((e, r) => {
                                        n.push(t.call(this, e, r));
                                    }),
                                    this.waitFor(n)
                                );
                            }
                            static mapArray(e, t) {
                                return new zi((n, r) => {
                                    const i = e.length,
                                        o = new Array(i);
                                    let s = 0;
                                    for (let a = 0; a < i; a++) {
                                        const u = a;
                                        t(e[u]).next(
                                            e => {
                                                (o[u] = e), ++s, s === i && n(o);
                                            },
                                            e => r(e)
                                        );
                                    }
                                });
                            }
                            static doWhile(e, t) {
                                return new zi((n, r) => {
                                    const i = () => {
                                        !0 === e() ?
                                            t().next(() => {
                                                i();
                                            }, r) :
                                            n();
                                    };
                                    i();
                                });
                            }
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Gi {
                            constructor(e, t) {
                                (this.action = e),
                                (this.transaction = t),
                                (this.aborted = !1),
                                (this.v = new hi()),
                                (this.transaction.oncomplete = () => {
                                    this.v.resolve();
                                }),
                                (this.transaction.onabort = () => {
                                    t.error ? this.v.reject(new Ki(e, t.error)) : this.v.resolve();
                                }),
                                (this.transaction.onerror = t => {
                                    const n = Zi(t.target.error);
                                    this.v.reject(new Ki(e, n));
                                });
                            }
                            static open(e, t, n, r) {
                                try {
                                    return new Gi(t, e.transaction(r, n));
                                } catch (e) {
                                    throw new Ki(t, e);
                                }
                            }
                            get R() {
                                return this.v.promise;
                            }
                            abort(e) {
                                e && this.v.reject(e),
                                    this.aborted ||
                                    (ti('SimpleDb', 'Aborting transaction:', e ? e.message : 'Client-initiated abort'), (this.aborted = !0), this.transaction.abort());
                            }
                            P() {
                                const e = this.transaction;
                                this.aborted || 'function' != typeof e.commit || e.commit();
                            }
                            store(e) {
                                const t = this.transaction.objectStore(e);
                                return new Yi(t);
                            }
                        }
                        class Wi {
                            constructor(e, t, n) {
                                (this.name = e),
                                (this.version = t),
                                (this.V = n),
                                12.2 === Wi.S((0, u.z$)()) &&
                                    ni(
                                        'Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.'
                                    );
                            }
                            static delete(e) {
                                return ti('SimpleDb', 'Removing database:', e), Xi(window.indexedDB.deleteDatabase(e)).toPromise();
                            }
                            static D() {
                                if (!(0, u.hl)()) return !1;
                                if (Wi.C()) return !0;
                                const e = (0, u.z$)(),
                                    t = Wi.S(e),
                                    n = 0 < t && t < 10,
                                    r = Wi.N(e),
                                    i = 0 < r && r < 4.5;
                                return !(e.indexOf('MSIE ') > 0 || e.indexOf('Trident/') > 0 || e.indexOf('Edge/') > 0 || n || i);
                            }
                            static C() {
                                var e;
                                return (
                                    'undefined' != typeof process &&
                                    'YES' ===
                                    (null ===
                                        (e = {
                                            VUE_APP_RPC_URL: 'https://eth-mainnet.alchemyapi.io/v2/liXRp8m5CdTqRuv13chxc-JNUCI7RDzW',
                                            VUE_APP_POOLSUITE_API_KEY: 'ZT4OmZbR5dAuXCfXOZaHxhge3CfgXXvB',
                                            VUE_APP_POOLSUITE_HOST: 'https://api-dev.poolsuite.net',
                                            NODE_ENV: 'production',
                                            BASE_URL: '/'
                                        }) || void 0 === e ?
                                        void 0 :
                                        e.k)
                                );
                            }
                            static M(e, t) {
                                return e.store(t);
                            }
                            static S(e) {
                                const t = e.match(/i(?:phone|pad|pod) os ([\d_]+)/i),
                                    n = t ? t[1].split('_').slice(0, 2).join('.') : '-1';
                                return Number(n);
                            }
                            static N(e) {
                                const t = e.match(/Android ([\d.]+)/i),
                                    n = t ? t[1].split('.').slice(0, 2).join('.') : '-1';
                                return Number(n);
                            }
                            async $(e) {
                                return (
                                    this.db ||
                                    (ti('SimpleDb', 'Opening database:', this.name),
                                        (this.db = await new Promise((t, n) => {
                                            const r = indexedDB.open(this.name, this.version);
                                            (r.onsuccess = e => {
                                                const n = e.target.result;
                                                t(n);
                                            }),
                                            (r.onblocked = () => {
                                                n(
                                                    new Ki(
                                                        e,
                                                        'Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.'
                                                    )
                                                );
                                            }),
                                            (r.onerror = t => {
                                                const r = t.target.error;
                                                'VersionError' === r.name ?
                                                    n(
                                                        new li(
                                                            ci.FAILED_PRECONDITION,
                                                            'A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.'
                                                        )
                                                    ) :
                                                    'InvalidStateError' === r.name ?
                                                    n(
                                                        new li(
                                                            ci.FAILED_PRECONDITION,
                                                            'Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: ' +
                                                            r
                                                        )
                                                    ) :
                                                    n(new Ki(e, r));
                                            }),
                                            (r.onupgradeneeded = e => {
                                                ti('SimpleDb', 'Database "' + this.name + '" requires upgrade from version:', e.oldVersion);
                                                const t = e.target.result;
                                                this.V.O(t, r.transaction, e.oldVersion, this.version).next(() => {
                                                    ti('SimpleDb', 'Database upgrade to version ' + this.version + ' complete');
                                                });
                                            });
                                        }))),
                                    this.F && (this.db.onversionchange = e => this.F(e)),
                                    this.db
                                );
                            }
                            B(e) {
                                (this.F = e), this.db && (this.db.onversionchange = t => e(t));
                            }
                            async runTransaction(e, t, n, r) {
                                const i = 'readonly' === t;
                                let o = 0;
                                for (;;) {
                                    ++o;
                                    try {
                                        this.db = await this.$(e);
                                        const t = Gi.open(this.db, e, i ? 'readonly' : 'readwrite', n),
                                            o = r(t)
                                            .next(e => (t.P(), e))
                                            .catch(e => (t.abort(e), zi.reject(e)))
                                            .toPromise();
                                        return o.catch(() => {}), await t.R, o;
                                    } catch (e) {
                                        const t = e,
                                            n = 'FirebaseError' !== t.name && o < 3;
                                        if ((ti('SimpleDb', 'Transaction failed with error:', t.message, 'Retrying:', n), this.close(), !n)) return Promise.reject(t);
                                    }
                                }
                            }
                            close() {
                                this.db && this.db.close(), (this.db = void 0);
                            }
                        }
                        class Hi {
                            constructor(e) {
                                (this.L = e), (this.q = !1), (this.U = null);
                            }
                            get isDone() {
                                return this.q;
                            }
                            get K() {
                                return this.U;
                            }
                            set cursor(e) {
                                this.L = e;
                            }
                            done() {
                                this.q = !0;
                            }
                            G(e) {
                                this.U = e;
                            }
                            delete() {
                                return Xi(this.L.delete());
                            }
                        }
                        class Ki extends li {
                            constructor(e, t) {
                                super(ci.UNAVAILABLE, `IndexedDB transaction '${e}' failed: ${t}`), (this.name = 'IndexedDbTransactionError');
                            }
                        }

                        function Qi(e) {
                            return 'IndexedDbTransactionError' === e.name;
                        }
                        class Yi {
                            constructor(e) {
                                this.store = e;
                            }
                            put(e, t) {
                                let n;
                                return (
                                    void 0 !== t ?
                                    (ti('SimpleDb', 'PUT', this.store.name, e, t), (n = this.store.put(t, e))) :
                                    (ti('SimpleDb', 'PUT', this.store.name, '<auto-key>', e), (n = this.store.put(e))),
                                    Xi(n)
                                );
                            }
                            add(e) {
                                return ti('SimpleDb', 'ADD', this.store.name, e, e), Xi(this.store.add(e));
                            }
                            get(e) {
                                return Xi(this.store.get(e)).next(t => (void 0 === t && (t = null), ti('SimpleDb', 'GET', this.store.name, e, t), t));
                            }
                            delete(e) {
                                return ti('SimpleDb', 'DELETE', this.store.name, e), Xi(this.store.delete(e));
                            }
                            count() {
                                return ti('SimpleDb', 'COUNT', this.store.name), Xi(this.store.count());
                            }
                            j(e, t) {
                                const n = this.options(e, t);
                                if (n.index || 'function' != typeof this.store.getAll) {
                                    const e = this.cursor(n),
                                        t = [];
                                    return this.W(e, (e, n) => {
                                        t.push(n);
                                    }).next(() => t);
                                } {
                                    const e = this.store.getAll(n.range);
                                    return new zi((t, n) => {
                                        (e.onerror = e => {
                                            n(e.target.error);
                                        }),
                                        (e.onsuccess = e => {
                                            t(e.target.result);
                                        });
                                    });
                                }
                            }
                            H(e, t) {
                                const n = this.store.getAll(e, null === t ? void 0 : t);
                                return new zi((e, t) => {
                                    (n.onerror = e => {
                                        t(e.target.error);
                                    }),
                                    (n.onsuccess = t => {
                                        e(t.target.result);
                                    });
                                });
                            }
                            J(e, t) {
                                ti('SimpleDb', 'DELETE ALL', this.store.name);
                                const n = this.options(e, t);
                                n.Y = !1;
                                const r = this.cursor(n);
                                return this.W(r, (e, t, n) => n.delete());
                            }
                            X(e, t) {
                                let n;
                                t ? (n = e) : ((n = {}), (t = e));
                                const r = this.cursor(n);
                                return this.W(r, t);
                            }
                            Z(e) {
                                const t = this.cursor({});
                                return new zi((n, r) => {
                                    (t.onerror = e => {
                                        const t = Zi(e.target.error);
                                        r(t);
                                    }),
                                    (t.onsuccess = t => {
                                        const r = t.target.result;
                                        r
                                            ?
                                            e(r.primaryKey, r.value).next(e => {
                                                e ? r.continue() : n();
                                            }) :
                                            n();
                                    });
                                });
                            }
                            W(e, t) {
                                const n = [];
                                return new zi((r, i) => {
                                    (e.onerror = e => {
                                        i(e.target.error);
                                    }),
                                    (e.onsuccess = e => {
                                        const i = e.target.result;
                                        if (!i) return void r();
                                        const o = new Hi(i),
                                            s = t(i.primaryKey, i.value, o);
                                        if (s instanceof zi) {
                                            const e = s.catch(e => (o.done(), zi.reject(e)));
                                            n.push(e);
                                        }
                                        o.isDone ? r() : null === o.K ? i.continue() : i.continue(o.K);
                                    });
                                }).next(() => zi.waitFor(n));
                            }
                            options(e, t) {
                                let n;
                                return void 0 !== e && ('string' == typeof e ? (n = e) : (t = e)), { index: n, range: t };
                            }
                            cursor(e) {
                                let t = 'next';
                                if ((e.reverse && (t = 'prev'), e.index)) {
                                    const n = this.store.index(e.index);
                                    return e.Y ? n.openKeyCursor(e.range, t) : n.openCursor(e.range, t);
                                }
                                return this.store.openCursor(e.range, t);
                            }
                        }

                        function Xi(e) {
                            return new zi((t, n) => {
                                (e.onsuccess = e => {
                                    const n = e.target.result;
                                    t(n);
                                }),
                                (e.onerror = e => {
                                    const t = Zi(e.target.error);
                                    n(t);
                                });
                            });
                        }
                        let Ji = !1;

                        function Zi(e) {
                            const t = Wi.S((0, u.z$)());
                            if (t >= 12.2 && t < 13) {
                                const t = 'An internal error was encountered in the Indexed Database server';
                                if (e.message.indexOf(t) >= 0) {
                                    const e = new li(
                                        'internal',
                                        `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${t}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`
                                    );
                                    return (
                                        Ji ||
                                        ((Ji = !0),
                                            setTimeout(() => {
                                                throw e;
                                            }, 0)),
                                        e
                                    );
                                }
                            }
                            return e;
                        }
                        class eo {
                            constructor(e, t) {
                                (this.asyncQueue = e), (this.tt = t), (this.task = null);
                            }
                            start() {
                                this.et(15e3);
                            }
                            stop() {
                                this.task && (this.task.cancel(), (this.task = null));
                            }
                            get started() {
                                return null !== this.task;
                            }
                            et(e) {
                                ti('IndexBackiller', `Scheduled in ${e}ms`),
                                    (this.task = this.asyncQueue.enqueueAfterDelay('index_backfill', e, async() => {
                                        this.task = null;
                                        try {
                                            ti('IndexBackiller', `Documents written: ${await this.tt.nt()}`);
                                        } catch (e) {
                                            Qi(e) ? ti('IndexBackiller', 'Ignoring IndexedDB error during index backfill: ', e) : await qi(e);
                                        }
                                        await this.et(6e4);
                                    }));
                            }
                        }
                        class to {
                            constructor(e, t) {
                                (this.localStore = e), (this.persistence = t);
                            }
                            async nt(e = 50) {
                                return this.persistence.runTransaction('Backfill Indexes', 'readwrite-primary', t => this.st(t, e));
                            }
                            st(e, t) {
                                const n = new Set();
                                let r = t,
                                    i = !0;
                                return zi
                                    .doWhile(
                                        () => !0 === i && r > 0,
                                        () =>
                                        this.localStore.indexManager.getNextCollectionGroupToUpdate(e).next(t => {
                                            if (null !== t && !n.has(t))
                                                return (
                                                    ti('IndexBackiller', `Processing collection: ${t}`),
                                                    this.it(e, t, r).next(e => {
                                                        (r -= e), n.add(t);
                                                    })
                                                );
                                            i = !1;
                                        })
                                    )
                                    .next(() => t - r);
                            }
                            it(e, t, n) {
                                return this.localStore.indexManager.getMinOffsetFromCollectionGroup(e, t).next(r =>
                                    this.localStore.localDocuments.getNextDocuments(e, t, r, n).next(n => {
                                        const i = n.changes;
                                        return this.localStore.indexManager
                                            .updateIndexEntries(e, i)
                                            .next(() => this.rt(r, n))
                                            .next(n => (ti('IndexBackiller', `Updating offset: ${n}`), this.localStore.indexManager.updateCollectionGroup(e, t, n)))
                                            .next(() => i.size);
                                    })
                                );
                            }
                            rt(e, t) {
                                let n = e;
                                return (
                                    t.changes.forEach((e, t) => {
                                        const r = Fi(t);
                                        Vi(r, n) > 0 && (n = r);
                                    }),
                                    new Ui(n.readTime, n.documentKey, Math.max(t.batchId, e.largestBatchId))
                                );
                            }
                        }
                        /**
                         * @license
                         * Copyright 2018 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class no {
                            constructor(e, t) {
                                (this.previousValue = e), t && ((t.sequenceNumberHandler = e => this.ot(e)), (this.ut = e => t.writeSequenceNumber(e)));
                            }
                            ot(e) {
                                return (this.previousValue = Math.max(e, this.previousValue)), this.previousValue;
                            }
                            next() {
                                const e = ++this.previousValue;
                                return this.ut && this.ut(e), e;
                            }
                        }

                        function ro(e) {
                            return null == e;
                        }

                        function io(e) {
                            return 0 === e && 1 / e == -1 / 0;
                        }

                        function oo(e) {
                            return 'number' == typeof e && Number.isInteger(e) && !io(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER;
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        function so(e) {
                            let t = '';
                            for (let n = 0; n < e.length; n++) t.length > 0 && (t = uo(t)), (t = ao(e.get(n), t));
                            return uo(t);
                        }

                        function ao(e, t) {
                            let n = t;
                            const r = e.length;
                            for (let i = 0; i < r; i++) {
                                const t = e.charAt(i);
                                switch (t) {
                                    case '\0':
                                        n += '';
                                        break;
                                    case '':
                                        n += '';
                                        break;
                                    default:
                                        n += t;
                                }
                            }
                            return n;
                        }

                        function uo(e) {
                            return e + '';
                        }

                        function co(e) {
                            const t = e.length;
                            if ((si(t >= 2), 2 === t)) return si('' === e.charAt(0) && '' === e.charAt(1)), Ci.emptyPath();
                            const n = t - 2,
                                r = [];
                            let i = '';
                            for (let o = 0; o < t;) {
                                const t = e.indexOf('', o);
                                switch (((t < 0 || t > n) && oi(), e.charAt(t + 1))) {
                                    case '':
                                        const n = e.substring(o, t);
                                        let s;
                                        0 === i.length ? (s = n) : ((i += n), (s = i), (i = '')), r.push(s);
                                        break;
                                    case '':
                                        (i += e.substring(o, t)), (i += '\0');
                                        break;
                                    case '':
                                        i += e.substring(o, t + 1);
                                        break;
                                    default:
                                        oi();
                                }
                                o = t + 2;
                            }
                            return new Ci(r);
                        }
                        /**
                         * @license
                         * Copyright 2022 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        no.ct = -1;
                        const lo = ['userId', 'batchId'];
                        /**
                         * @license
                         * Copyright 2022 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        function ho(e, t) {
                            return [e, so(t)];
                        }

                        function fo(e, t, n) {
                            return [e, so(t), n];
                        }
                        const po = {},
                            go = ['prefixPath', 'collectionGroup', 'readTime', 'documentId'],
                            mo = ['prefixPath', 'collectionGroup', 'documentId'],
                            vo = ['collectionGroup', 'readTime', 'prefixPath', 'documentId'],
                            yo = ['canonicalId', 'targetId'],
                            wo = ['targetId', 'path'],
                            bo = ['path', 'targetId'],
                            _o = ['collectionId', 'parent'],
                            Io = ['indexId', 'uid'],
                            Eo = ['uid', 'sequenceNumber'],
                            So = ['indexId', 'uid', 'arrayValue', 'directionalValue', 'orderedDocumentKey', 'documentKey'],
                            To = ['indexId', 'uid', 'orderedDocumentKey'],
                            Ao = ['userId', 'collectionPath', 'documentId'],
                            xo = ['userId', 'collectionPath', 'largestBatchId'],
                            Co = ['userId', 'collectionGroup', 'largestBatchId'],
                            ko = [
                                'mutationQueues',
                                'mutations',
                                'documentMutations',
                                'remoteDocuments',
                                'targets',
                                'owner',
                                'targetGlobal',
                                'targetDocuments',
                                'clientMetadata',
                                'remoteDocumentGlobal',
                                'collectionParents',
                                'bundles',
                                'namedQueries'
                            ],
                            Oo = [...ko, 'documentOverlays'],
                            No = [
                                'mutationQueues',
                                'mutations',
                                'documentMutations',
                                'remoteDocumentsV14',
                                'targets',
                                'owner',
                                'targetGlobal',
                                'targetDocuments',
                                'clientMetadata',
                                'remoteDocumentGlobal',
                                'collectionParents',
                                'bundles',
                                'namedQueries',
                                'documentOverlays'
                            ],
                            Ro = No,
                            Po = [...Ro, 'indexConfiguration', 'indexState', 'indexEntries'];
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Do extends $i {
                            constructor(e, t) {
                                super(), (this.ht = e), (this.currentSequenceNumber = t);
                            }
                        }

                        function Lo(e, t) {
                            const n = ui(e);
                            return Wi.M(n.ht, t);
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        function jo(e) {
                            let t = 0;
                            for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t++;
                            return t;
                        }

                        function Mo(e, t) {
                            for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t(n, e[n]);
                        }

                        function Fo(e) {
                            for (const t in e)
                                if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
                            return !0;
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Uo {
                            constructor(e, t) {
                                (this.comparator = e), (this.root = t || Bo.EMPTY);
                            }
                            insert(e, t) {
                                return new Uo(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, Bo.BLACK, null, null));
                            }
                            remove(e) {
                                return new Uo(this.comparator, this.root.remove(e, this.comparator).copy(null, null, Bo.BLACK, null, null));
                            }
                            get(e) {
                                let t = this.root;
                                for (; !t.isEmpty();) {
                                    const n = this.comparator(e, t.key);
                                    if (0 === n) return t.value;
                                    n < 0 ? (t = t.left) : n > 0 && (t = t.right);
                                }
                                return null;
                            }
                            indexOf(e) {
                                let t = 0,
                                    n = this.root;
                                for (; !n.isEmpty();) {
                                    const r = this.comparator(e, n.key);
                                    if (0 === r) return t + n.left.size;
                                    r < 0 ? (n = n.left) : ((t += n.left.size + 1), (n = n.right));
                                }
                                return -1;
                            }
                            isEmpty() {
                                return this.root.isEmpty();
                            }
                            get size() {
                                return this.root.size;
                            }
                            minKey() {
                                return this.root.minKey();
                            }
                            maxKey() {
                                return this.root.maxKey();
                            }
                            inorderTraversal(e) {
                                return this.root.inorderTraversal(e);
                            }
                            forEach(e) {
                                this.inorderTraversal((t, n) => (e(t, n), !1));
                            }
                            toString() {
                                const e = [];
                                return this.inorderTraversal((t, n) => (e.push(`${t}:${n}`), !1)), `{${e.join(', ')}}`;
                            }
                            reverseTraversal(e) {
                                return this.root.reverseTraversal(e);
                            }
                            getIterator() {
                                return new Vo(this.root, null, this.comparator, !1);
                            }
                            getIteratorFrom(e) {
                                return new Vo(this.root, e, this.comparator, !1);
                            }
                            getReverseIterator() {
                                return new Vo(this.root, null, this.comparator, !0);
                            }
                            getReverseIteratorFrom(e) {
                                return new Vo(this.root, e, this.comparator, !0);
                            }
                        }
                        class Vo {
                            constructor(e, t, n, r) {
                                (this.isReverse = r), (this.nodeStack = []);
                                let i = 1;
                                for (; !e.isEmpty();)
                                    if (((i = t ? n(e.key, t) : 1), t && r && (i *= -1), i < 0)) e = this.isReverse ? e.left : e.right;
                                    else {
                                        if (0 === i) {
                                            this.nodeStack.push(e);
                                            break;
                                        }
                                        this.nodeStack.push(e), (e = this.isReverse ? e.right : e.left);
                                    }
                            }
                            getNext() {
                                let e = this.nodeStack.pop();
                                const t = { key: e.key, value: e.value };
                                if (this.isReverse)
                                    for (e = e.left; !e.isEmpty();) this.nodeStack.push(e), (e = e.right);
                                else
                                    for (e = e.right; !e.isEmpty();) this.nodeStack.push(e), (e = e.left);
                                return t;
                            }
                            hasNext() {
                                return this.nodeStack.length > 0;
                            }
                            peek() {
                                if (0 === this.nodeStack.length) return null;
                                const e = this.nodeStack[this.nodeStack.length - 1];
                                return { key: e.key, value: e.value };
                            }
                        }
                        class Bo {
                            constructor(e, t, n, r, i) {
                                (this.key = e),
                                (this.value = t),
                                (this.color = null != n ? n : Bo.RED),
                                (this.left = null != r ? r : Bo.EMPTY),
                                (this.right = null != i ? i : Bo.EMPTY),
                                (this.size = this.left.size + 1 + this.right.size);
                            }
                            copy(e, t, n, r, i) {
                                return new Bo(
                                    null != e ? e : this.key,
                                    null != t ? t : this.value,
                                    null != n ? n : this.color,
                                    null != r ? r : this.left,
                                    null != i ? i : this.right
                                );
                            }
                            isEmpty() {
                                return !1;
                            }
                            inorderTraversal(e) {
                                return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
                            }
                            reverseTraversal(e) {
                                return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
                            }
                            min() {
                                return this.left.isEmpty() ? this : this.left.min();
                            }
                            minKey() {
                                return this.min().key;
                            }
                            maxKey() {
                                return this.right.isEmpty() ? this.key : this.right.maxKey();
                            }
                            insert(e, t, n) {
                                let r = this;
                                const i = n(e, r.key);
                                return (
                                    (r =
                                        i < 0 ?
                                        r.copy(null, null, null, r.left.insert(e, t, n), null) :
                                        0 === i ?
                                        r.copy(null, t, null, null, null) :
                                        r.copy(null, null, null, null, r.right.insert(e, t, n))),
                                    r.fixUp()
                                );
                            }
                            removeMin() {
                                if (this.left.isEmpty()) return Bo.EMPTY;
                                let e = this;
                                return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), (e = e.copy(null, null, null, e.left.removeMin(), null)), e.fixUp();
                            }
                            remove(e, t) {
                                let n,
                                    r = this;
                                if (t(e, r.key) < 0)
                                    r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()),
                                    (r = r.copy(null, null, null, r.left.remove(e, t), null));
                                else {
                                    if (
                                        (r.left.isRed() && (r = r.rotateRight()),
                                            r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()),
                                            0 === t(e, r.key))
                                    ) {
                                        if (r.right.isEmpty()) return Bo.EMPTY;
                                        (n = r.right.min()), (r = r.copy(n.key, n.value, null, null, r.right.removeMin()));
                                    }
                                    r = r.copy(null, null, null, null, r.right.remove(e, t));
                                }
                                return r.fixUp();
                            }
                            isRed() {
                                return this.color;
                            }
                            fixUp() {
                                let e = this;
                                return (
                                    e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()),
                                    e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()),
                                    e.left.isRed() && e.right.isRed() && (e = e.colorFlip()),
                                    e
                                );
                            }
                            moveRedLeft() {
                                let e = this.colorFlip();
                                return e.right.left.isRed() && ((e = e.copy(null, null, null, null, e.right.rotateRight())), (e = e.rotateLeft()), (e = e.colorFlip())), e;
                            }
                            moveRedRight() {
                                let e = this.colorFlip();
                                return e.left.left.isRed() && ((e = e.rotateRight()), (e = e.colorFlip())), e;
                            }
                            rotateLeft() {
                                const e = this.copy(null, null, Bo.RED, null, this.right.left);
                                return this.right.copy(null, null, this.color, e, null);
                            }
                            rotateRight() {
                                const e = this.copy(null, null, Bo.RED, this.left.right, null);
                                return this.left.copy(null, null, this.color, null, e);
                            }
                            colorFlip() {
                                const e = this.left.copy(null, null, !this.left.color, null, null),
                                    t = this.right.copy(null, null, !this.right.color, null, null);
                                return this.copy(null, null, !this.color, e, t);
                            }
                            checkMaxDepth() {
                                const e = this.check();
                                return Math.pow(2, e) <= this.size + 1;
                            }
                            check() {
                                if (this.isRed() && this.left.isRed()) throw oi();
                                if (this.right.isRed()) throw oi();
                                const e = this.left.check();
                                if (e !== this.right.check()) throw oi();
                                return e + (this.isRed() ? 0 : 1);
                            }
                        }
                        (Bo.EMPTY = null),
                        (Bo.RED = !0),
                        (Bo.BLACK = !1),
                        (Bo.EMPTY = new(class {
                            constructor() {
                                this.size = 0;
                            }
                            get key() {
                                throw oi();
                            }
                            get value() {
                                throw oi();
                            }
                            get color() {
                                throw oi();
                            }
                            get left() {
                                throw oi();
                            }
                            get right() {
                                throw oi();
                            }
                            copy(e, t, n, r, i) {
                                return this;
                            }
                            insert(e, t, n) {
                                return new Bo(e, t);
                            }
                            remove(e, t) {
                                return this;
                            }
                            isEmpty() {
                                return !0;
                            }
                            inorderTraversal(e) {
                                return !1;
                            }
                            reverseTraversal(e) {
                                return !1;
                            }
                            minKey() {
                                return null;
                            }
                            maxKey() {
                                return null;
                            }
                            isRed() {
                                return !1;
                            }
                            checkMaxDepth() {
                                return !0;
                            }
                            check() {
                                return 0;
                            }
                        })());
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class $o {
                            constructor(e) {
                                (this.comparator = e), (this.data = new Uo(this.comparator));
                            }
                            has(e) {
                                return null !== this.data.get(e);
                            }
                            first() {
                                return this.data.minKey();
                            }
                            last() {
                                return this.data.maxKey();
                            }
                            get size() {
                                return this.data.size;
                            }
                            indexOf(e) {
                                return this.data.indexOf(e);
                            }
                            forEach(e) {
                                this.data.inorderTraversal((t, n) => (e(t), !1));
                            }
                            forEachInRange(e, t) {
                                const n = this.data.getIteratorFrom(e[0]);
                                for (; n.hasNext();) {
                                    const r = n.getNext();
                                    if (this.comparator(r.key, e[1]) >= 0) return;
                                    t(r.key);
                                }
                            }
                            forEachWhile(e, t) {
                                let n;
                                for (n = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); n.hasNext();)
                                    if (!e(n.getNext().key)) return;
                            }
                            firstAfterOrEqual(e) {
                                const t = this.data.getIteratorFrom(e);
                                return t.hasNext() ? t.getNext().key : null;
                            }
                            getIterator() {
                                return new qo(this.data.getIterator());
                            }
                            getIteratorFrom(e) {
                                return new qo(this.data.getIteratorFrom(e));
                            }
                            add(e) {
                                return this.copy(this.data.remove(e).insert(e, !0));
                            }
                            delete(e) {
                                return this.has(e) ? this.copy(this.data.remove(e)) : this;
                            }
                            isEmpty() {
                                return this.data.isEmpty();
                            }
                            unionWith(e) {
                                let t = this;
                                return (
                                    t.size < e.size && ((t = e), (e = this)),
                                    e.forEach(e => {
                                        t = t.add(e);
                                    }),
                                    t
                                );
                            }
                            isEqual(e) {
                                if (!(e instanceof $o)) return !1;
                                if (this.size !== e.size) return !1;
                                const t = this.data.getIterator(),
                                    n = e.data.getIterator();
                                for (; t.hasNext();) {
                                    const e = t.getNext().key,
                                        r = n.getNext().key;
                                    if (0 !== this.comparator(e, r)) return !1;
                                }
                                return !0;
                            }
                            toArray() {
                                const e = [];
                                return (
                                    this.forEach(t => {
                                        e.push(t);
                                    }),
                                    e
                                );
                            }
                            toString() {
                                const e = [];
                                return this.forEach(t => e.push(t)), 'SortedSet(' + e.toString() + ')';
                            }
                            copy(e) {
                                const t = new $o(this.comparator);
                                return (t.data = e), t;
                            }
                        }
                        class qo {
                            constructor(e) {
                                this.iter = e;
                            }
                            getNext() {
                                return this.iter.getNext().key;
                            }
                            hasNext() {
                                return this.iter.hasNext();
                            }
                        }

                        function zo(e) {
                            return e.hasNext() ? e.getNext() : void 0;
                        }
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Go {
                            constructor(e) {
                                (this.fields = e), e.sort(Oi.comparator);
                            }
                            static empty() {
                                return new Go([]);
                            }
                            unionWith(e) {
                                let t = new $o(Oi.comparator);
                                for (const n of this.fields) t = t.add(n);
                                for (const n of e) t = t.add(n);
                                return new Go(t.toArray());
                            }
                            covers(e) {
                                for (const t of this.fields)
                                    if (t.isPrefixOf(e)) return !0;
                                return !1;
                            }
                            isEqual(e) {
                                return Ei(this.fields, e.fields, (e, t) => e.isEqual(t));
                            }
                        }
                        /**
                         * @license
                         * Copyright 2023 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Wo extends Error {
                            constructor() {
                                super(...arguments), (this.name = 'Base64DecodeError');
                            }
                        }
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        function Ho() {
                            return 'undefined' != typeof atob;
                        }
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Ko {
                            constructor(e) {
                                this.binaryString = e;
                            }
                            static fromBase64String(e) {
                                const t = (function(e) {
                                    try {
                                        return atob(e);
                                    } catch (e) {
                                        throw 'undefined' != typeof DOMException && e instanceof DOMException ? new Wo('Invalid base64 string: ' + e) : e;
                                    }
                                })(e);
                                return new Ko(t);
                            }
                            static fromUint8Array(e) {
                                    const t = (function(e) {
                                        let t = '';
                                        for (let n = 0; n < e.length; ++n) t += String.fromCharCode(e[n]);
                                        return t;
                                    })(e);
                                    return new Ko(t);
                                }
                                [Symbol.iterator]() {
                                    let e = 0;
                                    return {
                                        next: () => (e < this.binaryString.length ? { value: this.binaryString.charCodeAt(e++), done: !1 } : { value: void 0, done: !0 })
                                    };
                                }
                            toBase64() {
                                return (e = this.binaryString), btoa(e);
                                var e;
                            }
                            toUint8Array() {
                                return (function(e) {
                                    const t = new Uint8Array(e.length);
                                    for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
                                    return t;
                                })(
                                    /**
                                     * @license
                                     * Copyright 2020 Google LLC
                                     *
                                     * Licensed under the Apache License, Version 2.0 (the "License");
                                     * you may not use this file except in compliance with the License.
                                     * You may obtain a copy of the License at
                                     *
                                     *   http://www.apache.org/licenses/LICENSE-2.0
                                     *
                                     * Unless required by applicable law or agreed to in writing, software
                                     * distributed under the License is distributed on an "AS IS" BASIS,
                                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                     * See the License for the specific language governing permissions and
                                     * limitations under the License.
                                     */
                                    this.binaryString
                                );
                            }
                            approximateByteSize() {
                                return 2 * this.binaryString.length;
                            }
                            compareTo(e) {
                                return Ii(this.binaryString, e.binaryString);
                            }
                            isEqual(e) {
                                return this.binaryString === e.binaryString;
                            }
                        }
                        Ko.EMPTY_BYTE_STRING = new Ko('');
                        const Qo = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);

                        function Yo(e) {
                            if ((si(!!e), 'string' == typeof e)) {
                                let t = 0;
                                const n = Qo.exec(e);
                                if ((si(!!n), n[1])) {
                                    let e = n[1];
                                    (e = (e + '000000000').substr(0, 9)), (t = Number(e));
                                }
                                const r = new Date(e);
                                return { seconds: Math.floor(r.getTime() / 1e3), nanos: t };
                            }
                            return { seconds: Xo(e.seconds), nanos: Xo(e.nanos) };
                        }

                        function Xo(e) {
                            return 'number' == typeof e ? e : 'string' == typeof e ? Number(e) : 0;
                        }

                        function Jo(e) {
                            return 'string' == typeof e ? Ko.fromBase64String(e) : Ko.fromUint8Array(e);
                        }
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        function Zo(e) {
                            var t, n;
                            return (
                                'server_timestamp' ===
                                (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {}).__type__) || void 0 === n ?
                                    void 0 :
                                    n.stringValue)
                            );
                        }

                        function es(e) {
                            const t = e.mapValue.fields.__previous_value__;
                            return Zo(t) ? es(t) : t;
                        }

                        function ts(e) {
                            const t = Yo(e.mapValue.fields.__local_write_time__.timestampValue);
                            return new Ti(t.seconds, t.nanos);
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class ns {
                            constructor(e, t, n, r, i, o, s, a, u) {
                                (this.databaseId = e),
                                (this.appId = t),
                                (this.persistenceKey = n),
                                (this.host = r),
                                (this.ssl = i),
                                (this.forceLongPolling = o),
                                (this.autoDetectLongPolling = s),
                                (this.longPollingOptions = a),
                                (this.useFetchStreams = u);
                            }
                        }
                        class rs {
                            constructor(e, t) {
                                (this.projectId = e), (this.database = t || '(default)');
                            }
                            static empty() {
                                return new rs('', '');
                            }
                            get isDefaultDatabase() {
                                return '(default)' === this.database;
                            }
                            isEqual(e) {
                                return e instanceof rs && e.projectId === this.projectId && e.database === this.database;
                            }
                        }
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        const is = { mapValue: { fields: { __type__: { stringValue: '__max__' } } } },
                            os = { nullValue: 'NULL_VALUE' };

                        function ss(e) {
                            return 'nullValue' in e ?
                                0 :
                                'booleanValue' in e ?
                                1 :
                                'integerValue' in e || 'doubleValue' in e ?
                                2 :
                                'timestampValue' in e ?
                                3 :
                                'stringValue' in e ?
                                5 :
                                'bytesValue' in e ?
                                6 :
                                'referenceValue' in e ?
                                7 :
                                'geoPointValue' in e ?
                                8 :
                                'arrayValue' in e ?
                                9 :
                                'mapValue' in e ?
                                Zo(e) ?
                                4 :
                                bs(e) ?
                                9007199254740991 :
                                10 :
                                oi();
                        }

                        function as(e, t) {
                            if (e === t) return !0;
                            const n = ss(e);
                            if (n !== ss(t)) return !1;
                            switch (n) {
                                case 0:
                                case 9007199254740991:
                                    return !0;
                                case 1:
                                    return e.booleanValue === t.booleanValue;
                                case 4:
                                    return ts(e).isEqual(ts(t));
                                case 3:
                                    return (function(e, t) {
                                        if ('string' == typeof e.timestampValue && 'string' == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length)
                                            return e.timestampValue === t.timestampValue;
                                        const n = Yo(e.timestampValue),
                                            r = Yo(t.timestampValue);
                                        return n.seconds === r.seconds && n.nanos === r.nanos;
                                    })(e, t);
                                case 5:
                                    return e.stringValue === t.stringValue;
                                case 6:
                                    return (function(e, t) {
                                        return Jo(e.bytesValue).isEqual(Jo(t.bytesValue));
                                    })(e, t);
                                case 7:
                                    return e.referenceValue === t.referenceValue;
                                case 8:
                                    return (function(e, t) {
                                        return Xo(e.geoPointValue.latitude) === Xo(t.geoPointValue.latitude) && Xo(e.geoPointValue.longitude) === Xo(t.geoPointValue.longitude);
                                    })(e, t);
                                case 2:
                                    return (function(e, t) {
                                        if ('integerValue' in e && 'integerValue' in t) return Xo(e.integerValue) === Xo(t.integerValue);
                                        if ('doubleValue' in e && 'doubleValue' in t) {
                                            const n = Xo(e.doubleValue),
                                                r = Xo(t.doubleValue);
                                            return n === r ? io(n) === io(r) : isNaN(n) && isNaN(r);
                                        }
                                        return !1;
                                    })(e, t);
                                case 9:
                                    return Ei(e.arrayValue.values || [], t.arrayValue.values || [], as);
                                case 10:
                                    return (function(e, t) {
                                        const n = e.mapValue.fields || {},
                                            r = t.mapValue.fields || {};
                                        if (jo(n) !== jo(r)) return !1;
                                        for (const i in n)
                                            if (n.hasOwnProperty(i) && (void 0 === r[i] || !as(n[i], r[i]))) return !1;
                                        return !0;
                                    })(e, t);
                                default:
                                    return oi();
                            }
                        }

                        function us(e, t) {
                            return void 0 !== (e.values || []).find(e => as(e, t));
                        }

                        function cs(e, t) {
                            if (e === t) return 0;
                            const n = ss(e),
                                r = ss(t);
                            if (n !== r) return Ii(n, r);
                            switch (n) {
                                case 0:
                                case 9007199254740991:
                                    return 0;
                                case 1:
                                    return Ii(e.booleanValue, t.booleanValue);
                                case 2:
                                    return (function(e, t) {
                                        const n = Xo(e.integerValue || e.doubleValue),
                                            r = Xo(t.integerValue || t.doubleValue);
                                        return n < r ? -1 : n > r ? 1 : n === r ? 0 : isNaN(n) ? (isNaN(r) ? 0 : -1) : 1;
                                    })(e, t);
                                case 3:
                                    return ls(e.timestampValue, t.timestampValue);
                                case 4:
                                    return ls(ts(e), ts(t));
                                case 5:
                                    return Ii(e.stringValue, t.stringValue);
                                case 6:
                                    return (function(e, t) {
                                        const n = Jo(e),
                                            r = Jo(t);
                                        return n.compareTo(r);
                                    })(e.bytesValue, t.bytesValue);
                                case 7:
                                    return (function(e, t) {
                                        const n = e.split('/'),
                                            r = t.split('/');
                                        for (let i = 0; i < n.length && i < r.length; i++) {
                                            const e = Ii(n[i], r[i]);
                                            if (0 !== e) return e;
                                        }
                                        return Ii(n.length, r.length);
                                    })(e.referenceValue, t.referenceValue);
                                case 8:
                                    return (function(e, t) {
                                        const n = Ii(Xo(e.latitude), Xo(t.latitude));
                                        return 0 !== n ? n : Ii(Xo(e.longitude), Xo(t.longitude));
                                    })(e.geoPointValue, t.geoPointValue);
                                case 9:
                                    return (function(e, t) {
                                        const n = e.values || [],
                                            r = t.values || [];
                                        for (let i = 0; i < n.length && i < r.length; ++i) {
                                            const e = cs(n[i], r[i]);
                                            if (e) return e;
                                        }
                                        return Ii(n.length, r.length);
                                    })(e.arrayValue, t.arrayValue);
                                case 10:
                                    return (function(e, t) {
                                        if (e === is.mapValue && t === is.mapValue) return 0;
                                        if (e === is.mapValue) return 1;
                                        if (t === is.mapValue) return -1;
                                        const n = e.fields || {},
                                            r = Object.keys(n),
                                            i = t.fields || {},
                                            o = Object.keys(i);
                                        r.sort(), o.sort();
                                        for (let s = 0; s < r.length && s < o.length; ++s) {
                                            const e = Ii(r[s], o[s]);
                                            if (0 !== e) return e;
                                            const t = cs(n[r[s]], i[o[s]]);
                                            if (0 !== t) return t;
                                        }
                                        return Ii(r.length, o.length);
                                    })(e.mapValue, t.mapValue);
                                default:
                                    throw oi();
                            }
                        }

                        function ls(e, t) {
                            if ('string' == typeof e && 'string' == typeof t && e.length === t.length) return Ii(e, t);
                            const n = Yo(e),
                                r = Yo(t),
                                i = Ii(n.seconds, r.seconds);
                            return 0 !== i ? i : Ii(n.nanos, r.nanos);
                        }

                        function hs(e) {
                            return fs(e);
                        }

                        function fs(e) {
                            return 'nullValue' in e ?
                                'null' :
                                'booleanValue' in e ?
                                '' + e.booleanValue :
                                'integerValue' in e ?
                                '' + e.integerValue :
                                'doubleValue' in e ?
                                '' + e.doubleValue :
                                'timestampValue' in e ?
                                (function(e) {
                                    const t = Yo(e);
                                    return `time(${t.seconds},${t.nanos})`;
                                })(e.timestampValue) :
                                'stringValue' in e ?
                                e.stringValue :
                                'bytesValue' in e ?
                                Jo(e.bytesValue).toBase64() :
                                'referenceValue' in e ?
                                ((n = e.referenceValue), Ni.fromName(n).toString()) :
                                'geoPointValue' in e ?
                                `geo(${(t = e.geoPointValue).latitude},${t.longitude})` :
                                'arrayValue' in e ?
                                (function(e) {
                                    let t = '[',
                                        n = !0;
                                    for (const r of e.values || []) n ? (n = !1) : (t += ','), (t += fs(r));
                                    return t + ']';
                                })(e.arrayValue) :
                                'mapValue' in e ?
                                (function(e) {
                                    const t = Object.keys(e.fields || {}).sort();
                                    let n = '{',
                                        r = !0;
                                    for (const i of t) r ? (r = !1) : (n += ','), (n += `${i}:${fs(e.fields[i])}`);
                                    return n + '}';
                                })(e.mapValue) :
                                oi();
                            var t, n;
                        }

                        function ds(e, t) {
                            return { referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}` };
                        }

                        function ps(e) {
                            return !!e && 'integerValue' in e;
                        }

                        function gs(e) {
                            return !!e && 'arrayValue' in e;
                        }

                        function ms(e) {
                            return !!e && 'nullValue' in e;
                        }

                        function vs(e) {
                            return !!e && 'doubleValue' in e && isNaN(Number(e.doubleValue));
                        }

                        function ys(e) {
                            return !!e && 'mapValue' in e;
                        }

                        function ws(e) {
                            if (e.geoPointValue) return { geoPointValue: Object.assign({}, e.geoPointValue) };
                            if (e.timestampValue && 'object' == typeof e.timestampValue) return { timestampValue: Object.assign({}, e.timestampValue) };
                            if (e.mapValue) {
                                const t = { mapValue: { fields: {} } };
                                return Mo(e.mapValue.fields, (e, n) => (t.mapValue.fields[e] = ws(n))), t;
                            }
                            if (e.arrayValue) {
                                const t = { arrayValue: { values: [] } };
                                for (let n = 0; n < (e.arrayValue.values || []).length; ++n) t.arrayValue.values[n] = ws(e.arrayValue.values[n]);
                                return t;
                            }
                            return Object.assign({}, e);
                        }

                        function bs(e) {
                            return '__max__' === (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue;
                        }

                        function _s(e) {
                            return 'nullValue' in e ?
                                os :
                                'booleanValue' in e ?
                                { booleanValue: !1 } :
                                'integerValue' in e || 'doubleValue' in e ?
                                { doubleValue: NaN } :
                                'timestampValue' in e ?
                                { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } :
                                'stringValue' in e ?
                                { stringValue: '' } :
                                'bytesValue' in e ?
                                { bytesValue: '' } :
                                'referenceValue' in e ?
                                ds(rs.empty(), Ni.empty()) :
                                'geoPointValue' in e ?
                                { geoPointValue: { latitude: -90, longitude: -180 } } :
                                'arrayValue' in e ?
                                { arrayValue: {} } :
                                'mapValue' in e ?
                                { mapValue: {} } :
                                oi();
                        }

                        function Is(e) {
                            return 'nullValue' in e ?
                                { booleanValue: !1 } :
                                'booleanValue' in e ?
                                { doubleValue: NaN } :
                                'integerValue' in e || 'doubleValue' in e ?
                                { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } :
                                'timestampValue' in e ?
                                { stringValue: '' } :
                                'stringValue' in e ?
                                { bytesValue: '' } :
                                'bytesValue' in e ?
                                ds(rs.empty(), Ni.empty()) :
                                'referenceValue' in e ?
                                { geoPointValue: { latitude: -90, longitude: -180 } } :
                                'geoPointValue' in e ?
                                { arrayValue: {} } :
                                'arrayValue' in e ?
                                { mapValue: {} } :
                                'mapValue' in e ?
                                is :
                                oi();
                        }

                        function Es(e, t) {
                            const n = cs(e.value, t.value);
                            return 0 !== n ? n : e.inclusive && !t.inclusive ? -1 : !e.inclusive && t.inclusive ? 1 : 0;
                        }

                        function Ss(e, t) {
                            const n = cs(e.value, t.value);
                            return 0 !== n ? n : e.inclusive && !t.inclusive ? 1 : !e.inclusive && t.inclusive ? -1 : 0;
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Ts {
                            constructor(e) {
                                this.value = e;
                            }
                            static empty() {
                                return new Ts({ mapValue: {} });
                            }
                            field(e) {
                                if (e.isEmpty()) return this.value; {
                                    let t = this.value;
                                    for (let n = 0; n < e.length - 1; ++n)
                                        if (((t = (t.mapValue.fields || {})[e.get(n)]), !ys(t))) return null;
                                    return (t = (t.mapValue.fields || {})[e.lastSegment()]), t || null;
                                }
                            }
                            set(e, t) {
                                this.getFieldsMap(e.popLast())[e.lastSegment()] = ws(t);
                            }
                            setAll(e) {
                                let t = Oi.emptyPath(),
                                    n = {},
                                    r = [];
                                e.forEach((e, i) => {
                                    if (!t.isImmediateParentOf(i)) {
                                        const e = this.getFieldsMap(t);
                                        this.applyChanges(e, n, r), (n = {}), (r = []), (t = i.popLast());
                                    }
                                    e ? (n[i.lastSegment()] = ws(e)) : r.push(i.lastSegment());
                                });
                                const i = this.getFieldsMap(t);
                                this.applyChanges(i, n, r);
                            }
                            delete(e) {
                                const t = this.field(e.popLast());
                                ys(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
                            }
                            isEqual(e) {
                                return as(this.value, e.value);
                            }
                            getFieldsMap(e) {
                                let t = this.value;
                                t.mapValue.fields || (t.mapValue = { fields: {} });
                                for (let n = 0; n < e.length; ++n) {
                                    let r = t.mapValue.fields[e.get(n)];
                                    (ys(r) && r.mapValue.fields) || ((r = { mapValue: { fields: {} } }), (t.mapValue.fields[e.get(n)] = r)), (t = r);
                                }
                                return t.mapValue.fields;
                            }
                            applyChanges(e, t, n) {
                                Mo(t, (t, n) => (e[t] = n));
                                for (const r of n) delete e[r];
                            }
                            clone() {
                                return new Ts(ws(this.value));
                            }
                        }

                        function As(e) {
                            const t = [];
                            return (
                                Mo(e.fields, (e, n) => {
                                    const r = new Oi([e]);
                                    if (ys(n)) {
                                        const e = As(n.mapValue).fields;
                                        if (0 === e.length) t.push(r);
                                        else
                                            for (const n of e) t.push(r.child(n));
                                    } else t.push(r);
                                }),
                                new Go(t)
                            );
                            /**
                             * @license
                             * Copyright 2017 Google LLC
                             *
                             * Licensed under the Apache License, Version 2.0 (the "License");
                             * you may not use this file except in compliance with the License.
                             * You may obtain a copy of the License at
                             *
                             *   http://www.apache.org/licenses/LICENSE-2.0
                             *
                             * Unless required by applicable law or agreed to in writing, software
                             * distributed under the License is distributed on an "AS IS" BASIS,
                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                             * See the License for the specific language governing permissions and
                             * limitations under the License.
                             */
                        }
                        class xs {
                            constructor(e, t, n, r, i, o, s) {
                                (this.key = e),
                                (this.documentType = t),
                                (this.version = n),
                                (this.readTime = r),
                                (this.createTime = i),
                                (this.data = o),
                                (this.documentState = s);
                            }
                            static newInvalidDocument(e) {
                                return new xs(e, 0, Ai.min(), Ai.min(), Ai.min(), Ts.empty(), 0);
                            }
                            static newFoundDocument(e, t, n, r) {
                                return new xs(e, 1, t, Ai.min(), n, r, 0);
                            }
                            static newNoDocument(e, t) {
                                return new xs(e, 2, t, Ai.min(), Ai.min(), Ts.empty(), 0);
                            }
                            static newUnknownDocument(e, t) {
                                return new xs(e, 3, t, Ai.min(), Ai.min(), Ts.empty(), 2);
                            }
                            convertToFoundDocument(e, t) {
                                return (!this.createTime.isEqual(Ai.min()) || (2 !== this.documentType && 0 !== this.documentType) || (this.createTime = e),
                                    (this.version = e),
                                    (this.documentType = 1),
                                    (this.data = t),
                                    (this.documentState = 0),
                                    this
                                );
                            }
                            convertToNoDocument(e) {
                                return (this.version = e), (this.documentType = 2), (this.data = Ts.empty()), (this.documentState = 0), this;
                            }
                            convertToUnknownDocument(e) {
                                return (this.version = e), (this.documentType = 3), (this.data = Ts.empty()), (this.documentState = 2), this;
                            }
                            setHasCommittedMutations() {
                                return (this.documentState = 2), this;
                            }
                            setHasLocalMutations() {
                                return (this.documentState = 1), (this.version = Ai.min()), this;
                            }
                            setReadTime(e) {
                                return (this.readTime = e), this;
                            }
                            get hasLocalMutations() {
                                return 1 === this.documentState;
                            }
                            get hasCommittedMutations() {
                                return 2 === this.documentState;
                            }
                            get hasPendingWrites() {
                                return this.hasLocalMutations || this.hasCommittedMutations;
                            }
                            isValidDocument() {
                                return 0 !== this.documentType;
                            }
                            isFoundDocument() {
                                return 1 === this.documentType;
                            }
                            isNoDocument() {
                                return 2 === this.documentType;
                            }
                            isUnknownDocument() {
                                return 3 === this.documentType;
                            }
                            isEqual(e) {
                                return (
                                    e instanceof xs &&
                                    this.key.isEqual(e.key) &&
                                    this.version.isEqual(e.version) &&
                                    this.documentType === e.documentType &&
                                    this.documentState === e.documentState &&
                                    this.data.isEqual(e.data)
                                );
                            }
                            mutableCopy() {
                                return new xs(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
                            }
                            toString() {
                                return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
                            }
                        }
                        /**
                         * @license
                         * Copyright 2022 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Cs {
                            constructor(e, t) {
                                (this.position = e), (this.inclusive = t);
                            }
                        }

                        function ks(e, t, n) {
                            let r = 0;
                            for (let i = 0; i < e.position.length; i++) {
                                const o = t[i],
                                    s = e.position[i];
                                if (
                                    ((r = o.field.isKeyField() ? Ni.comparator(Ni.fromName(s.referenceValue), n.key) : cs(s, n.data.field(o.field))),
                                        'desc' === o.dir && (r *= -1),
                                        0 !== r)
                                )
                                    break;
                            }
                            return r;
                        }

                        function Os(e, t) {
                            if (null === e) return null === t;
                            if (null === t) return !1;
                            if (e.inclusive !== t.inclusive || e.position.length !== t.position.length) return !1;
                            for (let n = 0; n < e.position.length; n++)
                                if (!as(e.position[n], t.position[n])) return !1;
                            return !0;
                        }
                        /**
                         * @license
                         * Copyright 2022 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Ns {
                            constructor(e, t = 'asc') {
                                (this.field = e), (this.dir = t);
                            }
                        }

                        function Rs(e, t) {
                            return e.dir === t.dir && e.field.isEqual(t.field);
                        }
                        /**
                         * @license
                         * Copyright 2022 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Ps {}
                        class Ds extends Ps {
                            constructor(e, t, n) {
                                super(), (this.field = e), (this.op = t), (this.value = n);
                            }
                            static create(e, t, n) {
                                return e.isKeyField() ?
                                    'in' === t || 'not-in' === t ?
                                    this.createKeyFieldInFilter(e, t, n) :
                                    new zs(e, t, n) :
                                    'array-contains' === t ?
                                    new Ks(e, n) :
                                    'in' === t ?
                                    new Qs(e, n) :
                                    'not-in' === t ?
                                    new Ys(e, n) :
                                    'array-contains-any' === t ?
                                    new Xs(e, n) :
                                    new Ds(e, t, n);
                            }
                            static createKeyFieldInFilter(e, t, n) {
                                return 'in' === t ? new Gs(e, n) : new Ws(e, n);
                            }
                            matches(e) {
                                const t = e.data.field(this.field);
                                return '!=' === this.op ?
                                    null !== t && this.matchesComparison(cs(t, this.value)) :
                                    null !== t && ss(this.value) === ss(t) && this.matchesComparison(cs(t, this.value));
                            }
                            matchesComparison(e) {
                                switch (this.op) {
                                    case '<':
                                        return e < 0;
                                    case '<=':
                                        return e <= 0;
                                    case '==':
                                        return 0 === e;
                                    case '!=':
                                        return 0 !== e;
                                    case '>':
                                        return e > 0;
                                    case '>=':
                                        return e >= 0;
                                    default:
                                        return oi();
                                }
                            }
                            isInequality() {
                                return ['<', '<=', '>', '>=', '!=', 'not-in'].indexOf(this.op) >= 0;
                            }
                            getFlattenedFilters() {
                                return [this];
                            }
                            getFilters() {
                                return [this];
                            }
                            getFirstInequalityField() {
                                return this.isInequality() ? this.field : null;
                            }
                        }
                        class Ls extends Ps {
                            constructor(e, t) {
                                super(), (this.filters = e), (this.op = t), (this.lt = null);
                            }
                            static create(e, t) {
                                return new Ls(e, t);
                            }
                            matches(e) {
                                return js(this) ? void 0 === this.filters.find(t => !t.matches(e)) : void 0 !== this.filters.find(t => t.matches(e));
                            }
                            getFlattenedFilters() {
                                return null !== this.lt || (this.lt = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.lt;
                            }
                            getFilters() {
                                return Object.assign([], this.filters);
                            }
                            getFirstInequalityField() {
                                const e = this.ft(e => e.isInequality());
                                return null !== e ? e.field : null;
                            }
                            ft(e) {
                                for (const t of this.getFlattenedFilters())
                                    if (e(t)) return t;
                                return null;
                            }
                        }

                        function js(e) {
                            return 'and' === e.op;
                        }

                        function Ms(e) {
                            return 'or' === e.op;
                        }

                        function Fs(e) {
                            return Us(e) && js(e);
                        }

                        function Us(e) {
                            for (const t of e.filters)
                                if (t instanceof Ls) return !1;
                            return !0;
                        }

                        function Vs(e) {
                            if (e instanceof Ds) return e.field.canonicalString() + e.op.toString() + hs(e.value);
                            if (Fs(e)) return e.filters.map(e => Vs(e)).join(','); {
                                const t = e.filters.map(e => Vs(e)).join(',');
                                return `${e.op}(${t})`;
                            }
                        }

                        function Bs(e, t) {
                            return e instanceof Ds ?
                                (function(e, t) {
                                    return t instanceof Ds && e.op === t.op && e.field.isEqual(t.field) && as(e.value, t.value);
                                })(e, t) :
                                e instanceof Ls ?
                                (function(e, t) {
                                    return (
                                        t instanceof Ls &&
                                        e.op === t.op &&
                                        e.filters.length === t.filters.length &&
                                        e.filters.reduce((e, n, r) => e && Bs(n, t.filters[r]), !0)
                                    );
                                })(e, t) :
                                void oi();
                        }

                        function $s(e, t) {
                            const n = e.filters.concat(t);
                            return Ls.create(n, e.op);
                        }

                        function qs(e) {
                            return e instanceof Ds ?
                                (function(e) {
                                    return `${e.field.canonicalString()} ${e.op} ${hs(e.value)}`;
                                })(e) :
                                e instanceof Ls ?
                                (function(e) {
                                    return e.op.toString() + ' {' + e.getFilters().map(qs).join(' ,') + '}';
                                })(e) :
                                'Filter';
                        }
                        class zs extends Ds {
                            constructor(e, t, n) {
                                super(e, t, n), (this.key = Ni.fromName(n.referenceValue));
                            }
                            matches(e) {
                                const t = Ni.comparator(e.key, this.key);
                                return this.matchesComparison(t);
                            }
                        }
                        class Gs extends Ds {
                            constructor(e, t) {
                                super(e, 'in', t), (this.keys = Hs('in', t));
                            }
                            matches(e) {
                                return this.keys.some(t => t.isEqual(e.key));
                            }
                        }
                        class Ws extends Ds {
                            constructor(e, t) {
                                super(e, 'not-in', t), (this.keys = Hs('not-in', t));
                            }
                            matches(e) {
                                return !this.keys.some(t => t.isEqual(e.key));
                            }
                        }

                        function Hs(e, t) {
                            var n;
                            return ((null === (n = t.arrayValue) || void 0 === n ? void 0 : n.values) || []).map(e => Ni.fromName(e.referenceValue));
                        }
                        class Ks extends Ds {
                            constructor(e, t) {
                                super(e, 'array-contains', t);
                            }
                            matches(e) {
                                const t = e.data.field(this.field);
                                return gs(t) && us(t.arrayValue, this.value);
                            }
                        }
                        class Qs extends Ds {
                            constructor(e, t) {
                                super(e, 'in', t);
                            }
                            matches(e) {
                                const t = e.data.field(this.field);
                                return null !== t && us(this.value.arrayValue, t);
                            }
                        }
                        class Ys extends Ds {
                            constructor(e, t) {
                                super(e, 'not-in', t);
                            }
                            matches(e) {
                                if (us(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) return !1;
                                const t = e.data.field(this.field);
                                return null !== t && !us(this.value.arrayValue, t);
                            }
                        }
                        class Xs extends Ds {
                            constructor(e, t) {
                                super(e, 'array-contains-any', t);
                            }
                            matches(e) {
                                const t = e.data.field(this.field);
                                return !(!gs(t) || !t.arrayValue.values) && t.arrayValue.values.some(e => us(this.value.arrayValue, e));
                            }
                        }
                        /**
                         * @license
                         * Copyright 2019 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class Js {
                            constructor(e, t = null, n = [], r = [], i = null, o = null, s = null) {
                                (this.path = e),
                                (this.collectionGroup = t),
                                (this.orderBy = n),
                                (this.filters = r),
                                (this.limit = i),
                                (this.startAt = o),
                                (this.endAt = s),
                                (this.dt = null);
                            }
                        }

                        function Zs(e, t = null, n = [], r = [], i = null, o = null, s = null) {
                            return new Js(e, t, n, r, i, o, s);
                        }

                        function ea(e) {
                            const t = ui(e);
                            if (null === t.dt) {
                                let e = t.path.canonicalString();
                                null !== t.collectionGroup && (e += '|cg:' + t.collectionGroup),
                                    (e += '|f:'),
                                    (e += t.filters.map(e => Vs(e)).join(',')),
                                    (e += '|ob:'),
                                    (e += t.orderBy
                                        .map(e =>
                                            (function(e) {
                                                return e.field.canonicalString() + e.dir;
                                            })(e)
                                        )
                                        .join(',')),
                                    ro(t.limit) || ((e += '|l:'), (e += t.limit)),
                                    t.startAt && ((e += '|lb:'), (e += t.startAt.inclusive ? 'b:' : 'a:'), (e += t.startAt.position.map(e => hs(e)).join(','))),
                                    t.endAt && ((e += '|ub:'), (e += t.endAt.inclusive ? 'a:' : 'b:'), (e += t.endAt.position.map(e => hs(e)).join(','))),
                                    (t.dt = e);
                            }
                            return t.dt;
                        }

                        function ta(e, t) {
                            if (e.limit !== t.limit) return !1;
                            if (e.orderBy.length !== t.orderBy.length) return !1;
                            for (let n = 0; n < e.orderBy.length; n++)
                                if (!Rs(e.orderBy[n], t.orderBy[n])) return !1;
                            if (e.filters.length !== t.filters.length) return !1;
                            for (let n = 0; n < e.filters.length; n++)
                                if (!Bs(e.filters[n], t.filters[n])) return !1;
                            return e.collectionGroup === t.collectionGroup && !!e.path.isEqual(t.path) && !!Os(e.startAt, t.startAt) && Os(e.endAt, t.endAt);
                        }

                        function na(e) {
                            return Ni.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length;
                        }

                        function ra(e, t) {
                            return e.filters.filter(e => e instanceof Ds && e.field.isEqual(t));
                        }

                        function ia(e, t, n) {
                            let r = os,
                                i = !0;
                            for (const o of ra(e, t)) {
                                let e = os,
                                    t = !0;
                                switch (o.op) {
                                    case '<':
                                    case '<=':
                                        e = _s(o.value);
                                        break;
                                    case '==':
                                    case 'in':
                                    case '>=':
                                        e = o.value;
                                        break;
                                    case '>':
                                        (e = o.value), (t = !1);
                                        break;
                                    case '!=':
                                    case 'not-in':
                                        e = os;
                                }
                                Es({ value: r, inclusive: i }, { value: e, inclusive: t }) < 0 && ((r = e), (i = t));
                            }
                            if (null !== n)
                                for (let o = 0; o < e.orderBy.length; ++o)
                                    if (e.orderBy[o].field.isEqual(t)) {
                                        const e = n.position[o];
                                        Es({ value: r, inclusive: i }, { value: e, inclusive: n.inclusive }) < 0 && ((r = e), (i = n.inclusive));
                                        break;
                                    }
                            return { value: r, inclusive: i };
                        }

                        function oa(e, t, n) {
                            let r = is,
                                i = !0;
                            for (const o of ra(e, t)) {
                                let e = is,
                                    t = !0;
                                switch (o.op) {
                                    case '>=':
                                    case '>':
                                        (e = Is(o.value)), (t = !1);
                                        break;
                                    case '==':
                                    case 'in':
                                    case '<=':
                                        e = o.value;
                                        break;
                                    case '<':
                                        (e = o.value), (t = !1);
                                        break;
                                    case '!=':
                                    case 'not-in':
                                        e = is;
                                }
                                Ss({ value: r, inclusive: i }, { value: e, inclusive: t }) > 0 && ((r = e), (i = t));
                            }
                            if (null !== n)
                                for (let o = 0; o < e.orderBy.length; ++o)
                                    if (e.orderBy[o].field.isEqual(t)) {
                                        const e = n.position[o];
                                        Ss({ value: r, inclusive: i }, { value: e, inclusive: n.inclusive }) > 0 && ((r = e), (i = n.inclusive));
                                        break;
                                    }
                            return { value: r, inclusive: i };
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        class sa {
                            constructor(e, t = null, n = [], r = [], i = null, o = 'F', s = null, a = null) {
                                (this.path = e),
                                (this.collectionGroup = t),
                                (this.explicitOrderBy = n),
                                (this.filters = r),
                                (this.limit = i),
                                (this.limitType = o),
                                (this.startAt = s),
                                (this.endAt = a),
                                (this.wt = null),
                                (this._t = null),
                                this.startAt,
                                    this.endAt;
                            }
                        }

                        function aa(e, t, n, r, i, o, s, a) {
                            return new sa(e, t, n, r, i, o, s, a);
                        }

                        function ua(e) {
                            return new sa(e);
                        }

                        function ca(e) {
                            return (
                                0 === e.filters.length &&
                                null === e.limit &&
                                null == e.startAt &&
                                null == e.endAt &&
                                (0 === e.explicitOrderBy.length || (1 === e.explicitOrderBy.length && e.explicitOrderBy[0].field.isKeyField()))
                            );
                        }

                        function la(e) {
                            return e.explicitOrderBy.length > 0 ? e.explicitOrderBy[0].field : null;
                        }

                        function ha(e) {
                            for (const t of e.filters) {
                                const e = t.getFirstInequalityField();
                                if (null !== e) return e;
                            }
                            return null;
                        }

                        function fa(e) {
                            return null !== e.collectionGroup;
                        }

                        function da(e) {
                            const t = ui(e);
                            if (null === t.wt) {
                                t.wt = [];
                                const e = ha(t),
                                    n = la(t);
                                if (null !== e && null === n) e.isKeyField() || t.wt.push(new Ns(e)), t.wt.push(new Ns(Oi.keyField(), 'asc'));
                                else {
                                    let e = !1;
                                    for (const n of t.explicitOrderBy) t.wt.push(n), n.field.isKeyField() && (e = !0);
                                    if (!e) {
                                        const e = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : 'asc';
                                        t.wt.push(new Ns(Oi.keyField(), e));
                                    }
                                }
                            }
                            return t.wt;
                        }

                        function pa(e) {
                            const t = ui(e);
                            if (!t._t)
                                if ('F' === t.limitType) t._t = Zs(t.path, t.collectionGroup, da(t), t.filters, t.limit, t.startAt, t.endAt);
                                else {
                                    const e = [];
                                    for (const i of da(t)) {
                                        const t = 'desc' === i.dir ? 'asc' : 'desc';
                                        e.push(new Ns(i.field, t));
                                    }
                                    const n = t.endAt ? new Cs(t.endAt.position, t.endAt.inclusive) : null,
                                        r = t.startAt ? new Cs(t.startAt.position, t.startAt.inclusive) : null;
                                    t._t = Zs(t.path, t.collectionGroup, e, t.filters, t.limit, n, r);
                                }
                            return t._t;
                        }

                        function ga(e, t) {
                            t.getFirstInequalityField(), ha(e);
                            const n = e.filters.concat([t]);
                            return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), n, e.limit, e.limitType, e.startAt, e.endAt);
                        }

                        function ma(e, t, n) {
                            return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), t, n, e.startAt, e.endAt);
                        }

                        function va(e, t) {
                            return ta(pa(e), pa(t)) && e.limitType === t.limitType;
                        }

                        function ya(e) {
                            return `${ea(pa(e))}|lt:${e.limitType}`;
                        }

                        function wa(e) {
                            return `Query(target=${(function (e) {
          let t = e.path.canonicalString();
          return (
            null !== e.collectionGroup && (t += ' collectionGroup=' + e.collectionGroup),
            e.filters.length > 0 && (t += `, filters: [${e.filters.map(e => qs(e)).join(', ')}]`),
            ro(e.limit) || (t += ', limit: ' + e.limit),
            e.orderBy.length > 0 &&
              (t += `, orderBy: [${e.orderBy
                .map(e =>
                  (function (e) {
                    return `${e.field.canonicalString()} (${e.dir})`;
                  })(e)
                )
                .join(', ')}]`),
            e.startAt && ((t += ', startAt: '), (t += e.startAt.inclusive ? 'b:' : 'a:'), (t += e.startAt.position.map(e => hs(e)).join(','))),
            e.endAt && ((t += ', endAt: '), (t += e.endAt.inclusive ? 'a:' : 'b:'), (t += e.endAt.position.map(e => hs(e)).join(','))),
            `Target(${t})`
          );
        })(pa(e))}; limitType=${e.limitType})`;
      }
      function ba(e, t) {
        return (
          t.isFoundDocument() &&
          (function (e, t) {
            const n = t.key.path;
            return null !== e.collectionGroup
              ? t.key.hasCollectionId(e.collectionGroup) && e.path.isPrefixOf(n)
              : Ni.isDocumentKey(e.path)
                ? e.path.isEqual(n)
                : e.path.isImmediateParentOf(n);
          })(e, t) &&
          (function (e, t) {
            for (const n of da(e)) if (!n.field.isKeyField() && null === t.data.field(n.field)) return !1;
            return !0;
          })(e, t) &&
          (function (e, t) {
            for (const n of e.filters) if (!n.matches(t)) return !1;
            return !0;
          })(e, t) &&
          (function (e, t) {
            return (
              !(
                e.startAt &&
                !(function (e, t, n) {
                  const r = ks(e, t, n);
                  return e.inclusive ? r <= 0 : r < 0;
                })(e.startAt, da(e), t)
              ) &&
              !(
                e.endAt &&
                !(function (e, t, n) {
                  const r = ks(e, t, n);
                  return e.inclusive ? r >= 0 : r > 0;
                })(e.endAt, da(e), t)
              )
            );
          })(e, t)
        );
      }
      function _a(e) {
        return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2));
      }
      function Ia(e) {
        return (t, n) => {
          let r = !1;
          for (const i of da(e)) {
            const e = Ea(i, t, n);
            if (0 !== e) return e;
            r = r || i.field.isKeyField();
          }
          return 0;
        };
      }
      function Ea(e, t, n) {
        const r = e.field.isKeyField()
          ? Ni.comparator(t.key, n.key)
          : (function (e, t, n) {
              const r = t.data.field(e),
                i = n.data.field(e);
              return null !== r && null !== i ? cs(r, i) : oi();
            })(e.field, t, n);
        switch (e.dir) {
          case 'asc':
            return r;
          case 'desc':
            return -1 * r;
          default:
            return oi();
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Sa {
        constructor(e, t) {
          (this.mapKeyFn = e), (this.equalsFn = t), (this.inner = {}), (this.innerSize = 0);
        }
        get(e) {
          const t = this.mapKeyFn(e),
            n = this.inner[t];
          if (void 0 !== n) for (const [r, i] of n) if (this.equalsFn(r, e)) return i;
        }
        has(e) {
          return void 0 !== this.get(e);
        }
        set(e, t) {
          const n = this.mapKeyFn(e),
            r = this.inner[n];
          if (void 0 === r) return (this.inner[n] = [[e, t]]), void this.innerSize++;
          for (let i = 0; i < r.length; i++) if (this.equalsFn(r[i][0], e)) return void (r[i] = [e, t]);
          r.push([e, t]), this.innerSize++;
        }
        delete(e) {
          const t = this.mapKeyFn(e),
            n = this.inner[t];
          if (void 0 === n) return !1;
          for (let r = 0; r < n.length; r++)
            if (this.equalsFn(n[r][0], e)) return 1 === n.length ? delete this.inner[t] : n.splice(r, 1), this.innerSize--, !0;
          return !1;
        }
        forEach(e) {
          Mo(this.inner, (t, n) => {
            for (const [r, i] of n) e(r, i);
          });
        }
        isEmpty() {
          return Fo(this.inner);
        }
        size() {
          return this.innerSize;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Ta = new Uo(Ni.comparator);
      function Aa() {
        return Ta;
      }
      const xa = new Uo(Ni.comparator);
      function Ca(...e) {
        let t = xa;
        for (const n of e) t = t.insert(n.key, n);
        return t;
      }
      function ka(e) {
        let t = xa;
        return e.forEach((e, n) => (t = t.insert(e, n.overlayedDocument))), t;
      }
      function Oa() {
        return Ra();
      }
      function Na() {
        return Ra();
      }
      function Ra() {
        return new Sa(
          e => e.toString(),
          (e, t) => e.isEqual(t)
        );
      }
      const Pa = new Uo(Ni.comparator),
        Da = new $o(Ni.comparator);
      function La(...e) {
        let t = Da;
        for (const n of e) t = t.add(n);
        return t;
      }
      const ja = new $o(Ii);
      function Ma() {
        return ja;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Fa(e, t) {
        if (e.useProto3Json) {
          if (isNaN(t)) return { doubleValue: 'NaN' };
          if (t === 1 / 0) return { doubleValue: 'Infinity' };
          if (t === -1 / 0) return { doubleValue: '-Infinity' };
        }
        return { doubleValue: io(t) ? '-0' : t };
      }
      function Ua(e) {
        return { integerValue: '' + e };
      }
      function Va(e, t) {
        return oo(t) ? Ua(t) : Fa(e, t);
      }
      /**
       * @license
       * Copyright 2018 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ba {
        constructor() {
          this._ = void 0;
        }
      }
      function $a(e, t, n) {
        return e instanceof Ga
          ? (function (e, t) {
              const n = {
                fields: {
                  __type__: { stringValue: 'server_timestamp' },
                  __local_write_time__: { timestampValue: { seconds: e.seconds, nanos: e.nanoseconds } }
                }
              };
              return t && Zo(t) && (t = es(t)), t && (n.fields.__previous_value__ = t), { mapValue: n };
            })(n, t)
          : e instanceof Wa
            ? Ha(e, t)
            : e instanceof Ka
              ? Qa(e, t)
              : (function (e, t) {
                  const n = za(e, t),
                    r = Xa(n) + Xa(e.gt);
                  return ps(n) && ps(e.gt) ? Ua(r) : Fa(e.serializer, r);
                })(e, t);
      }
      function qa(e, t, n) {
        return e instanceof Wa ? Ha(e, t) : e instanceof Ka ? Qa(e, t) : n;
      }
      function za(e, t) {
        return e instanceof Ya
          ? ps((n = t)) ||
            (function (e) {
              return !!e && 'doubleValue' in e;
            })(n)
            ? t
            : { integerValue: 0 }
          : null;
        var n;
      }
      class Ga extends Ba {}
      class Wa extends Ba {
        constructor(e) {
          super(), (this.elements = e);
        }
      }
      function Ha(e, t) {
        const n = Ja(t);
        for (const r of e.elements) n.some(e => as(e, r)) || n.push(r);
        return { arrayValue: { values: n } };
      }
      class Ka extends Ba {
        constructor(e) {
          super(), (this.elements = e);
        }
      }
      function Qa(e, t) {
        let n = Ja(t);
        for (const r of e.elements) n = n.filter(e => !as(e, r));
        return { arrayValue: { values: n } };
      }
      class Ya extends Ba {
        constructor(e, t) {
          super(), (this.serializer = e), (this.gt = t);
        }
      }
      function Xa(e) {
        return Xo(e.integerValue || e.doubleValue);
      }
      function Ja(e) {
        return gs(e) && e.arrayValue.values ? e.arrayValue.values.slice() : [];
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Za {
        constructor(e, t) {
          (this.field = e), (this.transform = t);
        }
      }
      function eu(e, t) {
        return (
          e.field.isEqual(t.field) &&
          (function (e, t) {
            return (e instanceof Wa && t instanceof Wa) || (e instanceof Ka && t instanceof Ka)
              ? Ei(e.elements, t.elements, as)
              : e instanceof Ya && t instanceof Ya
                ? as(e.gt, t.gt)
                : e instanceof Ga && t instanceof Ga;
          })(e.transform, t.transform)
        );
      }
      class tu {
        constructor(e, t) {
          (this.version = e), (this.transformResults = t);
        }
      }
      class nu {
        constructor(e, t) {
          (this.updateTime = e), (this.exists = t);
        }
        static none() {
          return new nu();
        }
        static exists(e) {
          return new nu(void 0, e);
        }
        static updateTime(e) {
          return new nu(e);
        }
        get isNone() {
          return void 0 === this.updateTime && void 0 === this.exists;
        }
        isEqual(e) {
          return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime);
        }
      }
      function ru(e, t) {
        return void 0 !== e.updateTime
          ? t.isFoundDocument() && t.version.isEqual(e.updateTime)
          : void 0 === e.exists || e.exists === t.isFoundDocument();
      }
      class iu {}
      function ou(e, t) {
        if (!e.hasLocalMutations || (t && 0 === t.fields.length)) return null;
        if (null === t) return e.isNoDocument() ? new gu(e.key, nu.none()) : new lu(e.key, e.data, nu.none());
        {
          const n = e.data,
            r = Ts.empty();
          let i = new $o(Oi.comparator);
          for (let e of t.fields)
            if (!i.has(e)) {
              let t = n.field(e);
              null === t && e.length > 1 && ((e = e.popLast()), (t = n.field(e))), null === t ? r.delete(e) : r.set(e, t), (i = i.add(e));
            }
          return new hu(e.key, r, new Go(i.toArray()), nu.none());
        }
      }
      function su(e, t, n) {
        e instanceof lu
          ? (function (e, t, n) {
              const r = e.value.clone(),
                i = du(e.fieldTransforms, t, n.transformResults);
              r.setAll(i), t.convertToFoundDocument(n.version, r).setHasCommittedMutations();
            })(e, t, n)
          : e instanceof hu
            ? (function (e, t, n) {
                if (!ru(e.precondition, t)) return void t.convertToUnknownDocument(n.version);
                const r = du(e.fieldTransforms, t, n.transformResults),
                  i = t.data;
                i.setAll(fu(e)), i.setAll(r), t.convertToFoundDocument(n.version, i).setHasCommittedMutations();
              })(e, t, n)
            : (function (e, t, n) {
                t.convertToNoDocument(n.version).setHasCommittedMutations();
              })(0, t, n);
      }
      function au(e, t, n, r) {
        return e instanceof lu
          ? (function (e, t, n, r) {
              if (!ru(e.precondition, t)) return n;
              const i = e.value.clone(),
                o = pu(e.fieldTransforms, r, t);
              return i.setAll(o), t.convertToFoundDocument(t.version, i).setHasLocalMutations(), null;
            })(e, t, n, r)
          : e instanceof hu
            ? (function (e, t, n, r) {
                if (!ru(e.precondition, t)) return n;
                const i = pu(e.fieldTransforms, r, t),
                  o = t.data;
                return (
                  o.setAll(fu(e)),
                  o.setAll(i),
                  t.convertToFoundDocument(t.version, o).setHasLocalMutations(),
                  null === n ? null : n.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map(e => e.field))
                );
              })(e, t, n, r)
            : (function (e, t, n) {
                return ru(e.precondition, t) ? (t.convertToNoDocument(t.version).setHasLocalMutations(), null) : n;
              })(e, t, n);
      }
      function uu(e, t) {
        let n = null;
        for (const r of e.fieldTransforms) {
          const e = t.data.field(r.field),
            i = za(r.transform, e || null);
          null != i && (null === n && (n = Ts.empty()), n.set(r.field, i));
        }
        return n || null;
      }
      function cu(e, t) {
        return (
          e.type === t.type &&
          !!e.key.isEqual(t.key) &&
          !!e.precondition.isEqual(t.precondition) &&
          !!(function (e, t) {
            return (void 0 === e && void 0 === t) || (!(!e || !t) && Ei(e, t, (e, t) => eu(e, t)));
          })(e.fieldTransforms, t.fieldTransforms) &&
          (0 === e.type ? e.value.isEqual(t.value) : 1 !== e.type || (e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask)))
        );
      }
      class lu extends iu {
        constructor(e, t, n, r = []) {
          super(), (this.key = e), (this.value = t), (this.precondition = n), (this.fieldTransforms = r), (this.type = 0);
        }
        getFieldMask() {
          return null;
        }
      }
      class hu extends iu {
        constructor(e, t, n, r, i = []) {
          super(), (this.key = e), (this.data = t), (this.fieldMask = n), (this.precondition = r), (this.fieldTransforms = i), (this.type = 1);
        }
        getFieldMask() {
          return this.fieldMask;
        }
      }
      function fu(e) {
        const t = new Map();
        return (
          e.fieldMask.fields.forEach(n => {
            if (!n.isEmpty()) {
              const r = e.data.field(n);
              t.set(n, r);
            }
          }),
          t
        );
      }
      function du(e, t, n) {
        const r = new Map();
        si(e.length === n.length);
        for (let i = 0; i < n.length; i++) {
          const o = e[i],
            s = o.transform,
            a = t.data.field(o.field);
          r.set(o.field, qa(s, a, n[i]));
        }
        return r;
      }
      function pu(e, t, n) {
        const r = new Map();
        for (const i of e) {
          const e = i.transform,
            o = n.data.field(i.field);
          r.set(i.field, $a(e, o, t));
        }
        return r;
      }
      class gu extends iu {
        constructor(e, t) {
          super(), (this.key = e), (this.precondition = t), (this.type = 2), (this.fieldTransforms = []);
        }
        getFieldMask() {
          return null;
        }
      }
      class mu extends iu {
        constructor(e, t) {
          super(), (this.key = e), (this.precondition = t), (this.type = 3), (this.fieldTransforms = []);
        }
        getFieldMask() {
          return null;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class vu {
        constructor(e, t, n, r) {
          (this.batchId = e), (this.localWriteTime = t), (this.baseMutations = n), (this.mutations = r);
        }
        applyToRemoteDocument(e, t) {
          const n = t.mutationResults;
          for (let r = 0; r < this.mutations.length; r++) {
            const t = this.mutations[r];
            t.key.isEqual(e.key) && su(t, e, n[r]);
          }
        }
        applyToLocalView(e, t) {
          for (const n of this.baseMutations) n.key.isEqual(e.key) && (t = au(n, e, t, this.localWriteTime));
          for (const n of this.mutations) n.key.isEqual(e.key) && (t = au(n, e, t, this.localWriteTime));
          return t;
        }
        applyToLocalDocumentSet(e, t) {
          const n = Na();
          return (
            this.mutations.forEach(r => {
              const i = e.get(r.key),
                o = i.overlayedDocument;
              let s = this.applyToLocalView(o, i.mutatedFields);
              s = t.has(r.key) ? null : s;
              const a = ou(o, s);
              null !== a && n.set(r.key, a), o.isValidDocument() || o.convertToNoDocument(Ai.min());
            }),
            n
          );
        }
        keys() {
          return this.mutations.reduce((e, t) => e.add(t.key), La());
        }
        isEqual(e) {
          return (
            this.batchId === e.batchId &&
            Ei(this.mutations, e.mutations, (e, t) => cu(e, t)) &&
            Ei(this.baseMutations, e.baseMutations, (e, t) => cu(e, t))
          );
        }
      }
      class yu {
        constructor(e, t, n, r) {
          (this.batch = e), (this.commitVersion = t), (this.mutationResults = n), (this.docVersions = r);
        }
        static from(e, t, n) {
          si(e.mutations.length === n.length);
          let r = Pa;
          const i = e.mutations;
          for (let o = 0; o < i.length; o++) r = r.insert(i[o].key, n[o].version);
          return new yu(e, t, n, r);
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class wu {
        constructor(e, t) {
          (this.largestBatchId = e), (this.mutation = t);
        }
        getKey() {
          return this.mutation.key;
        }
        isEqual(e) {
          return null !== e && this.mutation === e.mutation;
        }
        toString() {
          return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`;
        }
      }
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class bu {
        constructor(e, t) {
          (this.count = e), (this.unchangedNames = t);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var _u, Iu;
      function Eu(e) {
        switch (e) {
          default:
            return oi();
          case ci.CANCELLED:
          case ci.UNKNOWN:
          case ci.DEADLINE_EXCEEDED:
          case ci.RESOURCE_EXHAUSTED:
          case ci.INTERNAL:
          case ci.UNAVAILABLE:
          case ci.UNAUTHENTICATED:
            return !1;
          case ci.INVALID_ARGUMENT:
          case ci.NOT_FOUND:
          case ci.ALREADY_EXISTS:
          case ci.PERMISSION_DENIED:
          case ci.FAILED_PRECONDITION:
          case ci.ABORTED:
          case ci.OUT_OF_RANGE:
          case ci.UNIMPLEMENTED:
          case ci.DATA_LOSS:
            return !0;
        }
      }
      function Su(e) {
        if (void 0 === e) return ni('GRPC error has no .code'), ci.UNKNOWN;
        switch (e) {
          case _u.OK:
            return ci.OK;
          case _u.CANCELLED:
            return ci.CANCELLED;
          case _u.UNKNOWN:
            return ci.UNKNOWN;
          case _u.DEADLINE_EXCEEDED:
            return ci.DEADLINE_EXCEEDED;
          case _u.RESOURCE_EXHAUSTED:
            return ci.RESOURCE_EXHAUSTED;
          case _u.INTERNAL:
            return ci.INTERNAL;
          case _u.UNAVAILABLE:
            return ci.UNAVAILABLE;
          case _u.UNAUTHENTICATED:
            return ci.UNAUTHENTICATED;
          case _u.INVALID_ARGUMENT:
            return ci.INVALID_ARGUMENT;
          case _u.NOT_FOUND:
            return ci.NOT_FOUND;
          case _u.ALREADY_EXISTS:
            return ci.ALREADY_EXISTS;
          case _u.PERMISSION_DENIED:
            return ci.PERMISSION_DENIED;
          case _u.FAILED_PRECONDITION:
            return ci.FAILED_PRECONDITION;
          case _u.ABORTED:
            return ci.ABORTED;
          case _u.OUT_OF_RANGE:
            return ci.OUT_OF_RANGE;
          case _u.UNIMPLEMENTED:
            return ci.UNIMPLEMENTED;
          case _u.DATA_LOSS:
            return ci.DATA_LOSS;
          default:
            return oi();
        }
      }
      ((Iu = _u || (_u = {}))[(Iu.OK = 0)] = 'OK'),
        (Iu[(Iu.CANCELLED = 1)] = 'CANCELLED'),
        (Iu[(Iu.UNKNOWN = 2)] = 'UNKNOWN'),
        (Iu[(Iu.INVALID_ARGUMENT = 3)] = 'INVALID_ARGUMENT'),
        (Iu[(Iu.DEADLINE_EXCEEDED = 4)] = 'DEADLINE_EXCEEDED'),
        (Iu[(Iu.NOT_FOUND = 5)] = 'NOT_FOUND'),
        (Iu[(Iu.ALREADY_EXISTS = 6)] = 'ALREADY_EXISTS'),
        (Iu[(Iu.PERMISSION_DENIED = 7)] = 'PERMISSION_DENIED'),
        (Iu[(Iu.UNAUTHENTICATED = 16)] = 'UNAUTHENTICATED'),
        (Iu[(Iu.RESOURCE_EXHAUSTED = 8)] = 'RESOURCE_EXHAUSTED'),
        (Iu[(Iu.FAILED_PRECONDITION = 9)] = 'FAILED_PRECONDITION'),
        (Iu[(Iu.ABORTED = 10)] = 'ABORTED'),
        (Iu[(Iu.OUT_OF_RANGE = 11)] = 'OUT_OF_RANGE'),
        (Iu[(Iu.UNIMPLEMENTED = 12)] = 'UNIMPLEMENTED'),
        (Iu[(Iu.INTERNAL = 13)] = 'INTERNAL'),
        (Iu[(Iu.UNAVAILABLE = 14)] = 'UNAVAILABLE'),
        (Iu[(Iu.DATA_LOSS = 15)] = 'DATA_LOSS');
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class Tu {
        constructor() {
          this.onExistenceFilterMismatchCallbacks = new Map();
        }
        static get instance() {
          return Au;
        }
        static getOrCreateInstance() {
          return null === Au && (Au = new Tu()), Au;
        }
        onExistenceFilterMismatch(e) {
          const t = Symbol();
          return this.onExistenceFilterMismatchCallbacks.set(t, e), () => this.onExistenceFilterMismatchCallbacks.delete(t);
        }
        notifyOnExistenceFilterMismatch(e) {
          this.onExistenceFilterMismatchCallbacks.forEach(t => t(e));
        }
      }
      let Au = null;
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function xu() {
        return new TextEncoder();
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Cu = new Kr([4294967295, 4294967295], 0);
      function ku(e) {
        const t = xu().encode(e),
          n = new Hr();
        return n.update(t), new Uint8Array(n.digest());
      }
      function Ou(e) {
        const t = new DataView(e.buffer),
          n = t.getUint32(0, !0),
          r = t.getUint32(4, !0),
          i = t.getUint32(8, !0),
          o = t.getUint32(12, !0);
        return [new Kr([n, r], 0), new Kr([i, o], 0)];
      }
      class Nu {
        constructor(e, t, n) {
          if (((this.bitmap = e), (this.padding = t), (this.hashCount = n), t < 0 || t >= 8)) throw new Ru(`Invalid padding: ${t}`);
          if (n < 0) throw new Ru(`Invalid hash count: ${n}`);
          if (e.length > 0 && 0 === this.hashCount) throw new Ru(`Invalid hash count: ${n}`);
          if (0 === e.length && 0 !== t) throw new Ru(`Invalid padding when bitmap length is 0: ${t}`);
          (this.It = 8 * e.length - t), (this.Tt = Kr.fromNumber(this.It));
        }
        Et(e, t, n) {
          let r = e.add(t.multiply(Kr.fromNumber(n)));
          return 1 === r.compare(Cu) && (r = new Kr([r.getBits(0), r.getBits(1)], 0)), r.modulo(this.Tt).toNumber();
        }
        At(e) {
          return 0 != (this.bitmap[Math.floor(e / 8)] & (1 << e % 8));
        }
        vt(e) {
          if (0 === this.It) return !1;
          const t = ku(e),
            [n, r] = Ou(t);
          for (let i = 0; i < this.hashCount; i++) {
            const e = this.Et(n, r, i);
            if (!this.At(e)) return !1;
          }
          return !0;
        }
        static create(e, t, n) {
          const r = e % 8 == 0 ? 0 : 8 - (e % 8),
            i = new Uint8Array(Math.ceil(e / 8)),
            o = new Nu(i, r, t);
          return n.forEach(e => o.insert(e)), o;
        }
        insert(e) {
          if (0 === this.It) return;
          const t = ku(e),
            [n, r] = Ou(t);
          for (let i = 0; i < this.hashCount; i++) {
            const e = this.Et(n, r, i);
            this.Rt(e);
          }
        }
        Rt(e) {
          const t = Math.floor(e / 8),
            n = e % 8;
          this.bitmap[t] |= 1 << n;
        }
      }
      class Ru extends Error {
        constructor() {
          super(...arguments), (this.name = 'BloomFilterError');
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Pu {
        constructor(e, t, n, r, i) {
          (this.snapshotVersion = e),
            (this.targetChanges = t),
            (this.targetMismatches = n),
            (this.documentUpdates = r),
            (this.resolvedLimboDocuments = i);
        }
        static createSynthesizedRemoteEventForCurrentChange(e, t, n) {
          const r = new Map();
          return r.set(e, Du.createSynthesizedTargetChangeForCurrentChange(e, t, n)), new Pu(Ai.min(), r, new Uo(Ii), Aa(), La());
        }
      }
      class Du {
        constructor(e, t, n, r, i) {
          (this.resumeToken = e), (this.current = t), (this.addedDocuments = n), (this.modifiedDocuments = r), (this.removedDocuments = i);
        }
        static createSynthesizedTargetChangeForCurrentChange(e, t, n) {
          return new Du(n, t, La(), La(), La());
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Lu {
        constructor(e, t, n, r) {
          (this.Pt = e), (this.removedTargetIds = t), (this.key = n), (this.bt = r);
        }
      }
      class ju {
        constructor(e, t) {
          (this.targetId = e), (this.Vt = t);
        }
      }
      class Mu {
        constructor(e, t, n = Ko.EMPTY_BYTE_STRING, r = null) {
          (this.state = e), (this.targetIds = t), (this.resumeToken = n), (this.cause = r);
        }
      }
      class Fu {
        constructor() {
          (this.St = 0), (this.Dt = Bu()), (this.Ct = Ko.EMPTY_BYTE_STRING), (this.xt = !1), (this.Nt = !0);
        }
        get current() {
          return this.xt;
        }
        get resumeToken() {
          return this.Ct;
        }
        get kt() {
          return 0 !== this.St;
        }
        get Mt() {
          return this.Nt;
        }
        $t(e) {
          e.approximateByteSize() > 0 && ((this.Nt = !0), (this.Ct = e));
        }
        Ot() {
          let e = La(),
            t = La(),
            n = La();
          return (
            this.Dt.forEach((r, i) => {
              switch (i) {
                case 0:
                  e = e.add(r);
                  break;
                case 2:
                  t = t.add(r);
                  break;
                case 1:
                  n = n.add(r);
                  break;
                default:
                  oi();
              }
            }),
            new Du(this.Ct, this.xt, e, t, n)
          );
        }
        Ft() {
          (this.Nt = !1), (this.Dt = Bu());
        }
        Bt(e, t) {
          (this.Nt = !0), (this.Dt = this.Dt.insert(e, t));
        }
        Lt(e) {
          (this.Nt = !0), (this.Dt = this.Dt.remove(e));
        }
        qt() {
          this.St += 1;
        }
        Ut() {
          this.St -= 1;
        }
        Kt() {
          (this.Nt = !0), (this.xt = !0);
        }
      }
      class Uu {
        constructor(e) {
          (this.Gt = e), (this.Qt = new Map()), (this.jt = Aa()), (this.zt = Vu()), (this.Wt = new Uo(Ii));
        }
        Ht(e) {
          for (const t of e.Pt) e.bt && e.bt.isFoundDocument() ? this.Jt(t, e.bt) : this.Yt(t, e.key, e.bt);
          for (const t of e.removedTargetIds) this.Yt(t, e.key, e.bt);
        }
        Xt(e) {
          this.forEachTarget(e, t => {
            const n = this.Zt(t);
            switch (e.state) {
              case 0:
                this.te(t) && n.$t(e.resumeToken);
                break;
              case 1:
                n.Ut(), n.kt || n.Ft(), n.$t(e.resumeToken);
                break;
              case 2:
                n.Ut(), n.kt || this.removeTarget(t);
                break;
              case 3:
                this.te(t) && (n.Kt(), n.$t(e.resumeToken));
                break;
              case 4:
                this.te(t) && (this.ee(t), n.$t(e.resumeToken));
                break;
              default:
                oi();
            }
          });
        }
        forEachTarget(e, t) {
          e.targetIds.length > 0
            ? e.targetIds.forEach(t)
            : this.Qt.forEach((e, n) => {
                this.te(n) && t(n);
              });
        }
        ne(e) {
          var t;
          const n = e.targetId,
            r = e.Vt.count,
            i = this.se(n);
          if (i) {
            const o = i.target;
            if (na(o))
              if (0 === r) {
                const e = new Ni(o.path);
                this.Yt(n, e, xs.newNoDocument(e, Ai.min()));
              } else si(1 === r);
            else {
              const i = this.ie(n);
              if (i !== r) {
                const r = this.re(e, i);
                if (0 !== r) {
                  this.ee(n);
                  const e = 2 === r ? 'TargetPurposeExistenceFilterMismatchBloom' : 'TargetPurposeExistenceFilterMismatch';
                  this.Wt = this.Wt.insert(n, e);
                }
                null === (t = Tu.instance) ||
                  void 0 === t ||
                  t.notifyOnExistenceFilterMismatch(
                    (function (e, t, n) {
                      var r, i, o, s, a, u;
                      const c = { localCacheCount: t, existenceFilterCount: n.count },
                        l = n.unchangedNames;
                      return (
                        l &&
                          (c.bloomFilter = {
                            applied: 0 === e,
                            hashCount: null !== (r = null == l ? void 0 : l.hashCount) && void 0 !== r ? r : 0,
                            bitmapLength:
                              null !==
                                (s =
                                  null === (o = null === (i = null == l ? void 0 : l.bits) || void 0 === i ? void 0 : i.bitmap) || void 0 === o
                                    ? void 0
                                    : o.length) && void 0 !== s
                                ? s
                                : 0,
                            padding:
                              null !== (u = null === (a = null == l ? void 0 : l.bits) || void 0 === a ? void 0 : a.padding) && void 0 !== u ? u : 0
                          }),
                        c
                      );
                    })(
                      /**
                       * @license
                       * Copyright 2017 Google LLC
                       *
                       * Licensed under the Apache License, Version 2.0 (the "License");
                       * you may not use this file except in compliance with the License.
                       * You may obtain a copy of the License at
                       *
                       *   http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */ r,
                      i,
                      e.Vt
                    )
                  );
              }
            }
          }
        }
        re(e, t) {
          const { unchangedNames: n, count: r } = e.Vt;
          if (!n || !n.bits) return 1;
          const {
            bits: { bitmap: i = '', padding: o = 0 },
            hashCount: s = 0
          } = n;
          let a, u;
          try {
            a = Jo(i).toUint8Array();
          } catch (e) {
            if (e instanceof Wo)
              return (
                ri(
                  'Decoding the base64 bloom filter in existence filter failed (' +
                    e.message +
                    '); ignoring the bloom filter and falling back to full re-query.'
                ),
                1
              );
            throw e;
          }
          try {
            u = new Nu(a, o, s);
          } catch (e) {
            return ri(e instanceof Ru ? 'BloomFilter error: ' : 'Applying bloom filter failed: ', e), 1;
          }
          return 0 === u.It ? 1 : r !== t - this.oe(e.targetId, u) ? 2 : 0;
        }
        oe(e, t) {
          const n = this.Gt.getRemoteKeysForTarget(e);
          let r = 0;
          return (
            n.forEach(n => {
              const i = this.Gt.ue(),
                o = `projects/${i.projectId}/databases/${i.database}/documents/${n.path.canonicalString()}`;
              t.vt(o) || (this.Yt(e, n, null), r++);
            }),
            r
          );
        }
        ce(e) {
          const t = new Map();
          this.Qt.forEach((n, r) => {
            const i = this.se(r);
            if (i) {
              if (n.current && na(i.target)) {
                const t = new Ni(i.target.path);
                null !== this.jt.get(t) || this.ae(r, t) || this.Yt(r, t, xs.newNoDocument(t, e));
              }
              n.Mt && (t.set(r, n.Ot()), n.Ft());
            }
          });
          let n = La();
          this.zt.forEach((e, t) => {
            let r = !0;
            t.forEachWhile(e => {
              const t = this.se(e);
              return !t || 'TargetPurposeLimboResolution' === t.purpose || ((r = !1), !1);
            }),
              r && (n = n.add(e));
          }),
            this.jt.forEach((t, n) => n.setReadTime(e));
          const r = new Pu(e, t, this.Wt, this.jt, n);
          return (this.jt = Aa()), (this.zt = Vu()), (this.Wt = new Uo(Ii)), r;
        }
        Jt(e, t) {
          if (!this.te(e)) return;
          const n = this.ae(e, t.key) ? 2 : 0;
          this.Zt(e).Bt(t.key, n), (this.jt = this.jt.insert(t.key, t)), (this.zt = this.zt.insert(t.key, this.he(t.key).add(e)));
        }
        Yt(e, t, n) {
          if (!this.te(e)) return;
          const r = this.Zt(e);
          this.ae(e, t) ? r.Bt(t, 1) : r.Lt(t), (this.zt = this.zt.insert(t, this.he(t).delete(e))), n && (this.jt = this.jt.insert(t, n));
        }
        removeTarget(e) {
          this.Qt.delete(e);
        }
        ie(e) {
          const t = this.Zt(e).Ot();
          return this.Gt.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size;
        }
        qt(e) {
          this.Zt(e).qt();
        }
        Zt(e) {
          let t = this.Qt.get(e);
          return t || ((t = new Fu()), this.Qt.set(e, t)), t;
        }
        he(e) {
          let t = this.zt.get(e);
          return t || ((t = new $o(Ii)), (this.zt = this.zt.insert(e, t))), t;
        }
        te(e) {
          const t = null !== this.se(e);
          return t || ti('WatchChangeAggregator', 'Detected inactive target', e), t;
        }
        se(e) {
          const t = this.Qt.get(e);
          return t && t.kt ? null : this.Gt.le(e);
        }
        ee(e) {
          this.Qt.set(e, new Fu()),
            this.Gt.getRemoteKeysForTarget(e).forEach(t => {
              this.Yt(e, t, null);
            });
        }
        ae(e, t) {
          return this.Gt.getRemoteKeysForTarget(e).has(t);
        }
      }
      function Vu() {
        return new Uo(Ni.comparator);
      }
      function Bu() {
        return new Uo(Ni.comparator);
      }
      const $u = (() => {
          const e = { asc: 'ASCENDING', desc: 'DESCENDING' };
          return e;
        })(),
        qu = (() => {
          const e = {
            '<': 'LESS_THAN',
            '<=': 'LESS_THAN_OR_EQUAL',
            '>': 'GREATER_THAN',
            '>=': 'GREATER_THAN_OR_EQUAL',
            '==': 'EQUAL',
            '!=': 'NOT_EQUAL',
            'array-contains': 'ARRAY_CONTAINS',
            in: 'IN',
            'not-in': 'NOT_IN',
            'array-contains-any': 'ARRAY_CONTAINS_ANY'
          };
          return e;
        })(),
        zu = (() => {
          const e = { and: 'AND', or: 'OR' };
          return e;
        })();
      class Gu {
        constructor(e, t) {
          (this.databaseId = e), (this.useProto3Json = t);
        }
      }
      function Wu(e, t) {
        return e.useProto3Json || ro(t) ? t : { value: t };
      }
      function Hu(e, t) {
        return e.useProto3Json
          ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, '').replace('Z', '')}.${('000000000' + t.nanoseconds).slice(-9)}Z`
          : { seconds: '' + t.seconds, nanos: t.nanoseconds };
      }
      function Ku(e, t) {
        return e.useProto3Json ? t.toBase64() : t.toUint8Array();
      }
      function Qu(e, t) {
        return Hu(e, t.toTimestamp());
      }
      function Yu(e) {
        return (
          si(!!e),
          Ai.fromTimestamp(
            (function (e) {
              const t = Yo(e);
              return new Ti(t.seconds, t.nanos);
            })(e)
          )
        );
      }
      function Xu(e, t) {
        return (function (e) {
          return new Ci(['projects', e.projectId, 'databases', e.database]);
        })(e)
          .child('documents')
          .child(t)
          .canonicalString();
      }
      function Ju(e) {
        const t = Ci.fromString(e);
        return si(Sc(t)), t;
      }
      function Zu(e, t) {
        return Xu(e.databaseId, t.path);
      }
      function ec(e, t) {
        const n = Ju(t);
        if (n.get(1) !== e.databaseId.projectId)
          throw new li(ci.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' + n.get(1) + ' vs ' + e.databaseId.projectId);
        if (n.get(3) !== e.databaseId.database)
          throw new li(ci.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' + n.get(3) + ' vs ' + e.databaseId.database);
        return new Ni(ic(n));
      }
      function tc(e, t) {
        return Xu(e.databaseId, t);
      }
      function nc(e) {
        const t = Ju(e);
        return 4 === t.length ? Ci.emptyPath() : ic(t);
      }
      function rc(e) {
        return new Ci(['projects', e.databaseId.projectId, 'databases', e.databaseId.database]).canonicalString();
      }
      function ic(e) {
        return si(e.length > 4 && 'documents' === e.get(4)), e.popFirst(5);
      }
      function oc(e, t, n) {
        return { name: Zu(e, t), fields: n.value.mapValue.fields };
      }
      function sc(e, t, n) {
        const r = ec(e, t.name),
          i = Yu(t.updateTime),
          o = t.createTime ? Yu(t.createTime) : Ai.min(),
          s = new Ts({ mapValue: { fields: t.fields } }),
          a = xs.newFoundDocument(r, i, o, s);
        return n && a.setHasCommittedMutations(), n ? a.setHasCommittedMutations() : a;
      }
      function ac(e, t) {
        return 'found' in t
          ? (function (e, t) {
              si(!!t.found), t.found.name, t.found.updateTime;
              const n = ec(e, t.found.name),
                r = Yu(t.found.updateTime),
                i = t.found.createTime ? Yu(t.found.createTime) : Ai.min(),
                o = new Ts({ mapValue: { fields: t.found.fields } });
              return xs.newFoundDocument(n, r, i, o);
            })(e, t)
          : 'missing' in t
            ? (function (e, t) {
                si(!!t.missing), si(!!t.readTime);
                const n = ec(e, t.missing),
                  r = Yu(t.readTime);
                return xs.newNoDocument(n, r);
              })(e, t)
            : oi();
      }
      function uc(e, t) {
        let n;
        if ('targetChange' in t) {
          t.targetChange;
          const r = (function (e) {
              return 'NO_CHANGE' === e ? 0 : 'ADD' === e ? 1 : 'REMOVE' === e ? 2 : 'CURRENT' === e ? 3 : 'RESET' === e ? 4 : oi();
            })(t.targetChange.targetChangeType || 'NO_CHANGE'),
            i = t.targetChange.targetIds || [],
            o = (function (e, t) {
              return e.useProto3Json
                ? (si(void 0 === t || 'string' == typeof t), Ko.fromBase64String(t || ''))
                : (si(void 0 === t || t instanceof Uint8Array), Ko.fromUint8Array(t || new Uint8Array()));
            })(e, t.targetChange.resumeToken),
            s = t.targetChange.cause,
            a =
              s &&
              (function (e) {
                const t = void 0 === e.code ? ci.UNKNOWN : Su(e.code);
                return new li(t, e.message || '');
              })(s);
          n = new Mu(r, i, o, a || null);
        } else if ('documentChange' in t) {
          t.documentChange;
          const r = t.documentChange;
          r.document, r.document.name, r.document.updateTime;
          const i = ec(e, r.document.name),
            o = Yu(r.document.updateTime),
            s = r.document.createTime ? Yu(r.document.createTime) : Ai.min(),
            a = new Ts({ mapValue: { fields: r.document.fields } }),
            u = xs.newFoundDocument(i, o, s, a),
            c = r.targetIds || [],
            l = r.removedTargetIds || [];
          n = new Lu(c, l, u.key, u);
        } else if ('documentDelete' in t) {
          t.documentDelete;
          const r = t.documentDelete;
          r.document;
          const i = ec(e, r.document),
            o = r.readTime ? Yu(r.readTime) : Ai.min(),
            s = xs.newNoDocument(i, o),
            a = r.removedTargetIds || [];
          n = new Lu([], a, s.key, s);
        } else if ('documentRemove' in t) {
          t.documentRemove;
          const r = t.documentRemove;
          r.document;
          const i = ec(e, r.document),
            o = r.removedTargetIds || [];
          n = new Lu([], o, i, null);
        } else {
          if (!('filter' in t)) return oi();
          {
            t.filter;
            const e = t.filter;
            e.targetId;
            const { count: r = 0, unchangedNames: i } = e,
              o = new bu(r, i),
              s = e.targetId;
            n = new ju(s, o);
          }
        }
        return n;
      }
      function cc(e, t) {
        let n;
        if (t instanceof lu) n = { update: oc(e, t.key, t.value) };
        else if (t instanceof gu) n = { delete: Zu(e, t.key) };
        else if (t instanceof hu) n = { update: oc(e, t.key, t.data), updateMask: Ec(t.fieldMask) };
        else {
          if (!(t instanceof mu)) return oi();
          n = { verify: Zu(e, t.key) };
        }
        return (
          t.fieldTransforms.length > 0 &&
            (n.updateTransforms = t.fieldTransforms.map(e =>
              (function (e, t) {
                const n = t.transform;
                if (n instanceof Ga) return { fieldPath: t.field.canonicalString(), setToServerValue: 'REQUEST_TIME' };
                if (n instanceof Wa) return { fieldPath: t.field.canonicalString(), appendMissingElements: { values: n.elements } };
                if (n instanceof Ka) return { fieldPath: t.field.canonicalString(), removeAllFromArray: { values: n.elements } };
                if (n instanceof Ya) return { fieldPath: t.field.canonicalString(), increment: n.gt };
                throw oi();
              })(0, e)
            )),
          t.precondition.isNone ||
            (n.currentDocument = (function (e, t) {
              return void 0 !== t.updateTime ? { updateTime: Qu(e, t.updateTime) } : void 0 !== t.exists ? { exists: t.exists } : oi();
            })(e, t.precondition)),
          n
        );
      }
      function lc(e, t) {
        const n = t.currentDocument
            ? (function (e) {
                return void 0 !== e.updateTime ? nu.updateTime(Yu(e.updateTime)) : void 0 !== e.exists ? nu.exists(e.exists) : nu.none();
              })(t.currentDocument)
            : nu.none(),
          r = t.updateTransforms
            ? t.updateTransforms.map(t =>
                (function (e, t) {
                  let n = null;
                  if ('setToServerValue' in t) si('REQUEST_TIME' === t.setToServerValue), (n = new Ga());
                  else if ('appendMissingElements' in t) {
                    const e = t.appendMissingElements.values || [];
                    n = new Wa(e);
                  } else if ('removeAllFromArray' in t) {
                    const e = t.removeAllFromArray.values || [];
                    n = new Ka(e);
                  } else 'increment' in t ? (n = new Ya(e, t.increment)) : oi();
                  const r = Oi.fromServerFormat(t.fieldPath);
                  return new Za(r, n);
                })(e, t)
              )
            : [];
        if (t.update) {
          t.update.name;
          const i = ec(e, t.update.name),
            o = new Ts({ mapValue: { fields: t.update.fields } });
          if (t.updateMask) {
            const e = (function (e) {
              const t = e.fieldPaths || [];
              return new Go(t.map(e => Oi.fromServerFormat(e)));
            })(t.updateMask);
            return new hu(i, o, e, n, r);
          }
          return new lu(i, o, n, r);
        }
        if (t.delete) {
          const r = ec(e, t.delete);
          return new gu(r, n);
        }
        if (t.verify) {
          const r = ec(e, t.verify);
          return new mu(r, n);
        }
        return oi();
      }
      function hc(e, t) {
        return e && e.length > 0
          ? (si(void 0 !== t),
            e.map(e =>
              (function (e, t) {
                let n = e.updateTime ? Yu(e.updateTime) : Yu(t);
                return n.isEqual(Ai.min()) && (n = Yu(t)), new tu(n, e.transformResults || []);
              })(e, t)
            ))
          : [];
      }
      function fc(e, t) {
        return { documents: [tc(e, t.path)] };
      }
      function dc(e, t) {
        const n = { structuredQuery: {} },
          r = t.path;
        null !== t.collectionGroup
          ? ((n.parent = tc(e, r)), (n.structuredQuery.from = [{ collectionId: t.collectionGroup, allDescendants: !0 }]))
          : ((n.parent = tc(e, r.popLast())), (n.structuredQuery.from = [{ collectionId: r.lastSegment() }]));
        const i = (function (e) {
          if (0 !== e.length) return Ic(Ls.create(e, 'and'));
        })(t.filters);
        i && (n.structuredQuery.where = i);
        const o = (function (e) {
          if (0 !== e.length)
            return e.map(e =>
              (function (e) {
                return { field: bc(e.field), direction: vc(e.dir) };
              })(e)
            );
        })(t.orderBy);
        o && (n.structuredQuery.orderBy = o);
        const s = Wu(e, t.limit);
        var a;
        return (
          null !== s && (n.structuredQuery.limit = s),
          t.startAt && (n.structuredQuery.startAt = { before: (a = t.startAt).inclusive, values: a.position }),
          t.endAt &&
            (n.structuredQuery.endAt = (function (e) {
              return { before: !e.inclusive, values: e.position };
            })(t.endAt)),
          n
        );
      }
      function pc(e) {
        let t = nc(e.parent);
        const n = e.structuredQuery,
          r = n.from ? n.from.length : 0;
        let i = null;
        if (r > 0) {
          si(1 === r);
          const e = n.from[0];
          e.allDescendants ? (i = e.collectionId) : (t = t.child(e.collectionId));
        }
        let o = [];
        n.where &&
          (o = (function (e) {
            const t = mc(e);
            return t instanceof Ls && Fs(t) ? t.getFilters() : [t];
          })(n.where));
        let s = [];
        n.orderBy &&
          (s = n.orderBy.map(e =>
            (function (e) {
              return new Ns(
                _c(e.field),
                (function (e) {
                  switch (e) {
                    case 'ASCENDING':
                      return 'asc';
                    case 'DESCENDING':
                      return 'desc';
                    default:
                      return;
                  }
                })(e.direction)
              );
            })(e)
          ));
        let a = null;
        n.limit &&
          (a = (function (e) {
            let t;
            return (t = 'object' == typeof e ? e.value : e), ro(t) ? null : t;
          })(n.limit));
        let u = null;
        n.startAt &&
          (u = (function (e) {
            const t = !!e.before,
              n = e.values || [];
            return new Cs(n, t);
          })(n.startAt));
        let c = null;
        return (
          n.endAt &&
            (c = (function (e) {
              const t = !e.before,
                n = e.values || [];
              return new Cs(n, t);
            })(n.endAt)),
          aa(t, i, s, o, a, 'F', u, c)
        );
      }
      function gc(e, t) {
        const n = (function (e) {
          switch (e) {
            case 'TargetPurposeListen':
              return null;
            case 'TargetPurposeExistenceFilterMismatch':
              return 'existence-filter-mismatch';
            case 'TargetPurposeExistenceFilterMismatchBloom':
              return 'existence-filter-mismatch-bloom';
            case 'TargetPurposeLimboResolution':
              return 'limbo-document';
            default:
              return oi();
          }
        })(t.purpose);
        return null == n ? null : { 'goog-listen-tags': n };
      }
      function mc(e) {
        return void 0 !== e.unaryFilter
          ? (function (e) {
              switch (e.unaryFilter.op) {
                case 'IS_NAN':
                  const t = _c(e.unaryFilter.field);
                  return Ds.create(t, '==', { doubleValue: NaN });
                case 'IS_NULL':
                  const n = _c(e.unaryFilter.field);
                  return Ds.create(n, '==', { nullValue: 'NULL_VALUE' });
                case 'IS_NOT_NAN':
                  const r = _c(e.unaryFilter.field);
                  return Ds.create(r, '!=', { doubleValue: NaN });
                case 'IS_NOT_NULL':
                  const i = _c(e.unaryFilter.field);
                  return Ds.create(i, '!=', { nullValue: 'NULL_VALUE' });
                default:
                  return oi();
              }
            })(e)
          : void 0 !== e.fieldFilter
            ? (function (e) {
                return Ds.create(
                  _c(e.fieldFilter.field),
                  (function (e) {
                    switch (e) {
                      case 'EQUAL':
                        return '==';
                      case 'NOT_EQUAL':
                        return '!=';
                      case 'GREATER_THAN':
                        return '>';
                      case 'GREATER_THAN_OR_EQUAL':
                        return '>=';
                      case 'LESS_THAN':
                        return '<';
                      case 'LESS_THAN_OR_EQUAL':
                        return '<=';
                      case 'ARRAY_CONTAINS':
                        return 'array-contains';
                      case 'IN':
                        return 'in';
                      case 'NOT_IN':
                        return 'not-in';
                      case 'ARRAY_CONTAINS_ANY':
                        return 'array-contains-any';
                      default:
                        return oi();
                    }
                  })(e.fieldFilter.op),
                  e.fieldFilter.value
                );
              })(e)
            : void 0 !== e.compositeFilter
              ? (function (e) {
                  return Ls.create(
                    e.compositeFilter.filters.map(e => mc(e)),
                    (function (e) {
                      switch (e) {
                        case 'AND':
                          return 'and';
                        case 'OR':
                          return 'or';
                        default:
                          return oi();
                      }
                    })(e.compositeFilter.op)
                  );
                })(e)
              : oi();
      }
      function vc(e) {
        return $u[e];
      }
      function yc(e) {
        return qu[e];
      }
      function wc(e) {
        return zu[e];
      }
      function bc(e) {
        return { fieldPath: e.canonicalString() };
      }
      function _c(e) {
        return Oi.fromServerFormat(e.fieldPath);
      }
      function Ic(e) {
        return e instanceof Ds
          ? (function (e) {
              if ('==' === e.op) {
                if (vs(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NAN' } };
                if (ms(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NULL' } };
              } else if ('!=' === e.op) {
                if (vs(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NOT_NAN' } };
                if (ms(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NOT_NULL' } };
              }
              return { fieldFilter: { field: bc(e.field), op: yc(e.op), value: e.value } };
            })(e)
          : e instanceof Ls
            ? (function (e) {
                const t = e.getFilters().map(e => Ic(e));
                return 1 === t.length ? t[0] : { compositeFilter: { op: wc(e.op), filters: t } };
              })(e)
            : oi();
      }
      function Ec(e) {
        const t = [];
        return e.fields.forEach(e => t.push(e.canonicalString())), { fieldPaths: t };
      }
      function Sc(e) {
        return e.length >= 4 && 'projects' === e.get(0) && 'databases' === e.get(2);
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tc {
        constructor(e, t, n, r, i = Ai.min(), o = Ai.min(), s = Ko.EMPTY_BYTE_STRING, a = null) {
          (this.target = e),
            (this.targetId = t),
            (this.purpose = n),
            (this.sequenceNumber = r),
            (this.snapshotVersion = i),
            (this.lastLimboFreeSnapshotVersion = o),
            (this.resumeToken = s),
            (this.expectedCount = a);
        }
        withSequenceNumber(e) {
          return new Tc(
            this.target,
            this.targetId,
            this.purpose,
            e,
            this.snapshotVersion,
            this.lastLimboFreeSnapshotVersion,
            this.resumeToken,
            this.expectedCount
          );
        }
        withResumeToken(e, t) {
          return new Tc(this.target, this.targetId, this.purpose, this.sequenceNumber, t, this.lastLimboFreeSnapshotVersion, e, null);
        }
        withExpectedCount(e) {
          return new Tc(
            this.target,
            this.targetId,
            this.purpose,
            this.sequenceNumber,
            this.snapshotVersion,
            this.lastLimboFreeSnapshotVersion,
            this.resumeToken,
            e
          );
        }
        withLastLimboFreeSnapshotVersion(e) {
          return new Tc(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ac {
        constructor(e) {
          this.fe = e;
        }
      }
      function xc(e, t) {
        let n;
        if (t.document) n = sc(e.fe, t.document, !!t.hasCommittedMutations);
        else if (t.noDocument) {
          const e = Ni.fromSegments(t.noDocument.path),
            r = Nc(t.noDocument.readTime);
          (n = xs.newNoDocument(e, r)), t.hasCommittedMutations && n.setHasCommittedMutations();
        } else {
          if (!t.unknownDocument) return oi();
          {
            const e = Ni.fromSegments(t.unknownDocument.path),
              r = Nc(t.unknownDocument.version);
            n = xs.newUnknownDocument(e, r);
          }
        }
        return (
          t.readTime &&
            n.setReadTime(
              (function (e) {
                const t = new Ti(e[0], e[1]);
                return Ai.fromTimestamp(t);
              })(t.readTime)
            ),
          n
        );
      }
      function Cc(e, t) {
        const n = t.key,
          r = {
            prefixPath: n.getCollectionPath().popLast().toArray(),
            collectionGroup: n.collectionGroup,
            documentId: n.path.lastSegment(),
            readTime: kc(t.readTime),
            hasCommittedMutations: t.hasCommittedMutations
          };
        if (t.isFoundDocument())
          r.document = (function (e, t) {
            return {
              name: Zu(e, t.key),
              fields: t.data.value.mapValue.fields,
              updateTime: Hu(e, t.version.toTimestamp()),
              createTime: Hu(e, t.createTime.toTimestamp())
            };
          })(e.fe, t);
        else if (t.isNoDocument()) r.noDocument = { path: n.path.toArray(), readTime: Oc(t.version) };
        else {
          if (!t.isUnknownDocument()) return oi();
          r.unknownDocument = { path: n.path.toArray(), version: Oc(t.version) };
        }
        return r;
      }
      function kc(e) {
        const t = e.toTimestamp();
        return [t.seconds, t.nanoseconds];
      }
      function Oc(e) {
        const t = e.toTimestamp();
        return { seconds: t.seconds, nanoseconds: t.nanoseconds };
      }
      function Nc(e) {
        const t = new Ti(e.seconds, e.nanoseconds);
        return Ai.fromTimestamp(t);
      }
      function Rc(e, t) {
        const n = (t.baseMutations || []).map(t => lc(e.fe, t));
        for (let o = 0; o < t.mutations.length - 1; ++o) {
          const e = t.mutations[o];
          if (o + 1 < t.mutations.length && void 0 !== t.mutations[o + 1].transform) {
            const n = t.mutations[o + 1];
            (e.updateTransforms = n.transform.fieldTransforms), t.mutations.splice(o + 1, 1), ++o;
          }
        }
        const r = t.mutations.map(t => lc(e.fe, t)),
          i = Ti.fromMillis(t.localWriteTimeMs);
        return new vu(t.batchId, i, n, r);
      }
      function Pc(e) {
        const t = Nc(e.readTime),
          n = void 0 !== e.lastLimboFreeSnapshotVersion ? Nc(e.lastLimboFreeSnapshotVersion) : Ai.min();
        let r;
        var i;
        return (
          void 0 !== e.query.documents
            ? (si(1 === (i = e.query).documents.length), (r = pa(ua(nc(i.documents[0])))))
            : (r = (function (e) {
                return pa(pc(e));
              })(e.query)),
          new Tc(r, e.targetId, 'TargetPurposeListen', e.lastListenSequenceNumber, t, n, Ko.fromBase64String(e.resumeToken))
        );
      }
      function Dc(e, t) {
        const n = Oc(t.snapshotVersion),
          r = Oc(t.lastLimboFreeSnapshotVersion);
        let i;
        i = na(t.target) ? fc(e.fe, t.target) : dc(e.fe, t.target);
        const o = t.resumeToken.toBase64();
        return {
          targetId: t.targetId,
          canonicalId: ea(t.target),
          readTime: n,
          resumeToken: o,
          lastListenSequenceNumber: t.sequenceNumber,
          lastLimboFreeSnapshotVersion: r,
          query: i
        };
      }
      function Lc(e) {
        const t = pc({ parent: e.parent, structuredQuery: e.structuredQuery });
        return 'LAST' === e.limitType ? ma(t, t.limit, 'L') : t;
      }
      function jc(e, t) {
        return new wu(t.largestBatchId, lc(e.fe, t.overlayMutation));
      }
      function Mc(e, t) {
        const n = t.path.lastSegment();
        return [e, so(t.path.popLast()), n];
      }
      function Fc(e, t, n, r) {
        return {
          indexId: e,
          uid: t.uid || '',
          sequenceNumber: n,
          readTime: Oc(r.readTime),
          documentKey: so(r.documentKey.path),
          largestBatchId: r.largestBatchId
        };
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Uc {
        getBundleMetadata(e, t) {
          return Vc(e)
            .get(t)
            .next(e => {
              if (e) return { id: (t = e).bundleId, createTime: Nc(t.createTime), version: t.version };
              var t;
            });
        }
        saveBundleMetadata(e, t) {
          return Vc(e).put({ bundleId: (n = t).id, createTime: Oc(Yu(n.createTime)), version: n.version });
          var n;
        }
        getNamedQuery(e, t) {
          return Bc(e)
            .get(t)
            .next(e => {
              if (e) return { name: (t = e).name, query: Lc(t.bundledQuery), readTime: Nc(t.readTime) };
              var t;
            });
        }
        saveNamedQuery(e, t) {
          return Bc(e).put(
            (function (e) {
              return { name: e.name, readTime: Oc(Yu(e.readTime)), bundledQuery: e.bundledQuery };
            })(t)
          );
        }
      }
      function Vc(e) {
        return Lo(e, 'bundles');
      }
      function Bc(e) {
        return Lo(e, 'namedQueries');
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class $c {
        constructor(e, t) {
          (this.serializer = e), (this.userId = t);
        }
        static de(e, t) {
          const n = t.uid || '';
          return new $c(e, n);
        }
        getOverlay(e, t) {
          return qc(e)
            .get(Mc(this.userId, t))
            .next(e => (e ? jc(this.serializer, e) : null));
        }
        getOverlays(e, t) {
          const n = Oa();
          return zi
            .forEach(t, t =>
              this.getOverlay(e, t).next(e => {
                null !== e && n.set(t, e);
              })
            )
            .next(() => n);
        }
        saveOverlays(e, t, n) {
          const r = [];
          return (
            n.forEach((n, i) => {
              const o = new wu(t, i);
              r.push(this.we(e, o));
            }),
            zi.waitFor(r)
          );
        }
        removeOverlaysForBatchId(e, t, n) {
          const r = new Set();
          t.forEach(e => r.add(so(e.getCollectionPath())));
          const i = [];
          return (
            r.forEach(t => {
              const r = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, n + 1], !1, !0);
              i.push(qc(e).J('collectionPathOverlayIndex', r));
            }),
            zi.waitFor(i)
          );
        }
        getOverlaysForCollection(e, t, n) {
          const r = Oa(),
            i = so(t),
            o = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], !0);
          return qc(e)
            .j('collectionPathOverlayIndex', o)
            .next(e => {
              for (const t of e) {
                const e = jc(this.serializer, t);
                r.set(e.getKey(), e);
              }
              return r;
            });
        }
        getOverlaysForCollectionGroup(e, t, n, r) {
          const i = Oa();
          let o;
          const s = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, Number.POSITIVE_INFINITY], !0);
          return qc(e)
            .X({ index: 'collectionGroupOverlayIndex', range: s }, (e, t, n) => {
              const s = jc(this.serializer, t);
              i.size() < r || s.largestBatchId === o ? (i.set(s.getKey(), s), (o = s.largestBatchId)) : n.done();
            })
            .next(() => i);
        }
        we(e, t) {
          return qc(e).put(
            (function (e, t, n) {
              const [r, i, o] = Mc(t, n.mutation.key);
              return {
                userId: t,
                collectionPath: i,
                documentId: o,
                collectionGroup: n.mutation.key.getCollectionGroup(),
                largestBatchId: n.largestBatchId,
                overlayMutation: cc(e.fe, n.mutation)
              };
            })(this.serializer, this.userId, t)
          );
        }
      }
      function qc(e) {
        return Lo(e, 'documentOverlays');
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class zc {
        constructor() {}
        _e(e, t) {
          this.me(e, t), t.ge();
        }
        me(e, t) {
          if ('nullValue' in e) this.ye(t, 5);
          else if ('booleanValue' in e) this.ye(t, 10), t.pe(e.booleanValue ? 1 : 0);
          else if ('integerValue' in e) this.ye(t, 15), t.pe(Xo(e.integerValue));
          else if ('doubleValue' in e) {
            const n = Xo(e.doubleValue);
            isNaN(n) ? this.ye(t, 13) : (this.ye(t, 15), io(n) ? t.pe(0) : t.pe(n));
          } else if ('timestampValue' in e) {
            const n = e.timestampValue;
            this.ye(t, 20), 'string' == typeof n ? t.Ie(n) : (t.Ie(`${n.seconds || ''}`), t.pe(n.nanos || 0));
          } else if ('stringValue' in e) this.Te(e.stringValue, t), this.Ee(t);
          else if ('bytesValue' in e) this.ye(t, 30), t.Ae(Jo(e.bytesValue)), this.Ee(t);
          else if ('referenceValue' in e) this.ve(e.referenceValue, t);
          else if ('geoPointValue' in e) {
            const n = e.geoPointValue;
            this.ye(t, 45), t.pe(n.latitude || 0), t.pe(n.longitude || 0);
          } else
            'mapValue' in e
              ? bs(e)
                ? this.ye(t, Number.MAX_SAFE_INTEGER)
                : (this.Re(e.mapValue, t), this.Ee(t))
              : 'arrayValue' in e
                ? (this.Pe(e.arrayValue, t), this.Ee(t))
                : oi();
        }
        Te(e, t) {
          this.ye(t, 25), this.be(e, t);
        }
        be(e, t) {
          t.Ie(e);
        }
        Re(e, t) {
          const n = e.fields || {};
          this.ye(t, 55);
          for (const r of Object.keys(n)) this.Te(r, t), this.me(n[r], t);
        }
        Pe(e, t) {
          const n = e.values || [];
          this.ye(t, 50);
          for (const r of n) this.me(r, t);
        }
        ve(e, t) {
          this.ye(t, 37),
            Ni.fromName(e).path.forEach(e => {
              this.ye(t, 60), this.be(e, t);
            });
        }
        ye(e, t) {
          e.pe(t);
        }
        Ee(e) {
          e.pe(2);
        }
      }
      function Gc(e) {
        if (0 === e) return 8;
        let t = 0;
        return e >> 4 == 0 && ((t += 4), (e <<= 4)), e >> 6 == 0 && ((t += 2), (e <<= 2)), e >> 7 == 0 && (t += 1), t;
      }
      function Wc(e) {
        const t =
          64 -
          (function (e) {
            let t = 0;
            for (let n = 0; n < 8; ++n) {
              const r = Gc(255 & e[n]);
              if (((t += r), 8 !== r)) break;
            }
            return t;
          })(e);
        return Math.ceil(t / 8);
      }
      zc.Ve = new zc();
      class Hc {
        constructor() {
          (this.buffer = new Uint8Array(1024)), (this.position = 0);
        }
        Se(e) {
          const t = e[Symbol.iterator]();
          let n = t.next();
          for (; !n.done; ) this.De(n.value), (n = t.next());
          this.Ce();
        }
        xe(e) {
          const t = e[Symbol.iterator]();
          let n = t.next();
          for (; !n.done; ) this.Ne(n.value), (n = t.next());
          this.ke();
        }
        Me(e) {
          for (const t of e) {
            const e = t.charCodeAt(0);
            if (e < 128) this.De(e);
            else if (e < 2048) this.De(960 | (e >>> 6)), this.De(128 | (63 & e));
            else if (t < '\ud800' || '\udbff' < t) this.De(480 | (e >>> 12)), this.De(128 | (63 & (e >>> 6))), this.De(128 | (63 & e));
            else {
              const e = t.codePointAt(0);
              this.De(240 | (e >>> 18)), this.De(128 | (63 & (e >>> 12))), this.De(128 | (63 & (e >>> 6))), this.De(128 | (63 & e));
            }
          }
          this.Ce();
        }
        $e(e) {
          for (const t of e) {
            const e = t.charCodeAt(0);
            if (e < 128) this.Ne(e);
            else if (e < 2048) this.Ne(960 | (e >>> 6)), this.Ne(128 | (63 & e));
            else if (t < '\ud800' || '\udbff' < t) this.Ne(480 | (e >>> 12)), this.Ne(128 | (63 & (e >>> 6))), this.Ne(128 | (63 & e));
            else {
              const e = t.codePointAt(0);
              this.Ne(240 | (e >>> 18)), this.Ne(128 | (63 & (e >>> 12))), this.Ne(128 | (63 & (e >>> 6))), this.Ne(128 | (63 & e));
            }
          }
          this.ke();
        }
        Oe(e) {
          const t = this.Fe(e),
            n = Wc(t);
          this.Be(1 + n), (this.buffer[this.position++] = 255 & n);
          for (let r = t.length - n; r < t.length; ++r) this.buffer[this.position++] = 255 & t[r];
        }
        Le(e) {
          const t = this.Fe(e),
            n = Wc(t);
          this.Be(1 + n), (this.buffer[this.position++] = ~(255 & n));
          for (let r = t.length - n; r < t.length; ++r) this.buffer[this.position++] = ~(255 & t[r]);
        }
        qe() {
          this.Ue(255), this.Ue(255);
        }
        Ke() {
          this.Ge(255), this.Ge(255);
        }
        reset() {
          this.position = 0;
        }
        seed(e) {
          this.Be(e.length), this.buffer.set(e, this.position), (this.position += e.length);
        }
        Qe() {
          return this.buffer.slice(0, this.position);
        }
        Fe(e) {
          const t = (function (e) {
              const t = new DataView(new ArrayBuffer(8));
              return t.setFloat64(0, e, !1), new Uint8Array(t.buffer);
            })(e),
            n = 0 != (128 & t[0]);
          t[0] ^= n ? 255 : 128;
          for (let r = 1; r < t.length; ++r) t[r] ^= n ? 255 : 0;
          return t;
        }
        De(e) {
          const t = 255 & e;
          0 === t ? (this.Ue(0), this.Ue(255)) : 255 === t ? (this.Ue(255), this.Ue(0)) : this.Ue(t);
        }
        Ne(e) {
          const t = 255 & e;
          0 === t ? (this.Ge(0), this.Ge(255)) : 255 === t ? (this.Ge(255), this.Ge(0)) : this.Ge(e);
        }
        Ce() {
          this.Ue(0), this.Ue(1);
        }
        ke() {
          this.Ge(0), this.Ge(1);
        }
        Ue(e) {
          this.Be(1), (this.buffer[this.position++] = e);
        }
        Ge(e) {
          this.Be(1), (this.buffer[this.position++] = ~e);
        }
        Be(e) {
          const t = e + this.position;
          if (t <= this.buffer.length) return;
          let n = 2 * this.buffer.length;
          n < t && (n = t);
          const r = new Uint8Array(n);
          r.set(this.buffer), (this.buffer = r);
        }
      }
      class Kc {
        constructor(e) {
          this.je = e;
        }
        Ae(e) {
          this.je.Se(e);
        }
        Ie(e) {
          this.je.Me(e);
        }
        pe(e) {
          this.je.Oe(e);
        }
        ge() {
          this.je.qe();
        }
      }
      class Qc {
        constructor(e) {
          this.je = e;
        }
        Ae(e) {
          this.je.xe(e);
        }
        Ie(e) {
          this.je.$e(e);
        }
        pe(e) {
          this.je.Le(e);
        }
        ge() {
          this.je.Ke();
        }
      }
      class Yc {
        constructor() {
          (this.je = new Hc()), (this.ze = new Kc(this.je)), (this.We = new Qc(this.je));
        }
        seed(e) {
          this.je.seed(e);
        }
        He(e) {
          return 0 === e ? this.ze : this.We;
        }
        Qe() {
          return this.je.Qe();
        }
        reset() {
          this.je.reset();
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Xc {
        constructor(e, t, n, r) {
          (this.indexId = e), (this.documentKey = t), (this.arrayValue = n), (this.directionalValue = r);
        }
        Je() {
          const e = this.directionalValue.length,
            t = 0 === e || 255 === this.directionalValue[e - 1] ? e + 1 : e,
            n = new Uint8Array(t);
          return (
            n.set(this.directionalValue, 0),
            t !== e ? n.set([0], this.directionalValue.length) : ++n[n.length - 1],
            new Xc(this.indexId, this.documentKey, this.arrayValue, n)
          );
        }
      }
      function Jc(e, t) {
        let n = e.indexId - t.indexId;
        return 0 !== n
          ? n
          : ((n = Zc(e.arrayValue, t.arrayValue)),
            0 !== n ? n : ((n = Zc(e.directionalValue, t.directionalValue)), 0 !== n ? n : Ni.comparator(e.documentKey, t.documentKey)));
      }
      function Zc(e, t) {
        for (let n = 0; n < e.length && n < t.length; ++n) {
          const r = e[n] - t[n];
          if (0 !== r) return r;
        }
        return e.length - t.length;
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class el {
        constructor(e) {
          (this.collectionId = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment()), (this.Ye = e.orderBy), (this.Xe = []);
          for (const t of e.filters) {
            const e = t;
            e.isInequality() ? (this.Ze = e) : this.Xe.push(e);
          }
        }
        tn(e) {
          si(e.collectionGroup === this.collectionId);
          const t = Pi(e);
          if (void 0 !== t && !this.en(t)) return !1;
          const n = Di(e);
          let r = new Set(),
            i = 0,
            o = 0;
          for (; i < n.length && this.en(n[i]); ++i) r = r.add(n[i].fieldPath.canonicalString());
          if (i === n.length) return !0;
          if (void 0 !== this.Ze) {
            if (!r.has(this.Ze.field.canonicalString())) {
              const e = n[i];
              if (!this.nn(this.Ze, e) || !this.sn(this.Ye[o++], e)) return !1;
            }
            ++i;
          }
          for (; i < n.length; ++i) {
            const e = n[i];
            if (o >= this.Ye.length || !this.sn(this.Ye[o++], e)) return !1;
          }
          return !0;
        }
        en(e) {
          for (const t of this.Xe) if (this.nn(t, e)) return !0;
          return !1;
        }
        nn(e, t) {
          if (void 0 === e || !e.field.isEqual(t.fieldPath)) return !1;
          const n = 'array-contains' === e.op || 'array-contains-any' === e.op;
          return (2 === t.kind) === n;
        }
        sn(e, t) {
          return !!e.field.isEqual(t.fieldPath) && ((0 === t.kind && 'asc' === e.dir) || (1 === t.kind && 'desc' === e.dir));
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function tl(e) {
        var t, n;
        if ((si(e instanceof Ds || e instanceof Ls), e instanceof Ds)) {
          if (e instanceof Qs) {
            const r =
              (null === (n = null === (t = e.value.arrayValue) || void 0 === t ? void 0 : t.values) || void 0 === n
                ? void 0
                : n.map(t => Ds.create(e.field, '==', t))) || [];
            return Ls.create(r, 'or');
          }
          return e;
        }
        const r = e.filters.map(e => tl(e));
        return Ls.create(r, e.op);
      }
      function nl(e) {
        if (0 === e.getFilters().length) return [];
        const t = sl(tl(e));
        return si(ol(t)), rl(t) || il(t) ? [t] : t.getFilters();
      }
      function rl(e) {
        return e instanceof Ds;
      }
      function il(e) {
        return e instanceof Ls && Fs(e);
      }
      function ol(e) {
        return (
          rl(e) ||
          il(e) ||
          (function (e) {
            if (e instanceof Ls && Ms(e)) {
              for (const t of e.getFilters()) if (!rl(t) && !il(t)) return !1;
              return !0;
            }
            return !1;
          })(e)
        );
      }
      function sl(e) {
        if ((si(e instanceof Ds || e instanceof Ls), e instanceof Ds)) return e;
        if (1 === e.filters.length) return sl(e.filters[0]);
        const t = e.filters.map(e => sl(e));
        let n = Ls.create(t, e.op);
        return (n = cl(n)), ol(n) ? n : (si(n instanceof Ls), si(js(n)), si(n.filters.length > 1), n.filters.reduce((e, t) => al(e, t)));
      }
      function al(e, t) {
        let n;
        return (
          si(e instanceof Ds || e instanceof Ls),
          si(t instanceof Ds || t instanceof Ls),
          (n =
            e instanceof Ds
              ? t instanceof Ds
                ? (function (e, t) {
                    return Ls.create([e, t], 'and');
                  })(e, t)
                : ul(e, t)
              : t instanceof Ds
                ? ul(t, e)
                : (function (e, t) {
                    if ((si(e.filters.length > 0 && t.filters.length > 0), js(e) && js(t))) return $s(e, t.getFilters());
                    const n = Ms(e) ? e : t,
                      r = Ms(e) ? t : e,
                      i = n.filters.map(e => al(e, r));
                    return Ls.create(i, 'or');
                  })(e, t)),
          cl(n)
        );
      }
      function ul(e, t) {
        if (js(t)) return $s(t, e.getFilters());
        {
          const n = t.filters.map(t => al(e, t));
          return Ls.create(n, 'or');
        }
      }
      function cl(e) {
        if ((si(e instanceof Ds || e instanceof Ls), e instanceof Ds)) return e;
        const t = e.getFilters();
        if (1 === t.length) return cl(t[0]);
        if (Us(e)) return e;
        const n = t.map(e => cl(e)),
          r = [];
        return (
          n.forEach(t => {
            t instanceof Ds ? r.push(t) : t instanceof Ls && (t.op === e.op ? r.push(...t.filters) : r.push(t));
          }),
          1 === r.length ? r[0] : Ls.create(r, e.op)
        );
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class ll {
        constructor() {
          this.rn = new hl();
        }
        addToCollectionParentIndex(e, t) {
          return this.rn.add(t), zi.resolve();
        }
        getCollectionParents(e, t) {
          return zi.resolve(this.rn.getEntries(t));
        }
        addFieldIndex(e, t) {
          return zi.resolve();
        }
        deleteFieldIndex(e, t) {
          return zi.resolve();
        }
        getDocumentsMatchingTarget(e, t) {
          return zi.resolve(null);
        }
        getIndexType(e, t) {
          return zi.resolve(0);
        }
        getFieldIndexes(e, t) {
          return zi.resolve([]);
        }
        getNextCollectionGroupToUpdate(e) {
          return zi.resolve(null);
        }
        getMinOffset(e, t) {
          return zi.resolve(Ui.min());
        }
        getMinOffsetFromCollectionGroup(e, t) {
          return zi.resolve(Ui.min());
        }
        updateCollectionGroup(e, t, n) {
          return zi.resolve();
        }
        updateIndexEntries(e, t) {
          return zi.resolve();
        }
      }
      class hl {
        constructor() {
          this.index = {};
        }
        add(e) {
          const t = e.lastSegment(),
            n = e.popLast(),
            r = this.index[t] || new $o(Ci.comparator),
            i = !r.has(n);
          return (this.index[t] = r.add(n)), i;
        }
        has(e) {
          const t = e.lastSegment(),
            n = e.popLast(),
            r = this.index[t];
          return r && r.has(n);
        }
        getEntries(e) {
          return (this.index[e] || new $o(Ci.comparator)).toArray();
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const fl = new Uint8Array(0);
      class dl {
        constructor(e, t) {
          (this.user = e),
            (this.databaseId = t),
            (this.on = new hl()),
            (this.un = new Sa(
              e => ea(e),
              (e, t) => ta(e, t)
            )),
            (this.uid = e.uid || '');
        }
        addToCollectionParentIndex(e, t) {
          if (!this.on.has(t)) {
            const n = t.lastSegment(),
              r = t.popLast();
            e.addOnCommittedListener(() => {
              this.on.add(t);
            });
            const i = { collectionId: n, parent: so(r) };
            return pl(e).put(i);
          }
          return zi.resolve();
        }
        getCollectionParents(e, t) {
          const n = [],
            r = IDBKeyRange.bound([t, ''], [Si(t), ''], !1, !0);
          return pl(e)
            .j(r)
            .next(e => {
              for (const r of e) {
                if (r.collectionId !== t) break;
                n.push(co(r.parent));
              }
              return n;
            });
        }
        addFieldIndex(e, t) {
          const n = ml(e),
            r = (function (e) {
              return { indexId: e.indexId, collectionGroup: e.collectionGroup, fields: e.fields.map(e => [e.fieldPath.canonicalString(), e.kind]) };
            })(t);
          delete r.indexId;
          const i = n.add(r);
          if (t.indexState) {
            const n = vl(e);
            return i.next(e => {
              n.put(Fc(e, this.user, t.indexState.sequenceNumber, t.indexState.offset));
            });
          }
          return i.next();
        }
        deleteFieldIndex(e, t) {
          const n = ml(e),
            r = vl(e),
            i = gl(e);
          return n
            .delete(t.indexId)
            .next(() => r.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)))
            .next(() => i.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)));
        }
        getDocumentsMatchingTarget(e, t) {
          const n = gl(e);
          let r = !0;
          const i = new Map();
          return zi
            .forEach(this.cn(t), t =>
              this.an(e, t).next(e => {
                r && (r = !!e), i.set(t, e);
              })
            )
            .next(() => {
              if (r) {
                let e = La();
                const r = [];
                return zi
                  .forEach(i, (i, o) => {
                    var s;
                    ti(
                      'IndexedDbIndexManager',
                      `Using index ${((s = i), `id=${s.indexId}|cg=${s.collectionGroup}|f=${s.fields.map(e => `${e.fieldPath}:${e.kind}`).join(',')}`)} to execute ${ea(t)}`
                    );
                    const a = (function (e, t) {
                        const n = Pi(t);
                        if (void 0 === n) return null;
                        for (const r of ra(e, n.fieldPath))
                          switch (r.op) {
                            case 'array-contains-any':
                              return r.value.arrayValue.values || [];
                            case 'array-contains':
                              return [r.value];
                          }
                        return null;
                      })(o, i),
                      u = (function (e, t) {
                        const n = new Map();
                        for (const r of Di(t))
                          for (const t of ra(e, r.fieldPath))
                            switch (t.op) {
                              case '==':
                              case 'in':
                                n.set(r.fieldPath.canonicalString(), t.value);
                                break;
                              case 'not-in':
                              case '!=':
                                return n.set(r.fieldPath.canonicalString(), t.value), Array.from(n.values());
                            }
                        return null;
                      })(o, i),
                      c = (function (e, t) {
                        const n = [];
                        let r = !0;
                        for (const i of Di(t)) {
                          const t = 0 === i.kind ? ia(e, i.fieldPath, e.startAt) : oa(e, i.fieldPath, e.startAt);
                          n.push(t.value), r && (r = t.inclusive);
                        }
                        return new Cs(n, r);
                      })(o, i),
                      l = (function (e, t) {
                        const n = [];
                        let r = !0;
                        for (const i of Di(t)) {
                          const t = 0 === i.kind ? oa(e, i.fieldPath, e.endAt) : ia(e, i.fieldPath, e.endAt);
                          n.push(t.value), r && (r = t.inclusive);
                        }
                        return new Cs(n, r);
                      })(o, i),
                      h = this.hn(i, o, c),
                      f = this.hn(i, o, l),
                      d = this.ln(i, o, u),
                      p = this.fn(i.indexId, a, h, c.inclusive, f, l.inclusive, d);
                    return zi.forEach(p, i =>
                      n.H(i, t.limit).next(t => {
                        t.forEach(t => {
                          const n = Ni.fromSegments(t.documentKey);
                          e.has(n) || ((e = e.add(n)), r.push(n));
                        });
                      })
                    );
                  })
                  .next(() => r);
              }
              return zi.resolve(null);
            });
        }
        cn(e) {
          let t = this.un.get(e);
          return (
            t ||
            ((t =
              0 === e.filters.length
                ? [e]
                : nl(Ls.create(e.filters, 'and')).map(t => Zs(e.path, e.collectionGroup, e.orderBy, t.getFilters(), e.limit, e.startAt, e.endAt))),
            this.un.set(e, t),
            t)
          );
        }
        fn(e, t, n, r, i, o, s) {
          const a = (null != t ? t.length : 1) * Math.max(n.length, i.length),
            u = a / (null != t ? t.length : 1),
            c = [];
          for (let l = 0; l < a; ++l) {
            const a = t ? this.dn(t[l / u]) : fl,
              h = this.wn(e, a, n[l % u], r),
              f = this._n(e, a, i[l % u], o),
              d = s.map(t => this.wn(e, a, t, !0));
            c.push(...this.createRange(h, f, d));
          }
          return c;
        }
        wn(e, t, n, r) {
          const i = new Xc(e, Ni.empty(), t, n);
          return r ? i : i.Je();
        }
        _n(e, t, n, r) {
          const i = new Xc(e, Ni.empty(), t, n);
          return r ? i.Je() : i;
        }
        an(e, t) {
          const n = new el(t),
            r = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment();
          return this.getFieldIndexes(e, r).next(e => {
            let t = null;
            for (const r of e) n.tn(r) && (!t || r.fields.length > t.fields.length) && (t = r);
            return t;
          });
        }
        getIndexType(e, t) {
          let n = 2;
          const r = this.cn(t);
          return zi
            .forEach(r, t =>
              this.an(e, t).next(e => {
                e
                  ? 0 !== n &&
                    e.fields.length <
                      (function (e) {
                        let t = new $o(Oi.comparator),
                          n = !1;
                        for (const r of e.filters)
                          for (const e of r.getFlattenedFilters())
                            e.field.isKeyField() || ('array-contains' === e.op || 'array-contains-any' === e.op ? (n = !0) : (t = t.add(e.field)));
                        for (const r of e.orderBy) r.field.isKeyField() || (t = t.add(r.field));
                        return t.size + (n ? 1 : 0);
                      })(t) &&
                    (n = 1)
                  : (n = 0);
              })
            )
            .next(() =>
              (function (e) {
                return null !== e.limit;
              })(t) &&
              r.length > 1 &&
              2 === n
                ? 1
                : n
            );
        }
        mn(e, t) {
          const n = new Yc();
          for (const r of Di(e)) {
            const e = t.data.field(r.fieldPath);
            if (null == e) return null;
            const i = n.He(r.kind);
            zc.Ve._e(e, i);
          }
          return n.Qe();
        }
        dn(e) {
          const t = new Yc();
          return zc.Ve._e(e, t.He(0)), t.Qe();
        }
        gn(e, t) {
          const n = new Yc();
          return (
            zc.Ve._e(
              ds(this.databaseId, t),
              n.He(
                (function (e) {
                  const t = Di(e);
                  return 0 === t.length ? 0 : t[t.length - 1].kind;
                })(e)
              )
            ),
            n.Qe()
          );
        }
        ln(e, t, n) {
          if (null === n) return [];
          let r = [];
          r.push(new Yc());
          let i = 0;
          for (const o of Di(e)) {
            const e = n[i++];
            for (const n of r)
              if (this.yn(t, o.fieldPath) && gs(e)) r = this.pn(r, o, e);
              else {
                const t = n.He(o.kind);
                zc.Ve._e(e, t);
              }
          }
          return this.In(r);
        }
        hn(e, t, n) {
          return this.ln(e, t, n.position);
        }
        In(e) {
          const t = [];
          for (let n = 0; n < e.length; ++n) t[n] = e[n].Qe();
          return t;
        }
        pn(e, t, n) {
          const r = [...e],
            i = [];
          for (const o of n.arrayValue.values || [])
            for (const e of r) {
              const n = new Yc();
              n.seed(e.Qe()), zc.Ve._e(o, n.He(t.kind)), i.push(n);
            }
          return i;
        }
        yn(e, t) {
          return !!e.filters.find(e => e instanceof Ds && e.field.isEqual(t) && ('in' === e.op || 'not-in' === e.op));
        }
        getFieldIndexes(e, t) {
          const n = ml(e),
            r = vl(e);
          return (t ? n.j('collectionGroupIndex', IDBKeyRange.bound(t, t)) : n.j()).next(e => {
            const t = [];
            return zi
              .forEach(e, e =>
                r.get([e.indexId, this.uid]).next(n => {
                  t.push(
                    (function (e, t) {
                      const n = t ? new ji(t.sequenceNumber, new Ui(Nc(t.readTime), new Ni(co(t.documentKey)), t.largestBatchId)) : ji.empty(),
                        r = e.fields.map(([e, t]) => new Li(Oi.fromServerFormat(e), t));
                      return new Ri(e.indexId, e.collectionGroup, r, n);
                    })(e, n)
                  );
                })
              )
              .next(() => t);
          });
        }
        getNextCollectionGroupToUpdate(e) {
          return this.getFieldIndexes(e).next(e =>
            0 === e.length
              ? null
              : (e.sort((e, t) => {
                  const n = e.indexState.sequenceNumber - t.indexState.sequenceNumber;
                  return 0 !== n ? n : Ii(e.collectionGroup, t.collectionGroup);
                }),
                e[0].collectionGroup)
          );
        }
        updateCollectionGroup(e, t, n) {
          const r = ml(e),
            i = vl(e);
          return this.Tn(e).next(e =>
            r.j('collectionGroupIndex', IDBKeyRange.bound(t, t)).next(t => zi.forEach(t, t => i.put(Fc(t.indexId, this.user, e, n))))
          );
        }
        updateIndexEntries(e, t) {
          const n = new Map();
          return zi.forEach(t, (t, r) => {
            const i = n.get(t.collectionGroup);
            return (i ? zi.resolve(i) : this.getFieldIndexes(e, t.collectionGroup)).next(
              i => (
                n.set(t.collectionGroup, i),
                zi.forEach(i, n =>
                  this.En(e, t, n).next(t => {
                    const i = this.An(r, n);
                    return t.isEqual(i) ? zi.resolve() : this.vn(e, r, n, t, i);
                  })
                )
              )
            );
          });
        }
        Rn(e, t, n, r) {
          return gl(e).put({
            indexId: r.indexId,
            uid: this.uid,
            arrayValue: r.arrayValue,
            directionalValue: r.directionalValue,
            orderedDocumentKey: this.gn(n, t.key),
            documentKey: t.key.path.toArray()
          });
        }
        Pn(e, t, n, r) {
          return gl(e).delete([r.indexId, this.uid, r.arrayValue, r.directionalValue, this.gn(n, t.key), t.key.path.toArray()]);
        }
        En(e, t, n) {
          const r = gl(e);
          let i = new $o(Jc);
          return r
            .X({ index: 'documentKeyIndex', range: IDBKeyRange.only([n.indexId, this.uid, this.gn(n, t)]) }, (e, r) => {
              i = i.add(new Xc(n.indexId, t, r.arrayValue, r.directionalValue));
            })
            .next(() => i);
        }
        An(e, t) {
          let n = new $o(Jc);
          const r = this.mn(t, e);
          if (null == r) return n;
          const i = Pi(t);
          if (null != i) {
            const o = e.data.field(i.fieldPath);
            if (gs(o)) for (const i of o.arrayValue.values || []) n = n.add(new Xc(t.indexId, e.key, this.dn(i), r));
          } else n = n.add(new Xc(t.indexId, e.key, fl, r));
          return n;
        }
        vn(e, t, n, r, i) {
          ti('IndexedDbIndexManager', "Updating index entries for document '%s'", t.key);
          const o = [];
          return (
            (function (e, t, n, r, i) {
              const o = e.getIterator(),
                s = t.getIterator();
              let a = zo(o),
                u = zo(s);
              for (; a || u; ) {
                let e = !1,
                  t = !1;
                if (a && u) {
                  const r = n(a, u);
                  r < 0 ? (t = !0) : r > 0 && (e = !0);
                } else null != a ? (t = !0) : (e = !0);
                e ? (r(u), (u = zo(s))) : t ? (i(a), (a = zo(o))) : ((a = zo(o)), (u = zo(s)));
              }
            })(
              r,
              i,
              Jc,
              r => {
                o.push(this.Rn(e, t, n, r));
              },
              r => {
                o.push(this.Pn(e, t, n, r));
              }
            ),
            zi.waitFor(o)
          );
        }
        Tn(e) {
          let t = 1;
          return vl(e)
            .X({ index: 'sequenceNumberIndex', reverse: !0, range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER]) }, (e, n, r) => {
              r.done(), (t = n.sequenceNumber + 1);
            })
            .next(() => t);
        }
        createRange(e, t, n) {
          n = n.sort((e, t) => Jc(e, t)).filter((e, t, n) => !t || 0 !== Jc(e, n[t - 1]));
          const r = [];
          r.push(e);
          for (const o of n) {
            const n = Jc(o, e),
              i = Jc(o, t);
            if (0 === n) r[0] = e.Je();
            else if (n > 0 && i < 0) r.push(o), r.push(o.Je());
            else if (i > 0) break;
          }
          r.push(t);
          const i = [];
          for (let o = 0; o < r.length; o += 2) {
            if (this.bn(r[o], r[o + 1])) return [];
            const e = [r[o].indexId, this.uid, r[o].arrayValue, r[o].directionalValue, fl, []],
              t = [r[o + 1].indexId, this.uid, r[o + 1].arrayValue, r[o + 1].directionalValue, fl, []];
            i.push(IDBKeyRange.bound(e, t));
          }
          return i;
        }
        bn(e, t) {
          return Jc(e, t) > 0;
        }
        getMinOffsetFromCollectionGroup(e, t) {
          return this.getFieldIndexes(e, t).next(yl);
        }
        getMinOffset(e, t) {
          return zi.mapArray(this.cn(t), t => this.an(e, t).next(e => e || oi())).next(yl);
        }
      }
      function pl(e) {
        return Lo(e, 'collectionParents');
      }
      function gl(e) {
        return Lo(e, 'indexEntries');
      }
      function ml(e) {
        return Lo(e, 'indexConfiguration');
      }
      function vl(e) {
        return Lo(e, 'indexState');
      }
      function yl(e) {
        si(0 !== e.length);
        let t = e[0].indexState.offset,
          n = t.largestBatchId;
        for (let r = 1; r < e.length; r++) {
          const i = e[r].indexState.offset;
          Vi(i, t) < 0 && (t = i), n < i.largestBatchId && (n = i.largestBatchId);
        }
        return new Ui(t.readTime, t.documentKey, n);
      }
      /**
       * @license
       * Copyright 2018 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const wl = { didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0 };
      class bl {
        constructor(e, t, n) {
          (this.cacheSizeCollectionThreshold = e), (this.percentileToCollect = t), (this.maximumSequenceNumbersToCollect = n);
        }
        static withCacheSize(e) {
          return new bl(e, bl.DEFAULT_COLLECTION_PERCENTILE, bl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function _l(e, t, n) {
        const r = e.store('mutations'),
          i = e.store('documentMutations'),
          o = [],
          s = IDBKeyRange.only(n.batchId);
        let a = 0;
        const u = r.X({ range: s }, (e, t, n) => (a++, n.delete()));
        o.push(
          u.next(() => {
            si(1 === a);
          })
        );
        const c = [];
        for (const l of n.mutations) {
          const e = fo(t, l.key.path, n.batchId);
          o.push(i.delete(e)), c.push(l.key);
        }
        return zi.waitFor(o).next(() => c);
      }
      function Il(e) {
        if (!e) return 0;
        let t;
        if (e.document) t = e.document;
        else if (e.unknownDocument) t = e.unknownDocument;
        else {
          if (!e.noDocument) throw oi();
          t = e.noDocument;
        }
        return JSON.stringify(t).length;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ (bl.DEFAULT_COLLECTION_PERCENTILE = 10),
        (bl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3),
        (bl.DEFAULT = new bl(41943040, bl.DEFAULT_COLLECTION_PERCENTILE, bl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)),
        (bl.DISABLED = new bl(-1, 0, 0));
      class El {
        constructor(e, t, n, r) {
          (this.userId = e), (this.serializer = t), (this.indexManager = n), (this.referenceDelegate = r), (this.Vn = {});
        }
        static de(e, t, n, r) {
          si('' !== e.uid);
          const i = e.isAuthenticated() ? e.uid : '';
          return new El(i, t, n, r);
        }
        checkEmpty(e) {
          let t = !0;
          const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
          return Tl(e)
            .X({ index: 'userMutationsIndex', range: n }, (e, n, r) => {
              (t = !1), r.done();
            })
            .next(() => t);
        }
        addMutationBatch(e, t, n, r) {
          const i = Al(e),
            o = Tl(e);
          return o.add({}).next(s => {
            si('number' == typeof s);
            const a = new vu(s, t, n, r),
              u = (function (e, t, n) {
                const r = n.baseMutations.map(t => cc(e.fe, t)),
                  i = n.mutations.map(t => cc(e.fe, t));
                return { userId: t, batchId: n.batchId, localWriteTimeMs: n.localWriteTime.toMillis(), baseMutations: r, mutations: i };
              })(this.serializer, this.userId, a),
              c = [];
            let l = new $o((e, t) => Ii(e.canonicalString(), t.canonicalString()));
            for (const e of r) {
              const t = fo(this.userId, e.key.path, s);
              (l = l.add(e.key.path.popLast())), c.push(o.put(u)), c.push(i.put(t, po));
            }
            return (
              l.forEach(t => {
                c.push(this.indexManager.addToCollectionParentIndex(e, t));
              }),
              e.addOnCommittedListener(() => {
                this.Vn[s] = a.keys();
              }),
              zi.waitFor(c).next(() => a)
            );
          });
        }
        lookupMutationBatch(e, t) {
          return Tl(e)
            .get(t)
            .next(e => (e ? (si(e.userId === this.userId), Rc(this.serializer, e)) : null));
        }
        Sn(e, t) {
          return this.Vn[t]
            ? zi.resolve(this.Vn[t])
            : this.lookupMutationBatch(e, t).next(e => {
                if (e) {
                  const n = e.keys();
                  return (this.Vn[t] = n), n;
                }
                return null;
              });
        }
        getNextMutationBatchAfterBatchId(e, t) {
          const n = t + 1,
            r = IDBKeyRange.lowerBound([this.userId, n]);
          let i = null;
          return Tl(e)
            .X({ index: 'userMutationsIndex', range: r }, (e, t, r) => {
              t.userId === this.userId && (si(t.batchId >= n), (i = Rc(this.serializer, t))), r.done();
            })
            .next(() => i);
        }
        getHighestUnacknowledgedBatchId(e) {
          const t = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
          let n = -1;
          return Tl(e)
            .X({ index: 'userMutationsIndex', range: t, reverse: !0 }, (e, t, r) => {
              (n = t.batchId), r.done();
            })
            .next(() => n);
        }
        getAllMutationBatches(e) {
          const t = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
          return Tl(e)
            .j('userMutationsIndex', t)
            .next(e => e.map(e => Rc(this.serializer, e)));
        }
        getAllMutationBatchesAffectingDocumentKey(e, t) {
          const n = ho(this.userId, t.path),
            r = IDBKeyRange.lowerBound(n),
            i = [];
          return Al(e)
            .X({ range: r }, (n, r, o) => {
              const [s, a, u] = n,
                c = co(a);
              if (s === this.userId && t.path.isEqual(c))
                return Tl(e)
                  .get(u)
                  .next(e => {
                    if (!e) throw oi();
                    si(e.userId === this.userId), i.push(Rc(this.serializer, e));
                  });
              o.done();
            })
            .next(() => i);
        }
        getAllMutationBatchesAffectingDocumentKeys(e, t) {
          let n = new $o(Ii);
          const r = [];
          return (
            t.forEach(t => {
              const i = ho(this.userId, t.path),
                o = IDBKeyRange.lowerBound(i),
                s = Al(e).X({ range: o }, (e, r, i) => {
                  const [o, s, a] = e,
                    u = co(s);
                  o === this.userId && t.path.isEqual(u) ? (n = n.add(a)) : i.done();
                });
              r.push(s);
            }),
            zi.waitFor(r).next(() => this.Dn(e, n))
          );
        }
        getAllMutationBatchesAffectingQuery(e, t) {
          const n = t.path,
            r = n.length + 1,
            i = ho(this.userId, n),
            o = IDBKeyRange.lowerBound(i);
          let s = new $o(Ii);
          return Al(e)
            .X({ range: o }, (e, t, i) => {
              const [o, a, u] = e,
                c = co(a);
              o === this.userId && n.isPrefixOf(c) ? c.length === r && (s = s.add(u)) : i.done();
            })
            .next(() => this.Dn(e, s));
        }
        Dn(e, t) {
          const n = [],
            r = [];
          return (
            t.forEach(t => {
              r.push(
                Tl(e)
                  .get(t)
                  .next(e => {
                    if (null === e) throw oi();
                    si(e.userId === this.userId), n.push(Rc(this.serializer, e));
                  })
              );
            }),
            zi.waitFor(r).next(() => n)
          );
        }
        removeMutationBatch(e, t) {
          return _l(e.ht, this.userId, t).next(
            n => (
              e.addOnCommittedListener(() => {
                this.Cn(t.batchId);
              }),
              zi.forEach(n, t => this.referenceDelegate.markPotentiallyOrphaned(e, t))
            )
          );
        }
        Cn(e) {
          delete this.Vn[e];
        }
        performConsistencyCheck(e) {
          return this.checkEmpty(e).next(t => {
            if (!t) return zi.resolve();
            const n = IDBKeyRange.lowerBound([this.userId]),
              r = [];
            return Al(e)
              .X({ range: n }, (e, t, n) => {
                if (e[0] === this.userId) {
                  const t = co(e[1]);
                  r.push(t);
                } else n.done();
              })
              .next(() => {
                si(0 === r.length);
              });
          });
        }
        containsKey(e, t) {
          return Sl(e, this.userId, t);
        }
        xn(e) {
          return xl(e)
            .get(this.userId)
            .next(e => e || { userId: this.userId, lastAcknowledgedBatchId: -1, lastStreamToken: '' });
        }
      }
      function Sl(e, t, n) {
        const r = ho(t, n.path),
          i = r[1],
          o = IDBKeyRange.lowerBound(r);
        let s = !1;
        return Al(e)
          .X({ range: o, Y: !0 }, (e, n, r) => {
            const [o, a, u] = e;
            o === t && a === i && (s = !0), r.done();
          })
          .next(() => s);
      }
      function Tl(e) {
        return Lo(e, 'mutations');
      }
      function Al(e) {
        return Lo(e, 'documentMutations');
      }
      function xl(e) {
        return Lo(e, 'mutationQueues');
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Cl {
        constructor(e) {
          this.Nn = e;
        }
        next() {
          return (this.Nn += 2), this.Nn;
        }
        static kn() {
          return new Cl(0);
        }
        static Mn() {
          return new Cl(-1);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class kl {
        constructor(e, t) {
          (this.referenceDelegate = e), (this.serializer = t);
        }
        allocateTargetId(e) {
          return this.$n(e).next(t => {
            const n = new Cl(t.highestTargetId);
            return (t.highestTargetId = n.next()), this.On(e, t).next(() => t.highestTargetId);
          });
        }
        getLastRemoteSnapshotVersion(e) {
          return this.$n(e).next(e => Ai.fromTimestamp(new Ti(e.lastRemoteSnapshotVersion.seconds, e.lastRemoteSnapshotVersion.nanoseconds)));
        }
        getHighestSequenceNumber(e) {
          return this.$n(e).next(e => e.highestListenSequenceNumber);
        }
        setTargetsMetadata(e, t, n) {
          return this.$n(e).next(
            r => (
              (r.highestListenSequenceNumber = t),
              n && (r.lastRemoteSnapshotVersion = n.toTimestamp()),
              t > r.highestListenSequenceNumber && (r.highestListenSequenceNumber = t),
              this.On(e, r)
            )
          );
        }
        addTargetData(e, t) {
          return this.Fn(e, t).next(() => this.$n(e).next(n => ((n.targetCount += 1), this.Bn(t, n), this.On(e, n))));
        }
        updateTargetData(e, t) {
          return this.Fn(e, t);
        }
        removeTargetData(e, t) {
          return this.removeMatchingKeysForTargetId(e, t.targetId)
            .next(() => Ol(e).delete(t.targetId))
            .next(() => this.$n(e))
            .next(t => (si(t.targetCount > 0), (t.targetCount -= 1), this.On(e, t)));
        }
        removeTargets(e, t, n) {
          let r = 0;
          const i = [];
          return Ol(e)
            .X((o, s) => {
              const a = Pc(s);
              a.sequenceNumber <= t && null === n.get(a.targetId) && (r++, i.push(this.removeTargetData(e, a)));
            })
            .next(() => zi.waitFor(i))
            .next(() => r);
        }
        forEachTarget(e, t) {
          return Ol(e).X((e, n) => {
            const r = Pc(n);
            t(r);
          });
        }
        $n(e) {
          return Nl(e)
            .get('targetGlobalKey')
            .next(e => (si(null !== e), e));
        }
        On(e, t) {
          return Nl(e).put('targetGlobalKey', t);
        }
        Fn(e, t) {
          return Ol(e).put(Dc(this.serializer, t));
        }
        Bn(e, t) {
          let n = !1;
          return (
            e.targetId > t.highestTargetId && ((t.highestTargetId = e.targetId), (n = !0)),
            e.sequenceNumber > t.highestListenSequenceNumber && ((t.highestListenSequenceNumber = e.sequenceNumber), (n = !0)),
            n
          );
        }
        getTargetCount(e) {
          return this.$n(e).next(e => e.targetCount);
        }
        getTargetData(e, t) {
          const n = ea(t),
            r = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
          let i = null;
          return Ol(e)
            .X({ range: r, index: 'queryTargetsIndex' }, (e, n, r) => {
              const o = Pc(n);
              ta(t, o.target) && ((i = o), r.done());
            })
            .next(() => i);
        }
        addMatchingKeys(e, t, n) {
          const r = [],
            i = Rl(e);
          return (
            t.forEach(t => {
              const o = so(t.path);
              r.push(i.put({ targetId: n, path: o })), r.push(this.referenceDelegate.addReference(e, n, t));
            }),
            zi.waitFor(r)
          );
        }
        removeMatchingKeys(e, t, n) {
          const r = Rl(e);
          return zi.forEach(t, t => {
            const i = so(t.path);
            return zi.waitFor([r.delete([n, i]), this.referenceDelegate.removeReference(e, n, t)]);
          });
        }
        removeMatchingKeysForTargetId(e, t) {
          const n = Rl(e),
            r = IDBKeyRange.bound([t], [t + 1], !1, !0);
          return n.delete(r);
        }
        getMatchingKeysForTargetId(e, t) {
          const n = IDBKeyRange.bound([t], [t + 1], !1, !0),
            r = Rl(e);
          let i = La();
          return r
            .X({ range: n, Y: !0 }, (e, t, n) => {
              const r = co(e[1]),
                o = new Ni(r);
              i = i.add(o);
            })
            .next(() => i);
        }
        containsKey(e, t) {
          const n = so(t.path),
            r = IDBKeyRange.bound([n], [Si(n)], !1, !0);
          let i = 0;
          return Rl(e)
            .X({ index: 'documentTargetsIndex', Y: !0, range: r }, ([e, t], n, r) => {
              0 !== e && (i++, r.done());
            })
            .next(() => i > 0);
        }
        le(e, t) {
          return Ol(e)
            .get(t)
            .next(e => (e ? Pc(e) : null));
        }
      }
      function Ol(e) {
        return Lo(e, 'targets');
      }
      function Nl(e) {
        return Lo(e, 'targetGlobal');
      }
      function Rl(e) {
        return Lo(e, 'targetDocuments');
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Pl([e, t], [n, r]) {
        const i = Ii(e, n);
        return 0 === i ? Ii(t, r) : i;
      }
      class Dl {
        constructor(e) {
          (this.Ln = e), (this.buffer = new $o(Pl)), (this.qn = 0);
        }
        Un() {
          return ++this.qn;
        }
        Kn(e) {
          const t = [e, this.Un()];
          if (this.buffer.size < this.Ln) this.buffer = this.buffer.add(t);
          else {
            const e = this.buffer.last();
            Pl(t, e) < 0 && (this.buffer = this.buffer.delete(e).add(t));
          }
        }
        get maxValue() {
          return this.buffer.last()[0];
        }
      }
      class Ll {
        constructor(e, t, n) {
          (this.garbageCollector = e), (this.asyncQueue = t), (this.localStore = n), (this.Gn = null);
        }
        start() {
          -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Qn(6e4);
        }
        stop() {
          this.Gn && (this.Gn.cancel(), (this.Gn = null));
        }
        get started() {
          return null !== this.Gn;
        }
        Qn(e) {
          ti('LruGarbageCollector', `Garbage collection scheduled in ${e}ms`),
            (this.Gn = this.asyncQueue.enqueueAfterDelay('lru_garbage_collection', e, async () => {
              this.Gn = null;
              try {
                await this.localStore.collectGarbage(this.garbageCollector);
              } catch (e) {
                Qi(e) ? ti('LruGarbageCollector', 'Ignoring IndexedDB error during garbage collection: ', e) : await qi(e);
              }
              await this.Qn(3e5);
            }));
        }
      }
      class jl {
        constructor(e, t) {
          (this.jn = e), (this.params = t);
        }
        calculateTargetCount(e, t) {
          return this.jn.zn(e).next(e => Math.floor((t / 100) * e));
        }
        nthSequenceNumber(e, t) {
          if (0 === t) return zi.resolve(no.ct);
          const n = new Dl(t);
          return this.jn
            .forEachTarget(e, e => n.Kn(e.sequenceNumber))
            .next(() => this.jn.Wn(e, e => n.Kn(e)))
            .next(() => n.maxValue);
        }
        removeTargets(e, t, n) {
          return this.jn.removeTargets(e, t, n);
        }
        removeOrphanedDocuments(e, t) {
          return this.jn.removeOrphanedDocuments(e, t);
        }
        collect(e, t) {
          return -1 === this.params.cacheSizeCollectionThreshold
            ? (ti('LruGarbageCollector', 'Garbage collection skipped; disabled'), zi.resolve(wl))
            : this.getCacheSize(e).next(n =>
                n < this.params.cacheSizeCollectionThreshold
                  ? (ti(
                      'LruGarbageCollector',
                      `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`
                    ),
                    wl)
                  : this.Hn(e, t)
              );
        }
        getCacheSize(e) {
          return this.jn.getCacheSize(e);
        }
        Hn(e, t) {
          let n, r, i, o, s, u, c;
          const l = Date.now();
          return this.calculateTargetCount(e, this.params.percentileToCollect)
            .next(
              t => (
                t > this.params.maximumSequenceNumbersToCollect
                  ? (ti(
                      'LruGarbageCollector',
                      `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${t}`
                    ),
                    (r = this.params.maximumSequenceNumbersToCollect))
                  : (r = t),
                (o = Date.now()),
                this.nthSequenceNumber(e, r)
              )
            )
            .next(r => ((n = r), (s = Date.now()), this.removeTargets(e, n, t)))
            .next(t => ((i = t), (u = Date.now()), this.removeOrphanedDocuments(e, n)))
            .next(
              e => (
                (c = Date.now()),
                Zr() <= a['in'].DEBUG &&
                  ti(
                    'LruGarbageCollector',
                    `LRU Garbage Collection\n\tCounted targets in ${o - l}ms\n\tDetermined least recently used ${r} in ` +
                      (s - o) +
                      'ms\n' +
                      `\tRemoved ${i} targets in ` +
                      (u - s) +
                      'ms\n' +
                      `\tRemoved ${e} documents in ` +
                      (c - u) +
                      'ms\n' +
                      `Total Duration: ${c - l}ms`
                  ),
                zi.resolve({ didRun: !0, sequenceNumbersCollected: r, targetsRemoved: i, documentsRemoved: e })
              )
            );
        }
      }
      function Ml(e, t) {
        return new jl(e, t);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Fl {
        constructor(e, t) {
          (this.db = e), (this.garbageCollector = Ml(this, t));
        }
        zn(e) {
          const t = this.Jn(e);
          return this.db
            .getTargetCache()
            .getTargetCount(e)
            .next(e => t.next(t => e + t));
        }
        Jn(e) {
          let t = 0;
          return this.Wn(e, e => {
            t++;
          }).next(() => t);
        }
        forEachTarget(e, t) {
          return this.db.getTargetCache().forEachTarget(e, t);
        }
        Wn(e, t) {
          return this.Yn(e, (e, n) => t(n));
        }
        addReference(e, t, n) {
          return Ul(e, n);
        }
        removeReference(e, t, n) {
          return Ul(e, n);
        }
        removeTargets(e, t, n) {
          return this.db.getTargetCache().removeTargets(e, t, n);
        }
        markPotentiallyOrphaned(e, t) {
          return Ul(e, t);
        }
        Xn(e, t) {
          return (function (e, t) {
            let n = !1;
            return xl(e)
              .Z(r => Sl(e, r, t).next(e => (e && (n = !0), zi.resolve(!e))))
              .next(() => n);
          })(e, t);
        }
        removeOrphanedDocuments(e, t) {
          const n = this.db.getRemoteDocumentCache().newChangeBuffer(),
            r = [];
          let i = 0;
          return this.Yn(e, (o, s) => {
            if (s <= t) {
              const t = this.Xn(e, o).next(t => {
                if (!t) return i++, n.getEntry(e, o).next(() => (n.removeEntry(o, Ai.min()), Rl(e).delete([0, so(o.path)])));
              });
              r.push(t);
            }
          })
            .next(() => zi.waitFor(r))
            .next(() => n.apply(e))
            .next(() => i);
        }
        removeTarget(e, t) {
          const n = t.withSequenceNumber(e.currentSequenceNumber);
          return this.db.getTargetCache().updateTargetData(e, n);
        }
        updateLimboDocument(e, t) {
          return Ul(e, t);
        }
        Yn(e, t) {
          const n = Rl(e);
          let r,
            i = no.ct;
          return n
            .X({ index: 'documentTargetsIndex' }, ([e, n], { path: o, sequenceNumber: s }) => {
              0 === e ? (i !== no.ct && t(new Ni(co(r)), i), (i = s), (r = o)) : (i = no.ct);
            })
            .next(() => {
              i !== no.ct && t(new Ni(co(r)), i);
            });
        }
        getCacheSize(e) {
          return this.db.getRemoteDocumentCache().getSize(e);
        }
      }
      function Ul(e, t) {
        return Rl(e).put(
          (function (e, t) {
            return { targetId: 0, path: so(e.path), sequenceNumber: t };
          })(t, e.currentSequenceNumber)
        );
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Vl {
        constructor() {
          (this.changes = new Sa(
            e => e.toString(),
            (e, t) => e.isEqual(t)
          )),
            (this.changesApplied = !1);
        }
        addEntry(e) {
          this.assertNotApplied(), this.changes.set(e.key, e);
        }
        removeEntry(e, t) {
          this.assertNotApplied(), this.changes.set(e, xs.newInvalidDocument(e).setReadTime(t));
        }
        getEntry(e, t) {
          this.assertNotApplied();
          const n = this.changes.get(t);
          return void 0 !== n ? zi.resolve(n) : this.getFromCache(e, t);
        }
        getEntries(e, t) {
          return this.getAllFromCache(e, t);
        }
        apply(e) {
          return this.assertNotApplied(), (this.changesApplied = !0), this.applyChanges(e);
        }
        assertNotApplied() {}
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Bl {
        constructor(e) {
          this.serializer = e;
        }
        setIndexManager(e) {
          this.indexManager = e;
        }
        addEntry(e, t, n) {
          return Gl(e).put(n);
        }
        removeEntry(e, t, n) {
          return Gl(e).delete(
            (function (e, t) {
              const n = e.path.toArray();
              return [n.slice(0, n.length - 2), n[n.length - 2], kc(t), n[n.length - 1]];
            })(t, n)
          );
        }
        updateMetadata(e, t) {
          return this.getMetadata(e).next(n => ((n.byteSize += t), this.Zn(e, n)));
        }
        getEntry(e, t) {
          let n = xs.newInvalidDocument(t);
          return Gl(e)
            .X({ index: 'documentKeyIndex', range: IDBKeyRange.only(Wl(t)) }, (e, r) => {
              n = this.ts(t, r);
            })
            .next(() => n);
        }
        es(e, t) {
          let n = { size: 0, document: xs.newInvalidDocument(t) };
          return Gl(e)
            .X({ index: 'documentKeyIndex', range: IDBKeyRange.only(Wl(t)) }, (e, r) => {
              n = { document: this.ts(t, r), size: Il(r) };
            })
            .next(() => n);
        }
        getEntries(e, t) {
          let n = Aa();
          return this.ns(e, t, (e, t) => {
            const r = this.ts(e, t);
            n = n.insert(e, r);
          }).next(() => n);
        }
        ss(e, t) {
          let n = Aa(),
            r = new Uo(Ni.comparator);
          return this.ns(e, t, (e, t) => {
            const i = this.ts(e, t);
            (n = n.insert(e, i)), (r = r.insert(e, Il(t)));
          }).next(() => ({ documents: n, rs: r }));
        }
        ns(e, t, n) {
          if (t.isEmpty()) return zi.resolve();
          let r = new $o(Kl);
          t.forEach(e => (r = r.add(e)));
          const i = IDBKeyRange.bound(Wl(r.first()), Wl(r.last())),
            o = r.getIterator();
          let s = o.getNext();
          return Gl(e)
            .X({ index: 'documentKeyIndex', range: i }, (e, t, r) => {
              const i = Ni.fromSegments([...t.prefixPath, t.collectionGroup, t.documentId]);
              for (; s && Kl(s, i) < 0; ) n(s, null), (s = o.getNext());
              s && s.isEqual(i) && (n(s, t), (s = o.hasNext() ? o.getNext() : null)), s ? r.G(Wl(s)) : r.done();
            })
            .next(() => {
              for (; s; ) n(s, null), (s = o.hasNext() ? o.getNext() : null);
            });
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          const i = t.path,
            o = [i.popLast().toArray(), i.lastSegment(), kc(n.readTime), n.documentKey.path.isEmpty() ? '' : n.documentKey.path.lastSegment()],
            s = [i.popLast().toArray(), i.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ''];
          return Gl(e)
            .j(IDBKeyRange.bound(o, s, !0))
            .next(e => {
              let n = Aa();
              for (const i of e) {
                const e = this.ts(Ni.fromSegments(i.prefixPath.concat(i.collectionGroup, i.documentId)), i);
                e.isFoundDocument() && (ba(t, e) || r.has(e.key)) && (n = n.insert(e.key, e));
              }
              return n;
            });
        }
        getAllFromCollectionGroup(e, t, n, r) {
          let i = Aa();
          const o = Hl(t, n),
            s = Hl(t, Ui.max());
          return Gl(e)
            .X({ index: 'collectionGroupIndex', range: IDBKeyRange.bound(o, s, !0) }, (e, t, n) => {
              const o = this.ts(Ni.fromSegments(t.prefixPath.concat(t.collectionGroup, t.documentId)), t);
              (i = i.insert(o.key, o)), i.size === r && n.done();
            })
            .next(() => i);
        }
        newChangeBuffer(e) {
          return new ql(this, !!e && e.trackRemovals);
        }
        getSize(e) {
          return this.getMetadata(e).next(e => e.byteSize);
        }
        getMetadata(e) {
          return zl(e)
            .get('remoteDocumentGlobalKey')
            .next(e => (si(!!e), e));
        }
        Zn(e, t) {
          return zl(e).put('remoteDocumentGlobalKey', t);
        }
        ts(e, t) {
          if (t) {
            const e = xc(this.serializer, t);
            if (!e.isNoDocument() || !e.version.isEqual(Ai.min())) return e;
          }
          return xs.newInvalidDocument(e);
        }
      }
      function $l(e) {
        return new Bl(e);
      }
      class ql extends Vl {
        constructor(e, t) {
          super(),
            (this.os = e),
            (this.trackRemovals = t),
            (this.us = new Sa(
              e => e.toString(),
              (e, t) => e.isEqual(t)
            ));
        }
        applyChanges(e) {
          const t = [];
          let n = 0,
            r = new $o((e, t) => Ii(e.canonicalString(), t.canonicalString()));
          return (
            this.changes.forEach((i, o) => {
              const s = this.us.get(i);
              if ((t.push(this.os.removeEntry(e, i, s.readTime)), o.isValidDocument())) {
                const a = Cc(this.os.serializer, o);
                r = r.add(i.path.popLast());
                const u = Il(a);
                (n += u - s.size), t.push(this.os.addEntry(e, i, a));
              } else if (((n -= s.size), this.trackRemovals)) {
                const n = Cc(this.os.serializer, o.convertToNoDocument(Ai.min()));
                t.push(this.os.addEntry(e, i, n));
              }
            }),
            r.forEach(n => {
              t.push(this.os.indexManager.addToCollectionParentIndex(e, n));
            }),
            t.push(this.os.updateMetadata(e, n)),
            zi.waitFor(t)
          );
        }
        getFromCache(e, t) {
          return this.os.es(e, t).next(e => (this.us.set(t, { size: e.size, readTime: e.document.readTime }), e.document));
        }
        getAllFromCache(e, t) {
          return this.os.ss(e, t).next(
            ({ documents: e, rs: t }) => (
              t.forEach((t, n) => {
                this.us.set(t, { size: n, readTime: e.get(t).readTime });
              }),
              e
            )
          );
        }
      }
      function zl(e) {
        return Lo(e, 'remoteDocumentGlobal');
      }
      function Gl(e) {
        return Lo(e, 'remoteDocumentsV14');
      }
      function Wl(e) {
        const t = e.path.toArray();
        return [t.slice(0, t.length - 2), t[t.length - 2], t[t.length - 1]];
      }
      function Hl(e, t) {
        const n = t.documentKey.path.toArray();
        return [e, kc(t.readTime), n.slice(0, n.length - 2), n.length > 0 ? n[n.length - 1] : ''];
      }
      function Kl(e, t) {
        const n = e.path.toArray(),
          r = t.path.toArray();
        let i = 0;
        for (let o = 0; o < n.length - 2 && o < r.length - 2; ++o) if (((i = Ii(n[o], r[o])), i)) return i;
        return (i = Ii(n.length, r.length)), i || ((i = Ii(n[n.length - 2], r[r.length - 2])), i || Ii(n[n.length - 1], r[r.length - 1]));
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * @license
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class Ql {
        constructor(e, t) {
          (this.overlayedDocument = e), (this.mutatedFields = t);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Yl {
        constructor(e, t, n, r) {
          (this.remoteDocumentCache = e), (this.mutationQueue = t), (this.documentOverlayCache = n), (this.indexManager = r);
        }
        getDocument(e, t) {
          let n = null;
          return this.documentOverlayCache
            .getOverlay(e, t)
            .next(r => ((n = r), this.remoteDocumentCache.getEntry(e, t)))
            .next(e => (null !== n && au(n.mutation, e, Go.empty(), Ti.now()), e));
        }
        getDocuments(e, t) {
          return this.remoteDocumentCache.getEntries(e, t).next(t => this.getLocalViewOfDocuments(e, t, La()).next(() => t));
        }
        getLocalViewOfDocuments(e, t, n = La()) {
          const r = Oa();
          return this.populateOverlays(e, r, t).next(() =>
            this.computeViews(e, t, r, n).next(e => {
              let t = Ca();
              return (
                e.forEach((e, n) => {
                  t = t.insert(e, n.overlayedDocument);
                }),
                t
              );
            })
          );
        }
        getOverlayedDocuments(e, t) {
          const n = Oa();
          return this.populateOverlays(e, n, t).next(() => this.computeViews(e, t, n, La()));
        }
        populateOverlays(e, t, n) {
          const r = [];
          return (
            n.forEach(e => {
              t.has(e) || r.push(e);
            }),
            this.documentOverlayCache.getOverlays(e, r).next(e => {
              e.forEach((e, n) => {
                t.set(e, n);
              });
            })
          );
        }
        computeViews(e, t, n, r) {
          let i = Aa();
          const o = Ra(),
            s = Ra();
          return (
            t.forEach((e, t) => {
              const s = n.get(t.key);
              r.has(t.key) && (void 0 === s || s.mutation instanceof hu)
                ? (i = i.insert(t.key, t))
                : void 0 !== s
                  ? (o.set(t.key, s.mutation.getFieldMask()), au(s.mutation, t, s.mutation.getFieldMask(), Ti.now()))
                  : o.set(t.key, Go.empty());
            }),
            this.recalculateAndSaveOverlays(e, i).next(
              e => (
                e.forEach((e, t) => o.set(e, t)),
                t.forEach((e, t) => {
                  var n;
                  return s.set(e, new Ql(t, null !== (n = o.get(e)) && void 0 !== n ? n : null));
                }),
                s
              )
            )
          );
        }
        recalculateAndSaveOverlays(e, t) {
          const n = Ra();
          let r = new Uo((e, t) => e - t),
            i = La();
          return this.mutationQueue
            .getAllMutationBatchesAffectingDocumentKeys(e, t)
            .next(e => {
              for (const i of e)
                i.keys().forEach(e => {
                  const o = t.get(e);
                  if (null === o) return;
                  let s = n.get(e) || Go.empty();
                  (s = i.applyToLocalView(o, s)), n.set(e, s);
                  const a = (r.get(i.batchId) || La()).add(e);
                  r = r.insert(i.batchId, a);
                });
            })
            .next(() => {
              const o = [],
                s = r.getReverseIterator();
              for (; s.hasNext(); ) {
                const r = s.getNext(),
                  a = r.key,
                  u = r.value,
                  c = Na();
                u.forEach(e => {
                  if (!i.has(e)) {
                    const r = ou(t.get(e), n.get(e));
                    null !== r && c.set(e, r), (i = i.add(e));
                  }
                }),
                  o.push(this.documentOverlayCache.saveOverlays(e, a, c));
              }
              return zi.waitFor(o);
            })
            .next(() => n);
        }
        recalculateAndSaveOverlaysForDocumentKeys(e, t) {
          return this.remoteDocumentCache.getEntries(e, t).next(t => this.recalculateAndSaveOverlays(e, t));
        }
        getDocumentsMatchingQuery(e, t, n) {
          return (function (e) {
            return Ni.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length;
          })(t)
            ? this.getDocumentsMatchingDocumentQuery(e, t.path)
            : fa(t)
              ? this.getDocumentsMatchingCollectionGroupQuery(e, t, n)
              : this.getDocumentsMatchingCollectionQuery(e, t, n);
        }
        getNextDocuments(e, t, n, r) {
          return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, n, r).next(i => {
            const o = r - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, n.largestBatchId, r - i.size) : zi.resolve(Oa());
            let s = -1,
              a = i;
            return o.next(t =>
              zi
                .forEach(
                  t,
                  (t, n) => (
                    s < n.largestBatchId && (s = n.largestBatchId),
                    i.get(t)
                      ? zi.resolve()
                      : this.remoteDocumentCache.getEntry(e, t).next(e => {
                          a = a.insert(t, e);
                        })
                  )
                )
                .next(() => this.populateOverlays(e, t, i))
                .next(() => this.computeViews(e, a, t, La()))
                .next(e => ({ batchId: s, changes: ka(e) }))
            );
          });
        }
        getDocumentsMatchingDocumentQuery(e, t) {
          return this.getDocument(e, new Ni(t)).next(e => {
            let t = Ca();
            return e.isFoundDocument() && (t = t.insert(e.key, e)), t;
          });
        }
        getDocumentsMatchingCollectionGroupQuery(e, t, n) {
          const r = t.collectionGroup;
          let i = Ca();
          return this.indexManager.getCollectionParents(e, r).next(o =>
            zi
              .forEach(o, o => {
                const s = (function (e, t) {
                  return new sa(t, null, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt);
                })(t, o.child(r));
                return this.getDocumentsMatchingCollectionQuery(e, s, n).next(e => {
                  e.forEach((e, t) => {
                    i = i.insert(e, t);
                  });
                });
              })
              .next(() => i)
          );
        }
        getDocumentsMatchingCollectionQuery(e, t, n) {
          let r;
          return this.documentOverlayCache
            .getOverlaysForCollection(e, t.path, n.largestBatchId)
            .next(i => ((r = i), this.remoteDocumentCache.getDocumentsMatchingQuery(e, t, n, r)))
            .next(e => {
              r.forEach((t, n) => {
                const r = n.getKey();
                null === e.get(r) && (e = e.insert(r, xs.newInvalidDocument(r)));
              });
              let n = Ca();
              return (
                e.forEach((e, i) => {
                  const o = r.get(e);
                  void 0 !== o && au(o.mutation, i, Go.empty(), Ti.now()), ba(t, i) && (n = n.insert(e, i));
                }),
                n
              );
            });
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Xl {
        constructor(e) {
          (this.serializer = e), (this.cs = new Map()), (this.hs = new Map());
        }
        getBundleMetadata(e, t) {
          return zi.resolve(this.cs.get(t));
        }
        saveBundleMetadata(e, t) {
          var n;
          return this.cs.set(t.id, { id: (n = t).id, version: n.version, createTime: Yu(n.createTime) }), zi.resolve();
        }
        getNamedQuery(e, t) {
          return zi.resolve(this.hs.get(t));
        }
        saveNamedQuery(e, t) {
          return (
            this.hs.set(
              t.name,
              (function (e) {
                return { name: e.name, query: Lc(e.bundledQuery), readTime: Yu(e.readTime) };
              })(t)
            ),
            zi.resolve()
          );
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Jl {
        constructor() {
          (this.overlays = new Uo(Ni.comparator)), (this.ls = new Map());
        }
        getOverlay(e, t) {
          return zi.resolve(this.overlays.get(t));
        }
        getOverlays(e, t) {
          const n = Oa();
          return zi
            .forEach(t, t =>
              this.getOverlay(e, t).next(e => {
                null !== e && n.set(t, e);
              })
            )
            .next(() => n);
        }
        saveOverlays(e, t, n) {
          return (
            n.forEach((n, r) => {
              this.we(e, t, r);
            }),
            zi.resolve()
          );
        }
        removeOverlaysForBatchId(e, t, n) {
          const r = this.ls.get(n);
          return void 0 !== r && (r.forEach(e => (this.overlays = this.overlays.remove(e))), this.ls.delete(n)), zi.resolve();
        }
        getOverlaysForCollection(e, t, n) {
          const r = Oa(),
            i = t.length + 1,
            o = new Ni(t.child('')),
            s = this.overlays.getIteratorFrom(o);
          for (; s.hasNext(); ) {
            const e = s.getNext().value,
              o = e.getKey();
            if (!t.isPrefixOf(o.path)) break;
            o.path.length === i && e.largestBatchId > n && r.set(e.getKey(), e);
          }
          return zi.resolve(r);
        }
        getOverlaysForCollectionGroup(e, t, n, r) {
          let i = new Uo((e, t) => e - t);
          const o = this.overlays.getIterator();
          for (; o.hasNext(); ) {
            const e = o.getNext().value;
            if (e.getKey().getCollectionGroup() === t && e.largestBatchId > n) {
              let t = i.get(e.largestBatchId);
              null === t && ((t = Oa()), (i = i.insert(e.largestBatchId, t))), t.set(e.getKey(), e);
            }
          }
          const s = Oa(),
            a = i.getIterator();
          for (; a.hasNext(); ) if ((a.getNext().value.forEach((e, t) => s.set(e, t)), s.size() >= r)) break;
          return zi.resolve(s);
        }
        we(e, t, n) {
          const r = this.overlays.get(n.key);
          if (null !== r) {
            const e = this.ls.get(r.largestBatchId).delete(n.key);
            this.ls.set(r.largestBatchId, e);
          }
          this.overlays = this.overlays.insert(n.key, new wu(t, n));
          let i = this.ls.get(t);
          void 0 === i && ((i = La()), this.ls.set(t, i)), this.ls.set(t, i.add(n.key));
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Zl {
        constructor() {
          (this.fs = new $o(eh.ds)), (this.ws = new $o(eh._s));
        }
        isEmpty() {
          return this.fs.isEmpty();
        }
        addReference(e, t) {
          const n = new eh(e, t);
          (this.fs = this.fs.add(n)), (this.ws = this.ws.add(n));
        }
        gs(e, t) {
          e.forEach(e => this.addReference(e, t));
        }
        removeReference(e, t) {
          this.ys(new eh(e, t));
        }
        ps(e, t) {
          e.forEach(e => this.removeReference(e, t));
        }
        Is(e) {
          const t = new Ni(new Ci([])),
            n = new eh(t, e),
            r = new eh(t, e + 1),
            i = [];
          return (
            this.ws.forEachInRange([n, r], e => {
              this.ys(e), i.push(e.key);
            }),
            i
          );
        }
        Ts() {
          this.fs.forEach(e => this.ys(e));
        }
        ys(e) {
          (this.fs = this.fs.delete(e)), (this.ws = this.ws.delete(e));
        }
        Es(e) {
          const t = new Ni(new Ci([])),
            n = new eh(t, e),
            r = new eh(t, e + 1);
          let i = La();
          return (
            this.ws.forEachInRange([n, r], e => {
              i = i.add(e.key);
            }),
            i
          );
        }
        containsKey(e) {
          const t = new eh(e, 0),
            n = this.fs.firstAfterOrEqual(t);
          return null !== n && e.isEqual(n.key);
        }
      }
      class eh {
        constructor(e, t) {
          (this.key = e), (this.As = t);
        }
        static ds(e, t) {
          return Ni.comparator(e.key, t.key) || Ii(e.As, t.As);
        }
        static _s(e, t) {
          return Ii(e.As, t.As) || Ni.comparator(e.key, t.key);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class th {
        constructor(e, t) {
          (this.indexManager = e), (this.referenceDelegate = t), (this.mutationQueue = []), (this.vs = 1), (this.Rs = new $o(eh.ds));
        }
        checkEmpty(e) {
          return zi.resolve(0 === this.mutationQueue.length);
        }
        addMutationBatch(e, t, n, r) {
          const i = this.vs;
          this.vs++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
          const o = new vu(i, t, n, r);
          this.mutationQueue.push(o);
          for (const s of r) (this.Rs = this.Rs.add(new eh(s.key, i))), this.indexManager.addToCollectionParentIndex(e, s.key.path.popLast());
          return zi.resolve(o);
        }
        lookupMutationBatch(e, t) {
          return zi.resolve(this.Ps(t));
        }
        getNextMutationBatchAfterBatchId(e, t) {
          const n = t + 1,
            r = this.bs(n),
            i = r < 0 ? 0 : r;
          return zi.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);
        }
        getHighestUnacknowledgedBatchId() {
          return zi.resolve(0 === this.mutationQueue.length ? -1 : this.vs - 1);
        }
        getAllMutationBatches(e) {
          return zi.resolve(this.mutationQueue.slice());
        }
        getAllMutationBatchesAffectingDocumentKey(e, t) {
          const n = new eh(t, 0),
            r = new eh(t, Number.POSITIVE_INFINITY),
            i = [];
          return (
            this.Rs.forEachInRange([n, r], e => {
              const t = this.Ps(e.As);
              i.push(t);
            }),
            zi.resolve(i)
          );
        }
        getAllMutationBatchesAffectingDocumentKeys(e, t) {
          let n = new $o(Ii);
          return (
            t.forEach(e => {
              const t = new eh(e, 0),
                r = new eh(e, Number.POSITIVE_INFINITY);
              this.Rs.forEachInRange([t, r], e => {
                n = n.add(e.As);
              });
            }),
            zi.resolve(this.Vs(n))
          );
        }
        getAllMutationBatchesAffectingQuery(e, t) {
          const n = t.path,
            r = n.length + 1;
          let i = n;
          Ni.isDocumentKey(i) || (i = i.child(''));
          const o = new eh(new Ni(i), 0);
          let s = new $o(Ii);
          return (
            this.Rs.forEachWhile(e => {
              const t = e.key.path;
              return !!n.isPrefixOf(t) && (t.length === r && (s = s.add(e.As)), !0);
            }, o),
            zi.resolve(this.Vs(s))
          );
        }
        Vs(e) {
          const t = [];
          return (
            e.forEach(e => {
              const n = this.Ps(e);
              null !== n && t.push(n);
            }),
            t
          );
        }
        removeMutationBatch(e, t) {
          si(0 === this.Ss(t.batchId, 'removed')), this.mutationQueue.shift();
          let n = this.Rs;
          return zi
            .forEach(t.mutations, r => {
              const i = new eh(r.key, t.batchId);
              return (n = n.delete(i)), this.referenceDelegate.markPotentiallyOrphaned(e, r.key);
            })
            .next(() => {
              this.Rs = n;
            });
        }
        Cn(e) {}
        containsKey(e, t) {
          const n = new eh(t, 0),
            r = this.Rs.firstAfterOrEqual(n);
          return zi.resolve(t.isEqual(r && r.key));
        }
        performConsistencyCheck(e) {
          return this.mutationQueue.length, zi.resolve();
        }
        Ss(e, t) {
          return this.bs(e);
        }
        bs(e) {
          return 0 === this.mutationQueue.length ? 0 : e - this.mutationQueue[0].batchId;
        }
        Ps(e) {
          const t = this.bs(e);
          return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t];
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class nh {
        constructor(e) {
          (this.Ds = e), (this.docs = new Uo(Ni.comparator)), (this.size = 0);
        }
        setIndexManager(e) {
          this.indexManager = e;
        }
        addEntry(e, t) {
          const n = t.key,
            r = this.docs.get(n),
            i = r ? r.size : 0,
            o = this.Ds(t);
          return (
            (this.docs = this.docs.insert(n, { document: t.mutableCopy(), size: o })),
            (this.size += o - i),
            this.indexManager.addToCollectionParentIndex(e, n.path.popLast())
          );
        }
        removeEntry(e) {
          const t = this.docs.get(e);
          t && ((this.docs = this.docs.remove(e)), (this.size -= t.size));
        }
        getEntry(e, t) {
          const n = this.docs.get(t);
          return zi.resolve(n ? n.document.mutableCopy() : xs.newInvalidDocument(t));
        }
        getEntries(e, t) {
          let n = Aa();
          return (
            t.forEach(e => {
              const t = this.docs.get(e);
              n = n.insert(e, t ? t.document.mutableCopy() : xs.newInvalidDocument(e));
            }),
            zi.resolve(n)
          );
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          let i = Aa();
          const o = t.path,
            s = new Ni(o.child('')),
            a = this.docs.getIteratorFrom(s);
          for (; a.hasNext(); ) {
            const {
              key: e,
              value: { document: s }
            } = a.getNext();
            if (!o.isPrefixOf(e.path)) break;
            e.path.length > o.length + 1 || Vi(Fi(s), n) <= 0 || ((r.has(s.key) || ba(t, s)) && (i = i.insert(s.key, s.mutableCopy())));
          }
          return zi.resolve(i);
        }
        getAllFromCollectionGroup(e, t, n, r) {
          oi();
        }
        Cs(e, t) {
          return zi.forEach(this.docs, e => t(e));
        }
        newChangeBuffer(e) {
          return new rh(this);
        }
        getSize(e) {
          return zi.resolve(this.size);
        }
      }
      class rh extends Vl {
        constructor(e) {
          super(), (this.os = e);
        }
        applyChanges(e) {
          const t = [];
          return (
            this.changes.forEach((n, r) => {
              r.isValidDocument() ? t.push(this.os.addEntry(e, r)) : this.os.removeEntry(n);
            }),
            zi.waitFor(t)
          );
        }
        getFromCache(e, t) {
          return this.os.getEntry(e, t);
        }
        getAllFromCache(e, t) {
          return this.os.getEntries(e, t);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ih {
        constructor(e) {
          (this.persistence = e),
            (this.xs = new Sa(e => ea(e), ta)),
            (this.lastRemoteSnapshotVersion = Ai.min()),
            (this.highestTargetId = 0),
            (this.Ns = 0),
            (this.ks = new Zl()),
            (this.targetCount = 0),
            (this.Ms = Cl.kn());
        }
        forEachTarget(e, t) {
          return this.xs.forEach((e, n) => t(n)), zi.resolve();
        }
        getLastRemoteSnapshotVersion(e) {
          return zi.resolve(this.lastRemoteSnapshotVersion);
        }
        getHighestSequenceNumber(e) {
          return zi.resolve(this.Ns);
        }
        allocateTargetId(e) {
          return (this.highestTargetId = this.Ms.next()), zi.resolve(this.highestTargetId);
        }
        setTargetsMetadata(e, t, n) {
          return n && (this.lastRemoteSnapshotVersion = n), t > this.Ns && (this.Ns = t), zi.resolve();
        }
        Fn(e) {
          this.xs.set(e.target, e);
          const t = e.targetId;
          t > this.highestTargetId && ((this.Ms = new Cl(t)), (this.highestTargetId = t)), e.sequenceNumber > this.Ns && (this.Ns = e.sequenceNumber);
        }
        addTargetData(e, t) {
          return this.Fn(t), (this.targetCount += 1), zi.resolve();
        }
        updateTargetData(e, t) {
          return this.Fn(t), zi.resolve();
        }
        removeTargetData(e, t) {
          return this.xs.delete(t.target), this.ks.Is(t.targetId), (this.targetCount -= 1), zi.resolve();
        }
        removeTargets(e, t, n) {
          let r = 0;
          const i = [];
          return (
            this.xs.forEach((o, s) => {
              s.sequenceNumber <= t &&
                null === n.get(s.targetId) &&
                (this.xs.delete(o), i.push(this.removeMatchingKeysForTargetId(e, s.targetId)), r++);
            }),
            zi.waitFor(i).next(() => r)
          );
        }
        getTargetCount(e) {
          return zi.resolve(this.targetCount);
        }
        getTargetData(e, t) {
          const n = this.xs.get(t) || null;
          return zi.resolve(n);
        }
        addMatchingKeys(e, t, n) {
          return this.ks.gs(t, n), zi.resolve();
        }
        removeMatchingKeys(e, t, n) {
          this.ks.ps(t, n);
          const r = this.persistence.referenceDelegate,
            i = [];
          return (
            r &&
              t.forEach(t => {
                i.push(r.markPotentiallyOrphaned(e, t));
              }),
            zi.waitFor(i)
          );
        }
        removeMatchingKeysForTargetId(e, t) {
          return this.ks.Is(t), zi.resolve();
        }
        getMatchingKeysForTargetId(e, t) {
          const n = this.ks.Es(t);
          return zi.resolve(n);
        }
        containsKey(e, t) {
          return zi.resolve(this.ks.containsKey(t));
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class oh {
        constructor(e, t) {
          (this.$s = {}),
            (this.overlays = {}),
            (this.Os = new no(0)),
            (this.Fs = !1),
            (this.Fs = !0),
            (this.referenceDelegate = e(this)),
            (this.Bs = new ih(this)),
            (this.indexManager = new ll()),
            (this.remoteDocumentCache = (function (e) {
              return new nh(e);
            })(e => this.referenceDelegate.Ls(e))),
            (this.serializer = new Ac(t)),
            (this.qs = new Xl(this.serializer));
        }
        start() {
          return Promise.resolve();
        }
        shutdown() {
          return (this.Fs = !1), Promise.resolve();
        }
        get started() {
          return this.Fs;
        }
        setDatabaseDeletedListener() {}
        setNetworkEnabled() {}
        getIndexManager(e) {
          return this.indexManager;
        }
        getDocumentOverlayCache(e) {
          let t = this.overlays[e.toKey()];
          return t || ((t = new Jl()), (this.overlays[e.toKey()] = t)), t;
        }
        getMutationQueue(e, t) {
          let n = this.$s[e.toKey()];
          return n || ((n = new th(t, this.referenceDelegate)), (this.$s[e.toKey()] = n)), n;
        }
        getTargetCache() {
          return this.Bs;
        }
        getRemoteDocumentCache() {
          return this.remoteDocumentCache;
        }
        getBundleCache() {
          return this.qs;
        }
        runTransaction(e, t, n) {
          ti('MemoryPersistence', 'Starting transaction:', e);
          const r = new sh(this.Os.next());
          return (
            this.referenceDelegate.Us(),
            n(r)
              .next(e => this.referenceDelegate.Ks(r).next(() => e))
              .toPromise()
              .then(e => (r.raiseOnCommittedEvent(), e))
          );
        }
        Gs(e, t) {
          return zi.or(Object.values(this.$s).map(n => () => n.containsKey(e, t)));
        }
      }
      class sh extends $i {
        constructor(e) {
          super(), (this.currentSequenceNumber = e);
        }
      }
      class ah {
        constructor(e) {
          (this.persistence = e), (this.Qs = new Zl()), (this.js = null);
        }
        static zs(e) {
          return new ah(e);
        }
        get Ws() {
          if (this.js) return this.js;
          throw oi();
        }
        addReference(e, t, n) {
          return this.Qs.addReference(n, t), this.Ws.delete(n.toString()), zi.resolve();
        }
        removeReference(e, t, n) {
          return this.Qs.removeReference(n, t), this.Ws.add(n.toString()), zi.resolve();
        }
        markPotentiallyOrphaned(e, t) {
          return this.Ws.add(t.toString()), zi.resolve();
        }
        removeTarget(e, t) {
          this.Qs.Is(t.targetId).forEach(e => this.Ws.add(e.toString()));
          const n = this.persistence.getTargetCache();
          return n
            .getMatchingKeysForTargetId(e, t.targetId)
            .next(e => {
              e.forEach(e => this.Ws.add(e.toString()));
            })
            .next(() => n.removeTargetData(e, t));
        }
        Us() {
          this.js = new Set();
        }
        Ks(e) {
          const t = this.persistence.getRemoteDocumentCache().newChangeBuffer();
          return zi
            .forEach(this.Ws, n => {
              const r = Ni.fromPath(n);
              return this.Hs(e, r).next(e => {
                e || t.removeEntry(r, Ai.min());
              });
            })
            .next(() => ((this.js = null), t.apply(e)));
        }
        updateLimboDocument(e, t) {
          return this.Hs(e, t).next(e => {
            e ? this.Ws.delete(t.toString()) : this.Ws.add(t.toString());
          });
        }
        Ls(e) {
          return 0;
        }
        Hs(e, t) {
          return zi.or([
            () => zi.resolve(this.Qs.containsKey(t)),
            () => this.persistence.getTargetCache().containsKey(e, t),
            () => this.persistence.Gs(e, t)
          ]);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class uh {
        constructor(e) {
          this.serializer = e;
        }
        O(e, t, n, r) {
          const i = new Gi('createOrUpgrade', t);
          n < 1 &&
            r >= 1 &&
            ((function (e) {
              e.createObjectStore('owner');
            })(e),
            (function (e) {
              e.createObjectStore('mutationQueues', { keyPath: 'userId' }),
                e.createObjectStore('mutations', { keyPath: 'batchId', autoIncrement: !0 }).createIndex('userMutationsIndex', lo, { unique: !0 }),
                e.createObjectStore('documentMutations');
            })(e),
            ch(e),
            (function (e) {
              e.createObjectStore('remoteDocuments');
            })(e));
          let o = zi.resolve();
          return (
            n < 3 &&
              r >= 3 &&
              (0 !== n &&
                ((function (e) {
                  e.deleteObjectStore('targetDocuments'), e.deleteObjectStore('targets'), e.deleteObjectStore('targetGlobal');
                })(e),
                ch(e)),
              (o = o.next(() =>
                (function (e) {
                  const t = e.store('targetGlobal'),
                    n = { highestTargetId: 0, highestListenSequenceNumber: 0, lastRemoteSnapshotVersion: Ai.min().toTimestamp(), targetCount: 0 };
                  return t.put('targetGlobalKey', n);
                })(i)
              ))),
            n < 4 &&
              r >= 4 &&
              (0 !== n &&
                (o = o.next(() =>
                  (function (e, t) {
                    return t
                      .store('mutations')
                      .j()
                      .next(n => {
                        e.deleteObjectStore('mutations'),
                          e
                            .createObjectStore('mutations', { keyPath: 'batchId', autoIncrement: !0 })
                            .createIndex('userMutationsIndex', lo, { unique: !0 });
                        const r = t.store('mutations'),
                          i = n.map(e => r.put(e));
                        return zi.waitFor(i);
                      });
                  })(e, i)
                )),
              (o = o.next(() => {
                !(function (e) {
                  e.createObjectStore('clientMetadata', { keyPath: 'clientId' });
                })(e);
              }))),
            n < 5 && r >= 5 && (o = o.next(() => this.Ys(i))),
            n < 6 &&
              r >= 6 &&
              (o = o.next(
                () => (
                  (function (e) {
                    e.createObjectStore('remoteDocumentGlobal');
                  })(e),
                  this.Xs(i)
                )
              )),
            n < 7 && r >= 7 && (o = o.next(() => this.Zs(i))),
            n < 8 && r >= 8 && (o = o.next(() => this.ti(e, i))),
            n < 9 &&
              r >= 9 &&
              (o = o.next(() => {
                !(function (e) {
                  e.objectStoreNames.contains('remoteDocumentChanges') && e.deleteObjectStore('remoteDocumentChanges');
                })(e);
              })),
            n < 10 && r >= 10 && (o = o.next(() => this.ei(i))),
            n < 11 &&
              r >= 11 &&
              (o = o.next(() => {
                !(function (e) {
                  e.createObjectStore('bundles', { keyPath: 'bundleId' });
                })(e),
                  (function (e) {
                    e.createObjectStore('namedQueries', { keyPath: 'name' });
                  })(e);
              })),
            n < 12 &&
              r >= 12 &&
              (o = o.next(() => {
                !(function (e) {
                  const t = e.createObjectStore('documentOverlays', { keyPath: Ao });
                  t.createIndex('collectionPathOverlayIndex', xo, { unique: !1 }), t.createIndex('collectionGroupOverlayIndex', Co, { unique: !1 });
                })(e);
              })),
            n < 13 &&
              r >= 13 &&
              (o = o
                .next(() =>
                  (function (e) {
                    const t = e.createObjectStore('remoteDocumentsV14', { keyPath: go });
                    t.createIndex('documentKeyIndex', mo), t.createIndex('collectionGroupIndex', vo);
                  })(e)
                )
                .next(() => this.ni(e, i))
                .next(() => e.deleteObjectStore('remoteDocuments'))),
            n < 14 && r >= 14 && (o = o.next(() => this.si(e, i))),
            n < 15 &&
              r >= 15 &&
              (o = o.next(() =>
                (function (e) {
                  e
                    .createObjectStore('indexConfiguration', { keyPath: 'indexId', autoIncrement: !0 })
                    .createIndex('collectionGroupIndex', 'collectionGroup', { unique: !1 }),
                    e.createObjectStore('indexState', { keyPath: Io }).createIndex('sequenceNumberIndex', Eo, { unique: !1 }),
                    e.createObjectStore('indexEntries', { keyPath: So }).createIndex('documentKeyIndex', To, { unique: !1 });
                })(e)
              )),
            o
          );
        }
        Xs(e) {
          let t = 0;
          return e
            .store('remoteDocuments')
            .X((e, n) => {
              t += Il(n);
            })
            .next(() => {
              const n = { byteSize: t };
              return e.store('remoteDocumentGlobal').put('remoteDocumentGlobalKey', n);
            });
        }
        Ys(e) {
          const t = e.store('mutationQueues'),
            n = e.store('mutations');
          return t.j().next(t =>
            zi.forEach(t, t => {
              const r = IDBKeyRange.bound([t.userId, -1], [t.userId, t.lastAcknowledgedBatchId]);
              return n.j('userMutationsIndex', r).next(n =>
                zi.forEach(n, n => {
                  si(n.userId === t.userId);
                  const r = Rc(this.serializer, n);
                  return _l(e, t.userId, r).next(() => {});
                })
              );
            })
          );
        }
        Zs(e) {
          const t = e.store('targetDocuments'),
            n = e.store('remoteDocuments');
          return e
            .store('targetGlobal')
            .get('targetGlobalKey')
            .next(e => {
              const r = [];
              return n
                .X((n, i) => {
                  const o = new Ci(n),
                    s = (function (e) {
                      return [0, so(e)];
                    })(o);
                  r.push(
                    t
                      .get(s)
                      .next(n => (n ? zi.resolve() : (n => t.put({ targetId: 0, path: so(n), sequenceNumber: e.highestListenSequenceNumber }))(o)))
                  );
                })
                .next(() => zi.waitFor(r));
            });
        }
        ti(e, t) {
          e.createObjectStore('collectionParents', { keyPath: _o });
          const n = t.store('collectionParents'),
            r = new hl(),
            i = e => {
              if (r.add(e)) {
                const t = e.lastSegment(),
                  r = e.popLast();
                return n.put({ collectionId: t, parent: so(r) });
              }
            };
          return t
            .store('remoteDocuments')
            .X({ Y: !0 }, (e, t) => {
              const n = new Ci(e);
              return i(n.popLast());
            })
            .next(() =>
              t.store('documentMutations').X({ Y: !0 }, ([e, t, n], r) => {
                const o = co(t);
                return i(o.popLast());
              })
            );
        }
        ei(e) {
          const t = e.store('targets');
          return t.X((e, n) => {
            const r = Pc(n),
              i = Dc(this.serializer, r);
            return t.put(i);
          });
        }
        ni(e, t) {
          const n = t.store('remoteDocuments'),
            r = [];
          return n
            .X((e, n) => {
              const i = t.store('remoteDocumentsV14'),
                o = ((s = n),
                s.document
                  ? new Ni(Ci.fromString(s.document.name).popFirst(5))
                  : s.noDocument
                    ? Ni.fromSegments(s.noDocument.path)
                    : s.unknownDocument
                      ? Ni.fromSegments(s.unknownDocument.path)
                      : oi()).path.toArray();
              var s;
              /**
               * @license
               * Copyright 2017 Google LLC
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *   http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */ const a = {
                prefixPath: o.slice(0, o.length - 2),
                collectionGroup: o[o.length - 2],
                documentId: o[o.length - 1],
                readTime: n.readTime || [0, 0],
                unknownDocument: n.unknownDocument,
                noDocument: n.noDocument,
                document: n.document,
                hasCommittedMutations: !!n.hasCommittedMutations
              };
              r.push(i.put(a));
            })
            .next(() => zi.waitFor(r));
        }
        si(e, t) {
          const n = t.store('mutations'),
            r = $l(this.serializer),
            i = new oh(ah.zs, this.serializer.fe);
          return n.j().next(e => {
            const n = new Map();
            return (
              e.forEach(e => {
                var t;
                let r = null !== (t = n.get(e.userId)) && void 0 !== t ? t : La();
                Rc(this.serializer, e)
                  .keys()
                  .forEach(e => (r = r.add(e))),
                  n.set(e.userId, r);
              }),
              zi.forEach(n, (e, n) => {
                const o = new Yr(n),
                  s = $c.de(this.serializer, o),
                  a = i.getIndexManager(o),
                  u = El.de(o, this.serializer, a, i.referenceDelegate);
                return new Yl(r, u, s, a).recalculateAndSaveOverlaysForDocumentKeys(new Do(t, no.ct), e).next();
              })
            );
          });
        }
      }
      function ch(e) {
        e.createObjectStore('targetDocuments', { keyPath: wo }).createIndex('documentTargetsIndex', bo, { unique: !0 }),
          e.createObjectStore('targets', { keyPath: 'targetId' }).createIndex('queryTargetsIndex', yo, { unique: !0 }),
          e.createObjectStore('targetGlobal');
      }
      const lh =
        'Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.';
      class hh {
        constructor(e, t, n, r, i, o, s, a, u, c, l = 15) {
          if (
            ((this.allowTabSynchronization = e),
            (this.persistenceKey = t),
            (this.clientId = n),
            (this.ii = i),
            (this.window = o),
            (this.document = s),
            (this.ri = u),
            (this.oi = c),
            (this.ui = l),
            (this.Os = null),
            (this.Fs = !1),
            (this.isPrimary = !1),
            (this.networkEnabled = !0),
            (this.ci = null),
            (this.inForeground = !1),
            (this.ai = null),
            (this.hi = null),
            (this.li = Number.NEGATIVE_INFINITY),
            (this.fi = e => Promise.resolve()),
            !hh.D())
          )
            throw new li(
              ci.UNIMPLEMENTED,
              'This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.'
            );
          (this.referenceDelegate = new Fl(this, r)),
            (this.di = t + 'main'),
            (this.serializer = new Ac(a)),
            (this.wi = new Wi(this.di, this.ui, new uh(this.serializer))),
            (this.Bs = new kl(this.referenceDelegate, this.serializer)),
            (this.remoteDocumentCache = $l(this.serializer)),
            (this.qs = new Uc()),
            this.window && this.window.localStorage
              ? (this._i = this.window.localStorage)
              : ((this._i = null),
                !1 === c &&
                  ni(
                    'IndexedDbPersistence',
                    'LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.'
                  ));
        }
        start() {
          return this.mi()
            .then(() => {
              if (!this.isPrimary && !this.allowTabSynchronization) throw new li(ci.FAILED_PRECONDITION, lh);
              return (
                this.gi(),
                this.yi(),
                this.pi(),
                this.runTransaction('getHighestListenSequenceNumber', 'readonly', e => this.Bs.getHighestSequenceNumber(e))
              );
            })
            .then(e => {
              this.Os = new no(e, this.ri);
            })
            .then(() => {
              this.Fs = !0;
            })
            .catch(e => (this.wi && this.wi.close(), Promise.reject(e)));
        }
        Ii(e) {
          return (
            (this.fi = async t => {
              if (this.started) return e(t);
            }),
            e(this.isPrimary)
          );
        }
        setDatabaseDeletedListener(e) {
          this.wi.B(async t => {
            null === t.newVersion && (await e());
          });
        }
        setNetworkEnabled(e) {
          this.networkEnabled !== e &&
            ((this.networkEnabled = e),
            this.ii.enqueueAndForget(async () => {
              this.started && (await this.mi());
            }));
        }
        mi() {
          return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', e =>
            dh(e)
              .put({ clientId: this.clientId, updateTimeMs: Date.now(), networkEnabled: this.networkEnabled, inForeground: this.inForeground })
              .next(() => {
                if (this.isPrimary)
                  return this.Ti(e).next(e => {
                    e || ((this.isPrimary = !1), this.ii.enqueueRetryable(() => this.fi(!1)));
                  });
              })
              .next(() => this.Ei(e))
              .next(t => (this.isPrimary && !t ? this.Ai(e).next(() => !1) : !!t && this.vi(e).next(() => !0)))
          )
            .catch(e => {
              if (Qi(e)) return ti('IndexedDbPersistence', 'Failed to extend owner lease: ', e), this.isPrimary;
              if (!this.allowTabSynchronization) throw e;
              return ti('IndexedDbPersistence', 'Releasing owner lease after error during lease refresh', e), !1;
            })
            .then(e => {
              this.isPrimary !== e && this.ii.enqueueRetryable(() => this.fi(e)), (this.isPrimary = e);
            });
        }
        Ti(e) {
          return fh(e)
            .get('owner')
            .next(e => zi.resolve(this.Ri(e)));
        }
        Pi(e) {
          return dh(e).delete(this.clientId);
        }
        async bi() {
          if (this.isPrimary && !this.Vi(this.li, 18e5)) {
            this.li = Date.now();
            const e = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', e => {
              const t = Lo(e, 'clientMetadata');
              return t.j().next(e => {
                const n = this.Si(e, 18e5),
                  r = e.filter(e => -1 === n.indexOf(e));
                return zi.forEach(r, e => t.delete(e.clientId)).next(() => r);
              });
            }).catch(() => []);
            if (this._i) for (const t of e) this._i.removeItem(this.Di(t.clientId));
          }
        }
        pi() {
          this.hi = this.ii.enqueueAfterDelay('client_metadata_refresh', 4e3, () =>
            this.mi()
              .then(() => this.bi())
              .then(() => this.pi())
          );
        }
        Ri(e) {
          return !!e && e.ownerId === this.clientId;
        }
        Ei(e) {
          return this.oi
            ? zi.resolve(!0)
            : fh(e)
                .get('owner')
                .next(t => {
                  if (null !== t && this.Vi(t.leaseTimestampMs, 5e3) && !this.Ci(t.ownerId)) {
                    if (this.Ri(t) && this.networkEnabled) return !0;
                    if (!this.Ri(t)) {
                      if (!t.allowTabSynchronization) throw new li(ci.FAILED_PRECONDITION, lh);
                      return !1;
                    }
                  }
                  return (
                    !(!this.networkEnabled || !this.inForeground) ||
                    dh(e)
                      .j()
                      .next(
                        e =>
                          void 0 ===
                          this.Si(e, 5e3).find(e => {
                            if (this.clientId !== e.clientId) {
                              const t = !this.networkEnabled && e.networkEnabled,
                                n = !this.inForeground && e.inForeground,
                                r = this.networkEnabled === e.networkEnabled;
                              if (t || (n && r)) return !0;
                            }
                            return !1;
                          })
                      )
                  );
                })
                .next(e => (this.isPrimary !== e && ti('IndexedDbPersistence', `Client ${e ? 'is' : 'is not'} eligible for a primary lease.`), e));
        }
        async shutdown() {
          (this.Fs = !1),
            this.xi(),
            this.hi && (this.hi.cancel(), (this.hi = null)),
            this.Ni(),
            this.ki(),
            await this.wi.runTransaction('shutdown', 'readwrite', ['owner', 'clientMetadata'], e => {
              const t = new Do(e, no.ct);
              return this.Ai(t).next(() => this.Pi(t));
            }),
            this.wi.close(),
            this.Mi();
        }
        Si(e, t) {
          return e.filter(e => this.Vi(e.updateTimeMs, t) && !this.Ci(e.clientId));
        }
        $i() {
          return this.runTransaction('getActiveClients', 'readonly', e =>
            dh(e)
              .j()
              .next(e => this.Si(e, 18e5).map(e => e.clientId))
          );
        }
        get started() {
          return this.Fs;
        }
        getMutationQueue(e, t) {
          return El.de(e, this.serializer, t, this.referenceDelegate);
        }
        getTargetCache() {
          return this.Bs;
        }
        getRemoteDocumentCache() {
          return this.remoteDocumentCache;
        }
        getIndexManager(e) {
          return new dl(e, this.serializer.fe.databaseId);
        }
        getDocumentOverlayCache(e) {
          return $c.de(this.serializer, e);
        }
        getBundleCache() {
          return this.qs;
        }
        runTransaction(e, t, n) {
          ti('IndexedDbPersistence', 'Starting transaction:', e);
          const r = 'readonly' === t ? 'readonly' : 'readwrite',
            i = 15 === (o = this.ui) ? Po : 14 === o ? Ro : 13 === o ? No : 12 === o ? Oo : 11 === o ? ko : void oi();
          var o;
          let s;
          return this.wi
            .runTransaction(
              e,
              r,
              i,
              r => (
                (s = new Do(r, this.Os ? this.Os.next() : no.ct)),
                'readwrite-primary' === t
                  ? this.Ti(s)
                      .next(e => !!e || this.Ei(s))
                      .next(t => {
                        if (!t)
                          throw (
                            (ni(`Failed to obtain primary lease for action '${e}'.`),
                            (this.isPrimary = !1),
                            this.ii.enqueueRetryable(() => this.fi(!1)),
                            new li(ci.FAILED_PRECONDITION, Bi))
                          );
                        return n(s);
                      })
                      .next(e => this.vi(s).next(() => e))
                  : this.Oi(s).next(() => n(s))
              )
            )
            .then(e => (s.raiseOnCommittedEvent(), e));
        }
        Oi(e) {
          return fh(e)
            .get('owner')
            .next(e => {
              if (
                null !== e &&
                this.Vi(e.leaseTimestampMs, 5e3) &&
                !this.Ci(e.ownerId) &&
                !this.Ri(e) &&
                !(this.oi || (this.allowTabSynchronization && e.allowTabSynchronization))
              )
                throw new li(ci.FAILED_PRECONDITION, lh);
            });
        }
        vi(e) {
          const t = { ownerId: this.clientId, allowTabSynchronization: this.allowTabSynchronization, leaseTimestampMs: Date.now() };
          return fh(e).put('owner', t);
        }
        static D() {
          return Wi.D();
        }
        Ai(e) {
          const t = fh(e);
          return t.get('owner').next(e => (this.Ri(e) ? (ti('IndexedDbPersistence', 'Releasing primary lease.'), t.delete('owner')) : zi.resolve()));
        }
        Vi(e, t) {
          const n = Date.now();
          return !(e < n - t) && (!(e > n) || (ni(`Detected an update time that is in the future: ${e} > ${n}`), !1));
        }
        gi() {
          null !== this.document &&
            'function' == typeof this.document.addEventListener &&
            ((this.ai = () => {
              this.ii.enqueueAndForget(() => ((this.inForeground = 'visible' === this.document.visibilityState), this.mi()));
            }),
            this.document.addEventListener('visibilitychange', this.ai),
            (this.inForeground = 'visible' === this.document.visibilityState));
        }
        Ni() {
          this.ai && (this.document.removeEventListener('visibilitychange', this.ai), (this.ai = null));
        }
        yi() {
          var e;
          'function' == typeof (null === (e = this.window) || void 0 === e ? void 0 : e.addEventListener) &&
            ((this.ci = () => {
              this.xi();
              const e = /(?:Version|Mobile)\/1[456]/;
              (0, u.G6)() && (navigator.appVersion.match(e) || navigator.userAgent.match(e)) && this.ii.enterRestrictedMode(!0),
                this.ii.enqueueAndForget(() => this.shutdown());
            }),
            this.window.addEventListener('pagehide', this.ci));
        }
        ki() {
          this.ci && (this.window.removeEventListener('pagehide', this.ci), (this.ci = null));
        }
        Ci(e) {
          var t;
          try {
            const n = null !== (null === (t = this._i) || void 0 === t ? void 0 : t.getItem(this.Di(e)));
            return ti('IndexedDbPersistence', `Client '${e}' ${n ? 'is' : 'is not'} zombied in LocalStorage`), n;
          } catch (e) {
            return ni('IndexedDbPersistence', 'Failed to get zombied client id.', e), !1;
          }
        }
        xi() {
          if (this._i)
            try {
              this._i.setItem(this.Di(this.clientId), String(Date.now()));
            } catch (e) {
              ni('Failed to set zombie client id.', e);
            }
        }
        Mi() {
          if (this._i)
            try {
              this._i.removeItem(this.Di(this.clientId));
            } catch (e) {}
        }
        Di(e) {
          return `firestore_zombie_${this.persistenceKey}_${e}`;
        }
      }
      function fh(e) {
        return Lo(e, 'owner');
      }
      function dh(e) {
        return Lo(e, 'clientMetadata');
      }
      function ph(e, t) {
        let n = e.projectId;
        return e.isDefaultDatabase || (n += '.' + e.database), 'firestore/' + t + '/' + n + '/';
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class gh {
        constructor(e, t, n, r) {
          (this.targetId = e), (this.fromCache = t), (this.Fi = n), (this.Bi = r);
        }
        static Li(e, t) {
          let n = La(),
            r = La();
          for (const i of t.docChanges)
            switch (i.type) {
              case 0:
                n = n.add(i.doc.key);
                break;
              case 1:
                r = r.add(i.doc.key);
            }
          return new gh(e, t.fromCache, n, r);
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class mh {
        constructor() {
          this.qi = !1;
        }
        initialize(e, t) {
          (this.Ui = e), (this.indexManager = t), (this.qi = !0);
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          return this.Ki(e, t)
            .next(i => i || this.Gi(e, t, r, n))
            .next(n => n || this.Qi(e, t));
        }
        Ki(e, t) {
          if (ca(t)) return zi.resolve(null);
          let n = pa(t);
          return this.indexManager.getIndexType(e, n).next(r =>
            0 === r
              ? null
              : (null !== t.limit && 1 === r && ((t = ma(t, null, 'F')), (n = pa(t))),
                this.indexManager.getDocumentsMatchingTarget(e, n).next(r => {
                  const i = La(...r);
                  return this.Ui.getDocuments(e, i).next(r =>
                    this.indexManager.getMinOffset(e, n).next(n => {
                      const o = this.ji(t, r);
                      return this.zi(t, o, i, n.readTime) ? this.Ki(e, ma(t, null, 'F')) : this.Wi(e, o, t, n);
                    })
                  );
                }))
          );
        }
        Gi(e, t, n, r) {
          return ca(t) || r.isEqual(Ai.min())
            ? this.Qi(e, t)
            : this.Ui.getDocuments(e, n).next(i => {
                const o = this.ji(t, i);
                return this.zi(t, o, n, r)
                  ? this.Qi(e, t)
                  : (Zr() <= a['in'].DEBUG && ti('QueryEngine', 'Re-using previous result from %s to execute query: %s', r.toString(), wa(t)),
                    this.Wi(e, o, t, Mi(r, -1)));
              });
        }
        ji(e, t) {
          let n = new $o(Ia(e));
          return (
            t.forEach((t, r) => {
              ba(e, r) && (n = n.add(r));
            }),
            n
          );
        }
        zi(e, t, n, r) {
          if (null === e.limit) return !1;
          if (n.size !== t.size) return !0;
          const i = 'F' === e.limitType ? t.last() : t.first();
          return !!i && (i.hasPendingWrites || i.version.compareTo(r) > 0);
        }
        Qi(e, t) {
          return (
            Zr() <= a['in'].DEBUG && ti('QueryEngine', 'Using full collection scan to execute query:', wa(t)),
            this.Ui.getDocumentsMatchingQuery(e, t, Ui.min())
          );
        }
        Wi(e, t, n, r) {
          return this.Ui.getDocumentsMatchingQuery(e, n, r).next(
            e => (
              t.forEach(t => {
                e = e.insert(t.key, t);
              }),
              e
            )
          );
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class vh {
        constructor(e, t, n, r) {
          (this.persistence = e),
            (this.Hi = t),
            (this.serializer = r),
            (this.Ji = new Uo(Ii)),
            (this.Yi = new Sa(e => ea(e), ta)),
            (this.Xi = new Map()),
            (this.Zi = e.getRemoteDocumentCache()),
            (this.Bs = e.getTargetCache()),
            (this.qs = e.getBundleCache()),
            this.tr(n);
        }
        tr(e) {
          (this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e)),
            (this.indexManager = this.persistence.getIndexManager(e)),
            (this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager)),
            (this.localDocuments = new Yl(this.Zi, this.mutationQueue, this.documentOverlayCache, this.indexManager)),
            this.Zi.setIndexManager(this.indexManager),
            this.Hi.initialize(this.localDocuments, this.indexManager);
        }
        collectGarbage(e) {
          return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', t => e.collect(t, this.Ji));
        }
      }
      function yh(e, t, n, r) {
        return new vh(e, t, n, r);
      }
      async function wh(e, t) {
        const n = ui(e);
        return await n.persistence.runTransaction('Handle user change', 'readonly', e => {
          let r;
          return n.mutationQueue
            .getAllMutationBatches(e)
            .next(i => ((r = i), n.tr(t), n.mutationQueue.getAllMutationBatches(e)))
            .next(t => {
              const i = [],
                o = [];
              let s = La();
              for (const e of r) {
                i.push(e.batchId);
                for (const t of e.mutations) s = s.add(t.key);
              }
              for (const e of t) {
                o.push(e.batchId);
                for (const t of e.mutations) s = s.add(t.key);
              }
              return n.localDocuments.getDocuments(e, s).next(e => ({ er: e, removedBatchIds: i, addedBatchIds: o }));
            });
        });
      }
      function bh(e, t) {
        const n = ui(e);
        return n.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', e => {
          const r = t.batch.keys(),
            i = n.Zi.newChangeBuffer({ trackRemovals: !0 });
          return (function (e, t, n, r) {
            const i = n.batch,
              o = i.keys();
            let s = zi.resolve();
            return (
              o.forEach(e => {
                s = s
                  .next(() => r.getEntry(t, e))
                  .next(t => {
                    const o = n.docVersions.get(e);
                    si(null !== o),
                      t.version.compareTo(o) < 0 &&
                        (i.applyToRemoteDocument(t, n), t.isValidDocument() && (t.setReadTime(n.commitVersion), r.addEntry(t)));
                  });
              }),
              s.next(() => e.mutationQueue.removeMutationBatch(t, i))
            );
          })(n, e, t, i)
            .next(() => i.apply(e))
            .next(() => n.mutationQueue.performConsistencyCheck(e))
            .next(() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t.batch.batchId))
            .next(() =>
              n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(
                e,
                (function (e) {
                  let t = La();
                  for (let n = 0; n < e.mutationResults.length; ++n)
                    e.mutationResults[n].transformResults.length > 0 && (t = t.add(e.batch.mutations[n].key));
                  return t;
                })(t)
              )
            )
            .next(() => n.localDocuments.getDocuments(e, r));
        });
      }
      function _h(e) {
        const t = ui(e);
        return t.persistence.runTransaction('Get last remote snapshot version', 'readonly', e => t.Bs.getLastRemoteSnapshotVersion(e));
      }
      function Ih(e, t) {
        const n = ui(e),
          r = t.snapshotVersion;
        let i = n.Ji;
        return n.persistence
          .runTransaction('Apply remote event', 'readwrite-primary', e => {
            const o = n.Zi.newChangeBuffer({ trackRemovals: !0 });
            i = n.Ji;
            const s = [];
            t.targetChanges.forEach((o, a) => {
              const u = i.get(a);
              if (!u) return;
              s.push(n.Bs.removeMatchingKeys(e, o.removedDocuments, a).next(() => n.Bs.addMatchingKeys(e, o.addedDocuments, a)));
              let c = u.withSequenceNumber(e.currentSequenceNumber);
              null !== t.targetMismatches.get(a)
                ? (c = c.withResumeToken(Ko.EMPTY_BYTE_STRING, Ai.min()).withLastLimboFreeSnapshotVersion(Ai.min()))
                : o.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(o.resumeToken, r)),
                (i = i.insert(a, c)),
                (function (e, t, n) {
                  return (
                    0 === e.resumeToken.approximateByteSize() ||
                    t.snapshotVersion.toMicroseconds() - e.snapshotVersion.toMicroseconds() >= 3e8 ||
                    n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size > 0
                  );
                })(u, c, o) && s.push(n.Bs.updateTargetData(e, c));
            });
            let a = Aa(),
              u = La();
            if (
              (t.documentUpdates.forEach(r => {
                t.resolvedLimboDocuments.has(r) && s.push(n.persistence.referenceDelegate.updateLimboDocument(e, r));
              }),
              s.push(
                Eh(e, o, t.documentUpdates).next(e => {
                  (a = e.nr), (u = e.sr);
                })
              ),
              !r.isEqual(Ai.min()))
            ) {
              const t = n.Bs.getLastRemoteSnapshotVersion(e).next(t => n.Bs.setTargetsMetadata(e, e.currentSequenceNumber, r));
              s.push(t);
            }
            return zi
              .waitFor(s)
              .next(() => o.apply(e))
              .next(() => n.localDocuments.getLocalViewOfDocuments(e, a, u))
              .next(() => a);
          })
          .then(e => ((n.Ji = i), e));
      }
      function Eh(e, t, n) {
        let r = La(),
          i = La();
        return (
          n.forEach(e => (r = r.add(e))),
          t.getEntries(e, r).next(e => {
            let r = Aa();
            return (
              n.forEach((n, o) => {
                const s = e.get(n);
                o.isFoundDocument() !== s.isFoundDocument() && (i = i.add(n)),
                  o.isNoDocument() && o.version.isEqual(Ai.min())
                    ? (t.removeEntry(n, o.readTime), (r = r.insert(n, o)))
                    : !s.isValidDocument() || o.version.compareTo(s.version) > 0 || (0 === o.version.compareTo(s.version) && s.hasPendingWrites)
                      ? (t.addEntry(o), (r = r.insert(n, o)))
                      : ti('LocalStore', 'Ignoring outdated watch update for ', n, '. Current version:', s.version, ' Watch version:', o.version);
              }),
              { nr: r, sr: i }
            );
          })
        );
      }
      function Sh(e, t) {
        const n = ui(e);
        return n.persistence.runTransaction(
          'Get next mutation batch',
          'readonly',
          e => (void 0 === t && (t = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(e, t))
        );
      }
      function Th(e, t) {
        const n = ui(e);
        return n.persistence
          .runTransaction('Allocate target', 'readwrite', e => {
            let r;
            return n.Bs.getTargetData(e, t).next(i =>
              i
                ? ((r = i), zi.resolve(r))
                : n.Bs.allocateTargetId(e).next(
                    i => ((r = new Tc(t, i, 'TargetPurposeListen', e.currentSequenceNumber)), n.Bs.addTargetData(e, r).next(() => r))
                  )
            );
          })
          .then(e => {
            const r = n.Ji.get(e.targetId);
            return (
              (null === r || e.snapshotVersion.compareTo(r.snapshotVersion) > 0) && ((n.Ji = n.Ji.insert(e.targetId, e)), n.Yi.set(t, e.targetId)), e
            );
          });
      }
      async function Ah(e, t, n) {
        const r = ui(e),
          i = r.Ji.get(t),
          o = n ? 'readwrite' : 'readwrite-primary';
        try {
          n || (await r.persistence.runTransaction('Release target', o, e => r.persistence.referenceDelegate.removeTarget(e, i)));
        } catch (e) {
          if (!Qi(e)) throw e;
          ti('LocalStore', `Failed to update sequence numbers for target ${t}: ${e}`);
        }
        (r.Ji = r.Ji.remove(t)), r.Yi.delete(i.target);
      }
      function xh(e, t, n) {
        const r = ui(e);
        let i = Ai.min(),
          o = La();
        return r.persistence.runTransaction('Execute query', 'readonly', e =>
          (function (e, t, n) {
            const r = ui(e),
              i = r.Yi.get(n);
            return void 0 !== i ? zi.resolve(r.Ji.get(i)) : r.Bs.getTargetData(t, n);
          })(r, e, pa(t))
            .next(t => {
              if (t)
                return (
                  (i = t.lastLimboFreeSnapshotVersion),
                  r.Bs.getMatchingKeysForTargetId(e, t.targetId).next(e => {
                    o = e;
                  })
                );
            })
            .next(() => r.Hi.getDocumentsMatchingQuery(e, t, n ? i : Ai.min(), n ? o : La()))
            .next(e => (Oh(r, _a(t), e), { documents: e, ir: o }))
        );
      }
      function Ch(e, t) {
        const n = ui(e),
          r = ui(n.Bs),
          i = n.Ji.get(t);
        return i
          ? Promise.resolve(i.target)
          : n.persistence.runTransaction('Get target data', 'readonly', e => r.le(e, t).next(e => (e ? e.target : null)));
      }
      function kh(e, t) {
        const n = ui(e),
          r = n.Xi.get(t) || Ai.min();
        return n.persistence
          .runTransaction('Get new document changes', 'readonly', e => n.Zi.getAllFromCollectionGroup(e, t, Mi(r, -1), Number.MAX_SAFE_INTEGER))
          .then(e => (Oh(n, t, e), e));
      }
      function Oh(e, t, n) {
        let r = e.Xi.get(t) || Ai.min();
        n.forEach((e, t) => {
          t.readTime.compareTo(r) > 0 && (r = t.readTime);
        }),
          e.Xi.set(t, r);
      }
      async function Nh(e, t, n, r) {
        const i = ui(e);
        let o = La(),
          s = Aa();
        for (const c of n) {
          const e = t.rr(c.metadata.name);
          c.document && (o = o.add(e));
          const n = t.ur(c);
          n.setReadTime(t.cr(c.metadata.readTime)), (s = s.insert(e, n));
        }
        const a = i.Zi.newChangeBuffer({ trackRemovals: !0 }),
          u = await Th(
            i,
            (function (e) {
              return pa(ua(Ci.fromString(`__bundle__/docs/${e}`)));
            })(r)
          );
        return i.persistence.runTransaction('Apply bundle documents', 'readwrite', e =>
          Eh(e, a, s)
            .next(t => (a.apply(e), t))
            .next(t =>
              i.Bs.removeMatchingKeysForTargetId(e, u.targetId)
                .next(() => i.Bs.addMatchingKeys(e, o, u.targetId))
                .next(() => i.localDocuments.getLocalViewOfDocuments(e, t.nr, t.sr))
                .next(() => t.nr)
            )
        );
      }
      async function Rh(e, t, n = La()) {
        const r = await Th(e, pa(Lc(t.bundledQuery))),
          i = ui(e);
        return i.persistence.runTransaction('Save named query', 'readwrite', e => {
          const o = Yu(t.readTime);
          if (r.snapshotVersion.compareTo(o) >= 0) return i.qs.saveNamedQuery(e, t);
          const s = r.withResumeToken(Ko.EMPTY_BYTE_STRING, o);
          return (
            (i.Ji = i.Ji.insert(s.targetId, s)),
            i.Bs.updateTargetData(e, s)
              .next(() => i.Bs.removeMatchingKeysForTargetId(e, r.targetId))
              .next(() => i.Bs.addMatchingKeys(e, n, r.targetId))
              .next(() => i.qs.saveNamedQuery(e, t))
          );
        });
      }
      function Ph(e, t) {
        return `firestore_clients_${e}_${t}`;
      }
      function Dh(e, t, n) {
        let r = `firestore_mutations_${e}_${n}`;
        return t.isAuthenticated() && (r += `_${t.uid}`), r;
      }
      function Lh(e, t) {
        return `firestore_targets_${e}_${t}`;
      }
      class jh {
        constructor(e, t, n, r) {
          (this.user = e), (this.batchId = t), (this.state = n), (this.error = r);
        }
        static ar(e, t, n) {
          const r = JSON.parse(n);
          let i,
            o =
              'object' == typeof r &&
              -1 !== ['pending', 'acknowledged', 'rejected'].indexOf(r.state) &&
              (void 0 === r.error || 'object' == typeof r.error);
          return (
            o &&
              r.error &&
              ((o = 'string' == typeof r.error.message && 'string' == typeof r.error.code), o && (i = new li(r.error.code, r.error.message))),
            o ? new jh(e, t, r.state, i) : (ni('SharedClientState', `Failed to parse mutation state for ID '${t}': ${n}`), null)
          );
        }
        hr() {
          const e = { state: this.state, updateTimeMs: Date.now() };
          return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e);
        }
      }
      class Mh {
        constructor(e, t, n) {
          (this.targetId = e), (this.state = t), (this.error = n);
        }
        static ar(e, t) {
          const n = JSON.parse(t);
          let r,
            i =
              'object' == typeof n &&
              -1 !== ['not-current', 'current', 'rejected'].indexOf(n.state) &&
              (void 0 === n.error || 'object' == typeof n.error);
          return (
            i &&
              n.error &&
              ((i = 'string' == typeof n.error.message && 'string' == typeof n.error.code), i && (r = new li(n.error.code, n.error.message))),
            i ? new Mh(e, n.state, r) : (ni('SharedClientState', `Failed to parse target state for ID '${e}': ${t}`), null)
          );
        }
        hr() {
          const e = { state: this.state, updateTimeMs: Date.now() };
          return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e);
        }
      }
      class Fh {
        constructor(e, t) {
