remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
          return (
            i.forEach(e => {
              r.has(e) || o.push(e);
            }),
            r.forEach(e => {
              i.has(e) || s.push(e);
            }),
            this.syncEngine.Wr(o, s).then(() => {
              this.gr = n;
            })
          );
        }
        Vr(e) {
          this.gr.get(e.clientId) && this.onlineStateHandler(e.onlineState);
        }
        Sr(e) {
          let t = Ma();
          return (
            e.forEach((e, n) => {
              t = t.unionWith(n.activeTargetIds);
            }),
            t
          );
        }
      }
      class $h {
        constructor() {
          (this.Hr = new Vh()), (this.Jr = {}), (this.onlineStateHandler = null), (this.sequenceNumberHandler = null);
        }
        addPendingMutation(e) {}
        updateMutationState(e, t, n) {}
        addLocalQueryTarget(e) {
          return this.Hr.lr(e), this.Jr[e] || 'not-current';
        }
        updateQueryState(e, t, n) {
          this.Jr[e] = t;
        }
        removeLocalQueryTarget(e) {
          this.Hr.dr(e);
        }
        isLocalQueryTarget(e) {
          return this.Hr.activeTargetIds.has(e);
        }
        clearQueryState(e) {
          delete this.Jr[e];
        }
        getAllActiveQueryTargets() {
          return this.Hr.activeTargetIds;
        }
        isActiveQueryTarget(e) {
          return this.Hr.activeTargetIds.has(e);
        }
        start() {
          return (this.Hr = new Vh()), Promise.resolve();
        }
        handleUserChange(e, t, n) {}
        setOnlineState(e) {}
        shutdown() {}
        writeSequenceNumber(e) {}
        notifyBundleLoaded(e) {}
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class qh {
        Yr(e) {}
        shutdown() {}
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class zh {
        constructor() {
          (this.Xr = () => this.Zr()), (this.eo = () => this.no()), (this.so = []), this.io();
        }
        Yr(e) {
          this.so.push(e);
        }
        shutdown() {
          window.removeEventListener('online', this.Xr), window.removeEventListener('offline', this.eo);
        }
        io() {
          window.addEventListener('online', this.Xr), window.addEventListener('offline', this.eo);
        }
        Zr() {
          ti('ConnectivityMonitor', 'Network connectivity changed: AVAILABLE');
          for (const e of this.so) e(0);
        }
        no() {
          ti('ConnectivityMonitor', 'Network connectivity changed: UNAVAILABLE');
          for (const e of this.so) e(1);
        }
        static D() {
          return 'undefined' != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
        }
      }
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ let Gh = null;
      function Wh() {
        return null === Gh ? (Gh = 268435456 + Math.round(2147483648 * Math.random())) : Gh++, '0x' + Gh.toString(16);
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      const Hh = { BatchGetDocuments: 'batchGet', Commit: 'commit', RunQuery: 'runQuery', RunAggregationQuery: 'runAggregationQuery' };
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Kh {
        constructor(e) {
          (this.ro = e.ro), (this.oo = e.oo);
        }
        uo(e) {
          this.co = e;
        }
        ao(e) {
          this.ho = e;
        }
        onMessage(e) {
          this.lo = e;
        }
        close() {
          this.oo();
        }
        send(e) {
          this.ro(e);
        }
        fo() {
          this.co();
        }
        wo(e) {
          this.ho(e);
        }
        _o(e) {
          this.lo(e);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Qh = 'WebChannelConnection';
      class Yh extends class {
        constructor(e) {
          (this.databaseInfo = e), (this.databaseId = e.databaseId);
          const t = e.ssl ? 'https' : 'http';
          (this.mo = t + '://' + e.host),
            (this.yo = 'projects/' + this.databaseId.projectId + '/databases/' + this.databaseId.database + '/documents');
        }
        get po() {
          return !1;
        }
        Io(e, t, n, r, i) {
          const o = Wh(),
            s = this.To(e, t);
          ti('RestConnection', `Sending RPC '${e}' ${o}:`, s, n);
          const a = {};
          return (
            this.Eo(a, r, i),
            this.Ao(e, s, a, n).then(
              t => (ti('RestConnection', `Received RPC '${e}' ${o}: `, t), t),
              t => {
                throw (ri('RestConnection', `RPC '${e}' ${o} failed with error: `, t, 'url: ', s, 'request:', n), t);
              }
            )
          );
        }
        vo(e, t, n, r, i, o) {
          return this.Io(e, t, n, r, i);
        }
        Eo(e, t, n) {
          (e['X-Goog-Api-Client'] = 'gl-js/ fire/' + Xr),
            (e['Content-Type'] = 'text/plain'),
            this.databaseInfo.appId && (e['X-Firebase-GMPID'] = this.databaseInfo.appId),
            t && t.headers.forEach((t, n) => (e[n] = t)),
            n && n.headers.forEach((t, n) => (e[n] = t));
        }
        To(e, t) {
          const n = Hh[e];
          return `${this.mo}/v1/${t}:${n}`;
        }
      } {
        constructor(e) {
          super(e),
            (this.forceLongPolling = e.forceLongPolling),
            (this.autoDetectLongPolling = e.autoDetectLongPolling),
            (this.useFetchStreams = e.useFetchStreams),
            (this.longPollingOptions = e.longPollingOptions);
        }
        Ao(e, t, n, r) {
          const i = Wh();
          return new Promise((o, s) => {
            const a = new Wr();
            a.setWithCredentials(!0),
              a.listenOnce(Br.COMPLETE, () => {
                try {
                  switch (a.getLastErrorCode()) {
                    case Vr.NO_ERROR:
                      const t = a.getResponseJson();
                      ti(Qh, `XHR for RPC '${e}' ${i} received:`, JSON.stringify(t)), o(t);
                      break;
                    case Vr.TIMEOUT:
                      ti(Qh, `RPC '${e}' ${i} timed out`), s(new li(ci.DEADLINE_EXCEEDED, 'Request time out'));
                      break;
                    case Vr.HTTP_ERROR:
                      const n = a.getStatus();
                      if ((ti(Qh, `RPC '${e}' ${i} failed with status:`, n, 'response text:', a.getResponseText()), n > 0)) {
                        let e = a.getResponseJson();
                        Array.isArray(e) && (e = e[0]);
                        const t = null == e ? void 0 : e.error;
                        if (t && t.status && t.message) {
                          const e = (function (e) {
                            const t = e.toLowerCase().replace(/_/g, '-');
                            return Object.values(ci).indexOf(t) >= 0 ? t : ci.UNKNOWN;
                          })(t.status);
                          s(new li(e, t.message));
                        } else s(new li(ci.UNKNOWN, 'Server responded with status ' + a.getStatus()));
                      } else s(new li(ci.UNAVAILABLE, 'Connection failed.'));
                      break;
                    default:
                      oi();
                  }
                } finally {
                  ti(Qh, `RPC '${e}' ${i} completed.`);
                }
              });
            const u = JSON.stringify(r);
            ti(Qh, `RPC '${e}' ${i} sending request:`, r), a.send(t, 'POST', u, n, 15);
          });
        }
        Ro(e, t, n) {
          const r = Wh(),
            i = [this.mo, '/', 'google.firestore.v1.Firestore', '/', e, '/channel'],
            o = Fr(),
            s = Ur(),
            a = {
              httpSessionIdParam: 'gsessionid',
              initMessageHeaders: {},
              messageUrlParams: { database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}` },
              sendRawJson: !0,
              supportsCrossDomainXhr: !0,
              internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 },
              forceLongPolling: this.forceLongPolling,
              detectBufferingProxy: this.autoDetectLongPolling
            },
            u = this.longPollingOptions.timeoutSeconds;
          void 0 !== u && (a.longPollingTimeout = Math.round(1e3 * u)),
            this.useFetchStreams && (a.xmlHttpFactory = new zr({})),
            this.Eo(a.initMessageHeaders, t, n),
            (a.encodeInitMessageHeaders = !0);
          const c = i.join('');
          ti(Qh, `Creating RPC '${e}' stream ${r}: ${c}`, a);
          const l = o.createWebChannel(c, a);
          let h = !1,
            f = !1;
          const d = new Kh({
              ro: t => {
                f
                  ? ti(Qh, `Not sending because RPC '${e}' stream ${r} is closed:`, t)
                  : (h || (ti(Qh, `Opening RPC '${e}' stream ${r} transport.`), l.open(), (h = !0)),
                    ti(Qh, `RPC '${e}' stream ${r} sending:`, t),
                    l.send(t));
              },
              oo: () => l.close()
            }),
            p = (e, t, n) => {
              e.listen(t, e => {
                try {
                  n(e);
                } catch (e) {
                  setTimeout(() => {
                    throw e;
                  }, 0);
                }
              });
            };
          return (
            p(l, Gr.EventType.OPEN, () => {
              f || ti(Qh, `RPC '${e}' stream ${r} transport opened.`);
            }),
            p(l, Gr.EventType.CLOSE, () => {
              f || ((f = !0), ti(Qh, `RPC '${e}' stream ${r} transport closed`), d.wo());
            }),
            p(l, Gr.EventType.ERROR, t => {
              f ||
                ((f = !0),
                ri(Qh, `RPC '${e}' stream ${r} transport errored:`, t),
                d.wo(new li(ci.UNAVAILABLE, 'The operation could not be completed')));
            }),
            p(l, Gr.EventType.MESSAGE, t => {
              var n;
              if (!f) {
                const i = t.data[0];
                si(!!i);
                const o = i,
                  s = o.error || (null === (n = o[0]) || void 0 === n ? void 0 : n.error);
                if (s) {
                  ti(Qh, `RPC '${e}' stream ${r} received error:`, s);
                  const t = s.status;
                  let n = (function (e) {
                      const t = _u[e];
                      if (void 0 !== t) return Su(t);
                    })(t),
                    i = s.message;
                  void 0 === n && ((n = ci.INTERNAL), (i = 'Unknown error status: ' + t + ' with message ' + s.message)),
                    (f = !0),
                    d.wo(new li(n, i)),
                    l.close();
                } else ti(Qh, `RPC '${e}' stream ${r} received:`, i), d._o(i);
              }
            }),
            p(s, $r.STAT_EVENT, t => {
              t.stat === qr.PROXY
                ? ti(Qh, `RPC '${e}' stream ${r} detected buffering proxy`)
                : t.stat === qr.NOPROXY && ti(Qh, `RPC '${e}' stream ${r} detected no buffering proxy`);
            }),
            setTimeout(() => {
              d.fo();
            }, 0),
            d
          );
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
