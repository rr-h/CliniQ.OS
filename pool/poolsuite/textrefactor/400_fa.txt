remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
          (this.settings = e),
            (this.databaseId = t),
            (this.serializer = n),
            (this.ignoreUndefinedProperties = r),
            void 0 === i && this.ua(),
            (this.fieldTransforms = i || []),
            (this.fieldMask = o || []);
        }
        get path() {
          return this.settings.path;
        }
        get ca() {
          return this.settings.ca;
        }
        aa(e) {
          return new ig(
            Object.assign(Object.assign({}, this.settings), e),
            this.databaseId,
            this.serializer,
            this.ignoreUndefinedProperties,
            this.fieldTransforms,
            this.fieldMask
          );
        }
        ha(e) {
          var t;
          const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e),
            r = this.aa({ path: n, la: !1 });
          return r.fa(e), r;
        }
        da(e) {
          var t;
          const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e),
            r = this.aa({ path: n, la: !1 });
          return r.ua(), r;
        }
        wa(e) {
          return this.aa({ path: void 0, la: !0 });
        }
        _a(e) {
          return Sg(e, this.settings.methodName, this.settings.ma || !1, this.path, this.settings.ga);
        }
        contains(e) {
          return void 0 !== this.fieldMask.find(t => e.isPrefixOf(t)) || void 0 !== this.fieldTransforms.find(t => e.isPrefixOf(t.field));
        }
        ua() {
          if (this.path) for (let e = 0; e < this.path.length; e++) this.fa(this.path.get(e));
        }
        fa(e) {
          if (0 === e.length) throw this._a('Document fields must not be empty');
          if (rg(this.ca) && eg.test(e)) throw this._a('Document fields cannot begin and end with "__"');
        }
      }
      class og {
        constructor(e, t, n) {
          (this.databaseId = e), (this.ignoreUndefinedProperties = t), (this.serializer = n || Zh(e));
        }
        ya(e, t, n, r = !1) {
          return new ig(
            { ca: e, methodName: t, ga: n, path: Oi.emptyPath(), la: !1, ma: r },
            this.databaseId,
            this.serializer,
            this.ignoreUndefinedProperties
          );
        }
      }
      function sg(e) {
        const t = e._freezeSettings(),
          n = Zh(e._databaseId);
        return new og(e._databaseId, !!t.ignoreUndefinedProperties, n);
      }
      function ag(e, t, n, r, i, o = {}) {
        const s = e.ya(o.merge || o.mergeFields ? 2 : 0, t, n, i);
        bg('Data must be an object, but it was:', s, r);
        const a = yg(r, s);
        let u, c;
        if (o.merge) (u = new Go(s.fieldMask)), (c = s.fieldTransforms);
        else if (o.mergeFields) {
          const e = [];
          for (const r of o.mergeFields) {
            const i = _g(t, r, n);
            if (!s.contains(i)) throw new li(ci.INVALID_ARGUMENT, `Field '${i}' is specified in your field mask but missing from your input data.`);
            Tg(e, i) || e.push(i);
          }
          (u = new Go(e)), (c = s.fieldTransforms.filter(e => u.covers(e.field)));
        } else (u = null), (c = s.fieldTransforms);
        return new tg(new Ts(a), u, c);
      }
      class ug extends Jp {
        _toFieldTransform(e) {
          if (2 !== e.ca)
            throw 1 === e.ca
              ? e._a(`${this._methodName}() can only appear at the top level of your update data`)
              : e._a(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
          return e.fieldMask.push(e.path), null;
        }
        isEqual(e) {
          return e instanceof ug;
        }
      }
      function cg(e, t, n) {
        return new ig({ ca: 3, ga: t.settings.ga, methodName: e._methodName, la: n }, t.databaseId, t.serializer, t.ignoreUndefinedProperties);
      }
      class lg extends Jp {
        _toFieldTransform(e) {
          return new Za(e.path, new Ga());
        }
        isEqual(e) {
          return e instanceof lg;
        }
      }
      class hg extends Jp {
        constructor(e, t) {
          super(e), (this.pa = t);
        }
        _toFieldTransform(e) {
          const t = cg(this, e, !0),
            n = this.pa.map(e => vg(e, t)),
            r = new Wa(n);
          return new Za(e.path, r);
        }
        isEqual(e) {
          return this === e;
        }
      }
      class fg extends Jp {
        constructor(e, t) {
          super(e), (this.pa = t);
        }
        _toFieldTransform(e) {
          const t = cg(this, e, !0),
            n = this.pa.map(e => vg(e, t)),
            r = new Ka(n);
          return new Za(e.path, r);
        }
        isEqual(e) {
          return this === e;
        }
      }
      class dg extends Jp {
        constructor(e, t) {
          super(e), (this.Ia = t);
        }
        _toFieldTransform(e) {
          const t = new Ya(e.serializer, Va(e.serializer, this.Ia));
          return new Za(e.path, t);
        }
        isEqual(e) {
          return this === e;
        }
      }
      function pg(e, t, n, r) {
        const i = e.ya(1, t, n);
        bg('Data must be an object, but it was:', i, r);
        const o = [],
          s = Ts.empty();
        Mo(r, (e, r) => {
          const a = Eg(t, e, n);
          r = (0, u.m9)(r);
          const c = i.da(a);
          if (r instanceof ug) o.push(a);
          else {
            const e = vg(r, c);
            null != e && (o.push(a), s.set(a, e));
          }
        });
        const a = new Go(o);
        return new ng(s, a, i.fieldTransforms);
      }
      function gg(e, t, n, r, i, o) {
        const s = e.ya(1, t, n),
          a = [_g(t, r, n)],
          c = [i];
        if (o.length % 2 != 0)
          throw new li(
            ci.INVALID_ARGUMENT,
            `Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`
          );
        for (let u = 0; u < o.length; u += 2) a.push(_g(t, o[u])), c.push(o[u + 1]);
        const l = [],
          h = Ts.empty();
        for (let d = a.length - 1; d >= 0; --d)
          if (!Tg(l, a[d])) {
            const e = a[d];
            let t = c[d];
            t = (0, u.m9)(t);
            const n = s.da(e);
            if (t instanceof ug) l.push(e);
            else {
              const r = vg(t, n);
              null != r && (l.push(e), h.set(e, r));
            }
          }
        const f = new Go(l);
        return new ng(h, f, s.fieldTransforms);
      }
      function mg(e, t, n, r = !1) {
        return vg(n, e.ya(r ? 4 : 3, t));
      }
      function vg(e, t) {
        if (wg((e = (0, u.m9)(e)))) return bg('Unsupported field value:', t, e), yg(e, t);
        if (e instanceof Jp)
          return (
            (function (e, t) {
              if (!rg(t.ca)) throw t._a(`${e._methodName}() can only be used with update() and set()`);
              if (!t.path) throw t._a(`${e._methodName}() is not currently supported inside arrays`);
              const n = e._toFieldTransform(t);
              n && t.fieldTransforms.push(n);
            })(e, t),
            null
          );
        if (void 0 === e && t.ignoreUndefinedProperties) return null;
        if ((t.path && t.fieldMask.push(t.path), e instanceof Array)) {
          if (t.settings.la && 4 !== t.ca) throw t._a('Nested arrays are not supported');
          return (function (e, t) {
            const n = [];
            let r = 0;
            for (const i of e) {
              let e = vg(i, t.wa(r));
              null == e && (e = { nullValue: 'NULL_VALUE' }), n.push(e), r++;
            }
            return { arrayValue: { values: n } };
          })(e, t);
        }
        return (function (e, t) {
          if (null === (e = (0, u.m9)(e))) return { nullValue: 'NULL_VALUE' };
          if ('number' == typeof e) return Va(t.serializer, e);
          if ('boolean' == typeof e) return { booleanValue: e };
          if ('string' == typeof e) return { stringValue: e };
          if (e instanceof Date) {
            const n = Ti.fromDate(e);
            return { timestampValue: Hu(t.serializer, n) };
          }
          if (e instanceof Ti) {
            const n = new Ti(e.seconds, 1e3 * Math.floor(e.nanoseconds / 1e3));
            return { timestampValue: Hu(t.serializer, n) };
          }
          if (e instanceof Zp) return { geoPointValue: { latitude: e.latitude, longitude: e.longitude } };
          if (e instanceof Yp) return { bytesValue: Ku(t.serializer, e._byteString) };
          if (e instanceof Tp) {
            const n = t.databaseId,
              r = e.firestore._databaseId;
            if (!r.isEqual(n))
              throw t._a(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);
            return { referenceValue: Xu(e.firestore._databaseId || t.databaseId, e._key.path) };
          }
          throw t._a(`Unsupported field value: ${wp(e)}`);
        })(e, t);
      }
      function yg(e, t) {
        const n = {};
        return (
          Fo(e)
            ? t.path && t.path.length > 0 && t.fieldMask.push(t.path)
            : Mo(e, (e, r) => {
                const i = vg(r, t.ha(e));
                null != i && (n[e] = i);
              }),
          { mapValue: { fields: n } }
        );
      }
      function wg(e) {
        return !(
          'object' != typeof e ||
          null === e ||
          e instanceof Array ||
          e instanceof Date ||
          e instanceof Ti ||
          e instanceof Zp ||
          e instanceof Yp ||
          e instanceof Tp ||
          e instanceof Jp
        );
      }
      function bg(e, t, n) {
        if (
          !wg(n) ||
          !(function (e) {
            return 'object' == typeof e && null !== e && (Object.getPrototypeOf(e) === Object.prototype || null === Object.getPrototypeOf(e));
          })(n)
        ) {
          const r = wp(n);
          throw 'an object' === r ? t._a(e + ' a custom object') : t._a(e + ' ' + r);
        }
      }
      function _g(e, t, n) {
        if ((t = (0, u.m9)(t)) instanceof Xp) return t._internalPath;
        if ('string' == typeof t) return Eg(e, t);
        throw Sg('Field path arguments must be of type string or ', e, !1, void 0, n);
      }
      const Ig = new RegExp('[~\\*/\\[\\]]');
      function Eg(e, t, n) {
        if (t.search(Ig) >= 0) throw Sg(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, n);
        try {
          return new Xp(...t.split('.'))._internalPath;
        } catch (r) {
          throw Sg(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, n);
        }
      }
      function Sg(e, t, n, r, i) {
        const o = r && !r.isEmpty(),
          s = void 0 !== i;
        let a = `Function ${t}() called with invalid data`;
        n && (a += ' (via `toFirestore()`)'), (a += '. ');
        let u = '';
        return (
          (o || s) && ((u += ' (found'), o && (u += ` in field ${r}`), s && (u += ` in document ${i}`), (u += ')')),
          new li(ci.INVALID_ARGUMENT, a + e + u)
        );
      }
      function Tg(e, t) {
        return e.some(e => e.isEqual(t));
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ag {
        constructor(e, t, n, r, i) {
          (this._firestore = e), (this._userDataWriter = t), (this._key = n), (this._document = r), (this._converter = i);
        }
        get id() {
          return this._key.path.lastSegment();
        }
        get ref() {
          return new Tp(this._firestore, this._converter, this._key);
        }
        exists() {
          return null !== this._document;
        }
        data() {
          if (this._document) {
            if (this._converter) {
              const e = new xg(this._firestore, this._userDataWriter, this._key, this._document, null);
              return this._converter.fromFirestore(e);
            }
            return this._userDataWriter.convertValue(this._document.data.value);
          }
        }
        get(e) {
          if (this._document) {
            const t = this._document.data.field(Cg('DocumentSnapshot.get', e));
            if (null !== t) return this._userDataWriter.convertValue(t);
          }
        }
      }
      class xg extends Ag {
        data() {
          return super.data();
        }
      }
      function Cg(e, t) {
        return 'string' == typeof t ? Eg(e, t) : t instanceof Xp ? t._internalPath : t._delegate._internalPath;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function kg(e) {
        if ('L' === e.limitType && 0 === e.explicitOrderBy.length)
          throw new li(ci.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');
      }
      class Og {}
      class Ng extends Og {}
      function Rg(e, t, ...n) {
        let r = [];
        t instanceof Og && r.push(t),
          (r = r.concat(n)),
          (function (e) {
            const t = e.filter(e => e instanceof Lg).length,
              n = e.filter(e => e instanceof Pg).length;
            if (t > 1 || (t > 0 && n > 0))
              throw new li(
                ci.INVALID_ARGUMENT,
                'InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.'
              );
          })(
            /**
