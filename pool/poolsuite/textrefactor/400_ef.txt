remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
              i.push(qc(e).J('collectionPathOverlayIndex', r));
            }),
            zi.waitFor(i)
          );
        }
        getOverlaysForCollection(e, t, n) {
          const r = Oa(),
            i = so(t),
            o = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], !0);
          return qc(e)
            .j('collectionPathOverlayIndex', o)
            .next(e => {
              for (const t of e) {
                const e = jc(this.serializer, t);
                r.set(e.getKey(), e);
              }
              return r;
            });
        }
        getOverlaysForCollectionGroup(e, t, n, r) {
          const i = Oa();
          let o;
          const s = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, Number.POSITIVE_INFINITY], !0);
          return qc(e)
            .X({ index: 'collectionGroupOverlayIndex', range: s }, (e, t, n) => {
              const s = jc(this.serializer, t);
              i.size() < r || s.largestBatchId === o ? (i.set(s.getKey(), s), (o = s.largestBatchId)) : n.done();
            })
            .next(() => i);
        }
        we(e, t) {
          return qc(e).put(
            (function (e, t, n) {
              const [r, i, o] = Mc(t, n.mutation.key);
              return {
                userId: t,
                collectionPath: i,
                documentId: o,
                collectionGroup: n.mutation.key.getCollectionGroup(),
                largestBatchId: n.largestBatchId,
                overlayMutation: cc(e.fe, n.mutation)
              };
            })(this.serializer, this.userId, t)
          );
        }
      }
      function qc(e) {
        return Lo(e, 'documentOverlays');
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class zc {
        constructor() {}
        _e(e, t) {
          this.me(e, t), t.ge();
        }
        me(e, t) {
          if ('nullValue' in e) this.ye(t, 5);
          else if ('booleanValue' in e) this.ye(t, 10), t.pe(e.booleanValue ? 1 : 0);
          else if ('integerValue' in e) this.ye(t, 15), t.pe(Xo(e.integerValue));
          else if ('doubleValue' in e) {
            const n = Xo(e.doubleValue);
            isNaN(n) ? this.ye(t, 13) : (this.ye(t, 15), io(n) ? t.pe(0) : t.pe(n));
          } else if ('timestampValue' in e) {
            const n = e.timestampValue;
            this.ye(t, 20), 'string' == typeof n ? t.Ie(n) : (t.Ie(`${n.seconds || ''}`), t.pe(n.nanos || 0));
          } else if ('stringValue' in e) this.Te(e.stringValue, t), this.Ee(t);
          else if ('bytesValue' in e) this.ye(t, 30), t.Ae(Jo(e.bytesValue)), this.Ee(t);
          else if ('referenceValue' in e) this.ve(e.referenceValue, t);
          else if ('geoPointValue' in e) {
            const n = e.geoPointValue;
            this.ye(t, 45), t.pe(n.latitude || 0), t.pe(n.longitude || 0);
          } else
            'mapValue' in e
              ? bs(e)
                ? this.ye(t, Number.MAX_SAFE_INTEGER)
                : (this.Re(e.mapValue, t), this.Ee(t))
              : 'arrayValue' in e
                ? (this.Pe(e.arrayValue, t), this.Ee(t))
                : oi();
        }
        Te(e, t) {
          this.ye(t, 25), this.be(e, t);
        }
        be(e, t) {
          t.Ie(e);
        }
        Re(e, t) {
          const n = e.fields || {};
          this.ye(t, 55);
          for (const r of Object.keys(n)) this.Te(r, t), this.me(n[r], t);
        }
        Pe(e, t) {
          const n = e.values || [];
          this.ye(t, 50);
          for (const r of n) this.me(r, t);
        }
        ve(e, t) {
          this.ye(t, 37),
            Ni.fromName(e).path.forEach(e => {
              this.ye(t, 60), this.be(e, t);
            });
        }
        ye(e, t) {
          e.pe(t);
        }
        Ee(e) {
          e.pe(2);
        }
      }
      function Gc(e) {
        if (0 === e) return 8;
        let t = 0;
        return e >> 4 == 0 && ((t += 4), (e <<= 4)), e >> 6 == 0 && ((t += 2), (e <<= 2)), e >> 7 == 0 && (t += 1), t;
      }
      function Wc(e) {
        const t =
          64 -
          (function (e) {
            let t = 0;
            for (let n = 0; n < 8; ++n) {
              const r = Gc(255 & e[n]);
              if (((t += r), 8 !== r)) break;
            }
            return t;
          })(e);
        return Math.ceil(t / 8);
      }
      zc.Ve = new zc();
      class Hc {
        constructor() {
          (this.buffer = new Uint8Array(1024)), (this.position = 0);
        }
        Se(e) {
          const t = e[Symbol.iterator]();
          let n = t.next();
          for (; !n.done; ) this.De(n.value), (n = t.next());
          this.Ce();
        }
        xe(e) {
          const t = e[Symbol.iterator]();
          let n = t.next();
          for (; !n.done; ) this.Ne(n.value), (n = t.next());
          this.ke();
        }
        Me(e) {
          for (const t of e) {
            const e = t.charCodeAt(0);
            if (e < 128) this.De(e);
            else if (e < 2048) this.De(960 | (e >>> 6)), this.De(128 | (63 & e));
            else if (t < '\ud800' || '\udbff' < t) this.De(480 | (e >>> 12)), this.De(128 | (63 & (e >>> 6))), this.De(128 | (63 & e));
            else {
              const e = t.codePointAt(0);
              this.De(240 | (e >>> 18)), this.De(128 | (63 & (e >>> 12))), this.De(128 | (63 & (e >>> 6))), this.De(128 | (63 & e));
            }
          }
          this.Ce();
        }
        $e(e) {
          for (const t of e) {
            const e = t.charCodeAt(0);
            if (e < 128) this.Ne(e);
            else if (e < 2048) this.Ne(960 | (e >>> 6)), this.Ne(128 | (63 & e));
            else if (t < '\ud800' || '\udbff' < t) this.Ne(480 | (e >>> 12)), this.Ne(128 | (63 & (e >>> 6))), this.Ne(128 | (63 & e));
            else {
              const e = t.codePointAt(0);
              this.Ne(240 | (e >>> 18)), this.Ne(128 | (63 & (e >>> 12))), this.Ne(128 | (63 & (e >>> 6))), this.Ne(128 | (63 & e));
            }
          }
          this.ke();
        }
        Oe(e) {
          const t = this.Fe(e),
            n = Wc(t);
          this.Be(1 + n), (this.buffer[this.position++] = 255 & n);
          for (let r = t.length - n; r < t.length; ++r) this.buffer[this.position++] = 255 & t[r];
        }
        Le(e) {
          const t = this.Fe(e),
            n = Wc(t);
          this.Be(1 + n), (this.buffer[this.position++] = ~(255 & n));
          for (let r = t.length - n; r < t.length; ++r) this.buffer[this.position++] = ~(255 & t[r]);
        }
        qe() {
          this.Ue(255), this.Ue(255);
        }
        Ke() {
          this.Ge(255), this.Ge(255);
        }
        reset() {
          this.position = 0;
        }
        seed(e) {
          this.Be(e.length), this.buffer.set(e, this.position), (this.position += e.length);
        }
        Qe() {
          return this.buffer.slice(0, this.position);
        }
        Fe(e) {
          const t = (function (e) {
              const t = new DataView(new ArrayBuffer(8));
              return t.setFloat64(0, e, !1), new Uint8Array(t.buffer);
            })(e),
            n = 0 != (128 & t[0]);
          t[0] ^= n ? 255 : 128;
          for (let r = 1; r < t.length; ++r) t[r] ^= n ? 255 : 0;
          return t;
        }
        De(e) {
          const t = 255 & e;
          0 === t ? (this.Ue(0), this.Ue(255)) : 255 === t ? (this.Ue(255), this.Ue(0)) : this.Ue(t);
        }
        Ne(e) {
          const t = 255 & e;
          0 === t ? (this.Ge(0), this.Ge(255)) : 255 === t ? (this.Ge(255), this.Ge(0)) : this.Ge(e);
        }
        Ce() {
          this.Ue(0), this.Ue(1);
        }
        ke() {
          this.Ge(0), this.Ge(1);
        }
        Ue(e) {
          this.Be(1), (this.buffer[this.position++] = e);
        }
        Ge(e) {
          this.Be(1), (this.buffer[this.position++] = ~e);
        }
        Be(e) {
          const t = e + this.position;
          if (t <= this.buffer.length) return;
          let n = 2 * this.buffer.length;
          n < t && (n = t);
          const r = new Uint8Array(n);
          r.set(this.buffer), (this.buffer = r);
        }
      }
      class Kc {
        constructor(e) {
          this.je = e;
        }
        Ae(e) {
          this.je.Se(e);
        }
        Ie(e) {
          this.je.Me(e);
        }
        pe(e) {
          this.je.Oe(e);
        }
        ge() {
          this.je.qe();
        }
      }
      class Qc {
        constructor(e) {
          this.je = e;
        }
        Ae(e) {
          this.je.xe(e);
        }
        Ie(e) {
          this.je.$e(e);
        }
        pe(e) {
          this.je.Le(e);
        }
        ge() {
          this.je.Ke();
        }
      }
      class Yc {
        constructor() {
          (this.je = new Hc()), (this.ze = new Kc(this.je)), (this.We = new Qc(this.je));
        }
        seed(e) {
          this.je.seed(e);
        }
        He(e) {
          return 0 === e ? this.ze : this.We;
        }
        Qe() {
          return this.je.Qe();
        }
        reset() {
          this.je.reset();
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Xc {
        constructor(e, t, n, r) {
          (this.indexId = e), (this.documentKey = t), (this.arrayValue = n), (this.directionalValue = r);
        }
        Je() {
          const e = this.directionalValue.length,
            t = 0 === e || 255 === this.directionalValue[e - 1] ? e + 1 : e,
            n = new Uint8Array(t);
          return (
            n.set(this.directionalValue, 0),
            t !== e ? n.set([0], this.directionalValue.length) : ++n[n.length - 1],
            new Xc(this.indexId, this.documentKey, this.arrayValue, n)
          );
        }
      }
      function Jc(e, t) {
        let n = e.indexId - t.indexId;
        return 0 !== n
          ? n
          : ((n = Zc(e.arrayValue, t.arrayValue)),
            0 !== n ? n : ((n = Zc(e.directionalValue, t.directionalValue)), 0 !== n ? n : Ni.comparator(e.documentKey, t.documentKey)));
      }
      function Zc(e, t) {
        for (let n = 0; n < e.length && n < t.length; ++n) {
          const r = e[n] - t[n];
          if (0 !== r) return r;
        }
        return e.length - t.length;
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class el {
        constructor(e) {
          (this.collectionId = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment()), (this.Ye = e.orderBy), (this.Xe = []);
          for (const t of e.filters) {
            const e = t;
            e.isInequality() ? (this.Ze = e) : this.Xe.push(e);
          }
        }
        tn(e) {
          si(e.collectionGroup === this.collectionId);
          const t = Pi(e);
          if (void 0 !== t && !this.en(t)) return !1;
          const n = Di(e);
          let r = new Set(),
            i = 0,
            o = 0;
          for (; i < n.length && this.en(n[i]); ++i) r = r.add(n[i].fieldPath.canonicalString());
          if (i === n.length) return !0;
          if (void 0 !== this.Ze) {
            if (!r.has(this.Ze.field.canonicalString())) {
              const e = n[i];
              if (!this.nn(this.Ze, e) || !this.sn(this.Ye[o++], e)) return !1;
            }
            ++i;
          }
          for (; i < n.length; ++i) {
            const e = n[i];
            if (o >= this.Ye.length || !this.sn(this.Ye[o++], e)) return !1;
          }
          return !0;
        }
        en(e) {
          for (const t of this.Xe) if (this.nn(t, e)) return !0;
          return !1;
        }
        nn(e, t) {
          if (void 0 === e || !e.field.isEqual(t.fieldPath)) return !1;
          const n = 'array-contains' === e.op || 'array-contains-any' === e.op;
          return (2 === t.kind) === n;
        }
