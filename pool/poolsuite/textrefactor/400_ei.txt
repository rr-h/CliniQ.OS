remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
            );
          });
        }
        lookupMutationBatch(e, t) {
          return Tl(e)
            .get(t)
            .next(e => (e ? (si(e.userId === this.userId), Rc(this.serializer, e)) : null));
        }
        Sn(e, t) {
          return this.Vn[t]
            ? zi.resolve(this.Vn[t])
            : this.lookupMutationBatch(e, t).next(e => {
                if (e) {
                  const n = e.keys();
                  return (this.Vn[t] = n), n;
                }
                return null;
              });
        }
        getNextMutationBatchAfterBatchId(e, t) {
          const n = t + 1,
            r = IDBKeyRange.lowerBound([this.userId, n]);
          let i = null;
          return Tl(e)
            .X({ index: 'userMutationsIndex', range: r }, (e, t, r) => {
              t.userId === this.userId && (si(t.batchId >= n), (i = Rc(this.serializer, t))), r.done();
            })
            .next(() => i);
        }
        getHighestUnacknowledgedBatchId(e) {
          const t = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
          let n = -1;
          return Tl(e)
            .X({ index: 'userMutationsIndex', range: t, reverse: !0 }, (e, t, r) => {
              (n = t.batchId), r.done();
            })
            .next(() => n);
        }
        getAllMutationBatches(e) {
          const t = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
          return Tl(e)
            .j('userMutationsIndex', t)
            .next(e => e.map(e => Rc(this.serializer, e)));
        }
        getAllMutationBatchesAffectingDocumentKey(e, t) {
          const n = ho(this.userId, t.path),
            r = IDBKeyRange.lowerBound(n),
            i = [];
          return Al(e)
            .X({ range: r }, (n, r, o) => {
              const [s, a, u] = n,
                c = co(a);
              if (s === this.userId && t.path.isEqual(c))
                return Tl(e)
                  .get(u)
                  .next(e => {
                    if (!e) throw oi();
                    si(e.userId === this.userId), i.push(Rc(this.serializer, e));
                  });
              o.done();
            })
            .next(() => i);
        }
        getAllMutationBatchesAffectingDocumentKeys(e, t) {
          let n = new $o(Ii);
          const r = [];
          return (
            t.forEach(t => {
              const i = ho(this.userId, t.path),
                o = IDBKeyRange.lowerBound(i),
                s = Al(e).X({ range: o }, (e, r, i) => {
                  const [o, s, a] = e,
                    u = co(s);
                  o === this.userId && t.path.isEqual(u) ? (n = n.add(a)) : i.done();
                });
              r.push(s);
            }),
            zi.waitFor(r).next(() => this.Dn(e, n))
          );
        }
        getAllMutationBatchesAffectingQuery(e, t) {
          const n = t.path,
            r = n.length + 1,
            i = ho(this.userId, n),
            o = IDBKeyRange.lowerBound(i);
          let s = new $o(Ii);
          return Al(e)
            .X({ range: o }, (e, t, i) => {
              const [o, a, u] = e,
                c = co(a);
              o === this.userId && n.isPrefixOf(c) ? c.length === r && (s = s.add(u)) : i.done();
            })
            .next(() => this.Dn(e, s));
        }
        Dn(e, t) {
          const n = [],
            r = [];
          return (
            t.forEach(t => {
              r.push(
                Tl(e)
                  .get(t)
                  .next(e => {
                    if (null === e) throw oi();
                    si(e.userId === this.userId), n.push(Rc(this.serializer, e));
                  })
              );
            }),
            zi.waitFor(r).next(() => n)
          );
        }
        removeMutationBatch(e, t) {
          return _l(e.ht, this.userId, t).next(
            n => (
              e.addOnCommittedListener(() => {
                this.Cn(t.batchId);
              }),
              zi.forEach(n, t => this.referenceDelegate.markPotentiallyOrphaned(e, t))
            )
          );
        }
        Cn(e) {
          delete this.Vn[e];
        }
        performConsistencyCheck(e) {
          return this.checkEmpty(e).next(t => {
            if (!t) return zi.resolve();
            const n = IDBKeyRange.lowerBound([this.userId]),
              r = [];
            return Al(e)
              .X({ range: n }, (e, t, n) => {
                if (e[0] === this.userId) {
                  const t = co(e[1]);
                  r.push(t);
                } else n.done();
              })
              .next(() => {
                si(0 === r.length);
              });
          });
        }
        containsKey(e, t) {
          return Sl(e, this.userId, t);
        }
        xn(e) {
          return xl(e)
            .get(this.userId)
            .next(e => e || { userId: this.userId, lastAcknowledgedBatchId: -1, lastStreamToken: '' });
        }
      }
      function Sl(e, t, n) {
        const r = ho(t, n.path),
          i = r[1],
          o = IDBKeyRange.lowerBound(r);
        let s = !1;
        return Al(e)
          .X({ range: o, Y: !0 }, (e, n, r) => {
            const [o, a, u] = e;
            o === t && a === i && (s = !0), r.done();
          })
          .next(() => s);
      }
      function Tl(e) {
        return Lo(e, 'mutations');
      }
      function Al(e) {
        return Lo(e, 'documentMutations');
      }
      function xl(e) {
        return Lo(e, 'mutationQueues');
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Cl {
        constructor(e) {
          this.Nn = e;
        }
        next() {
          return (this.Nn += 2), this.Nn;
        }
        static kn() {
          return new Cl(0);
        }
        static Mn() {
          return new Cl(-1);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class kl {
        constructor(e, t) {
          (this.referenceDelegate = e), (this.serializer = t);
        }
        allocateTargetId(e) {
          return this.$n(e).next(t => {
            const n = new Cl(t.highestTargetId);
            return (t.highestTargetId = n.next()), this.On(e, t).next(() => t.highestTargetId);
          });
        }
        getLastRemoteSnapshotVersion(e) {
          return this.$n(e).next(e => Ai.fromTimestamp(new Ti(e.lastRemoteSnapshotVersion.seconds, e.lastRemoteSnapshotVersion.nanoseconds)));
        }
        getHighestSequenceNumber(e) {
          return this.$n(e).next(e => e.highestListenSequenceNumber);
        }
        setTargetsMetadata(e, t, n) {
          return this.$n(e).next(
            r => (
              (r.highestListenSequenceNumber = t),
              n && (r.lastRemoteSnapshotVersion = n.toTimestamp()),
              t > r.highestListenSequenceNumber && (r.highestListenSequenceNumber = t),
              this.On(e, r)
            )
          );
        }
        addTargetData(e, t) {
          return this.Fn(e, t).next(() => this.$n(e).next(n => ((n.targetCount += 1), this.Bn(t, n), this.On(e, n))));
        }
        updateTargetData(e, t) {
          return this.Fn(e, t);
        }
        removeTargetData(e, t) {
          return this.removeMatchingKeysForTargetId(e, t.targetId)
            .next(() => Ol(e).delete(t.targetId))
            .next(() => this.$n(e))
            .next(t => (si(t.targetCount > 0), (t.targetCount -= 1), this.On(e, t)));
        }
        removeTargets(e, t, n) {
          let r = 0;
          const i = [];
          return Ol(e)
            .X((o, s) => {
              const a = Pc(s);
              a.sequenceNumber <= t && null === n.get(a.targetId) && (r++, i.push(this.removeTargetData(e, a)));
            })
            .next(() => zi.waitFor(i))
            .next(() => r);
        }
        forEachTarget(e, t) {
          return Ol(e).X((e, n) => {
            const r = Pc(n);
            t(r);
          });
        }
        $n(e) {
          return Nl(e)
            .get('targetGlobalKey')
            .next(e => (si(null !== e), e));
        }
        On(e, t) {
          return Nl(e).put('targetGlobalKey', t);
        }
        Fn(e, t) {
          return Ol(e).put(Dc(this.serializer, t));
        }
        Bn(e, t) {
          let n = !1;
          return (
            e.targetId > t.highestTargetId && ((t.highestTargetId = e.targetId), (n = !0)),
            e.sequenceNumber > t.highestListenSequenceNumber && ((t.highestListenSequenceNumber = e.sequenceNumber), (n = !0)),
            n
          );
        }
        getTargetCount(e) {
          return this.$n(e).next(e => e.targetCount);
        }
        getTargetData(e, t) {
          const n = ea(t),
            r = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
          let i = null;
          return Ol(e)
            .X({ range: r, index: 'queryTargetsIndex' }, (e, n, r) => {
              const o = Pc(n);
              ta(t, o.target) && ((i = o), r.done());
            })
            .next(() => i);
        }
        addMatchingKeys(e, t, n) {
          const r = [],
            i = Rl(e);
          return (
            t.forEach(t => {
              const o = so(t.path);
              r.push(i.put({ targetId: n, path: o })), r.push(this.referenceDelegate.addReference(e, n, t));
            }),
            zi.waitFor(r)
          );
        }
        removeMatchingKeys(e, t, n) {
          const r = Rl(e);
          return zi.forEach(t, t => {
            const i = so(t.path);
            return zi.waitFor([r.delete([n, i]), this.referenceDelegate.removeReference(e, n, t)]);
          });
        }
        removeMatchingKeysForTargetId(e, t) {
          const n = Rl(e),
            r = IDBKeyRange.bound([t], [t + 1], !1, !0);
          return n.delete(r);
        }
        getMatchingKeysForTargetId(e, t) {
          const n = IDBKeyRange.bound([t], [t + 1], !1, !0),
            r = Rl(e);
          let i = La();
          return r
            .X({ range: n, Y: !0 }, (e, t, n) => {
              const r = co(e[1]),
                o = new Ni(r);
              i = i.add(o);
            })
            .next(() => i);
        }
        containsKey(e, t) {
          const n = so(t.path),
            r = IDBKeyRange.bound([n], [Si(n)], !1, !0);
          let i = 0;
          return Rl(e)
            .X({ index: 'documentTargetsIndex', Y: !0, range: r }, ([e, t], n, r) => {
              0 !== e && (i++, r.done());
            })
            .next(() => i > 0);
        }
        le(e, t) {
          return Ol(e)
            .get(t)
            .next(e => (e ? Pc(e) : null));
        }
      }
      function Ol(e) {
        return Lo(e, 'targets');
      }
      function Nl(e) {
        return Lo(e, 'targetGlobal');
      }
      function Rl(e) {
        return Lo(e, 'targetDocuments');
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Pl([e, t], [n, r]) {
        const i = Ii(e, n);
        return 0 === i ? Ii(t, r) : i;
      }
      class Dl {
        constructor(e) {
          (this.Ln = e), (this.buffer = new $o(Pl)), (this.qn = 0);
        }
        Un() {
          return ++this.qn;
        }
        Kn(e) {
          const t = [e, this.Un()];
          if (this.buffer.size < this.Ln) this.buffer = this.buffer.add(t);
          else {
            const e = this.buffer.last();
            Pl(t, e) < 0 && (this.buffer = this.buffer.delete(e).add(t));
          }
        }
        get maxValue() {
          return this.buffer.last()[0];
        }
