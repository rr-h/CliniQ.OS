remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ Zn.receivers = [];
      class tr {
        constructor(e) {
          (this.target = e), (this.handlers = new Set());
        }
        removeMessageHandler(e) {
          e.messageChannel && (e.messageChannel.port1.removeEventListener('message', e.onMessage), e.messageChannel.port1.close()),
            this.handlers.delete(e);
        }
        async _send(e, t, n = 50) {
          const r = 'undefined' !== typeof MessageChannel ? new MessageChannel() : null;
          if (!r) throw new Error('connection_unavailable');
          let i, o;
          return new Promise((s, a) => {
            const u = er('', 20);
            r.port1.start();
            const c = setTimeout(() => {
              a(new Error('unsupported_event'));
            }, n);
            (o = {
              messageChannel: r,
              onMessage(e) {
                const t = e;
                if (t.data.eventId === u)
                  switch (t.data.status) {
                    case 'ack':
                      clearTimeout(c),
                        (i = setTimeout(() => {
                          a(new Error('timeout'));
                        }, 3e3));
                      break;
                    case 'done':
                      clearTimeout(i), s(t.data.response);
                      break;
                    default:
                      clearTimeout(c), clearTimeout(i), a(new Error('invalid_response'));
                      break;
                  }
              }
            }),
              this.handlers.add(o),
              r.port1.addEventListener('message', o.onMessage),
              this.target.postMessage({ eventType: e, eventId: u, data: t }, [r.port2]);
          }).finally(() => {
            o && this.removeMessageHandler(o);
          });
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function nr() {
        return window;
      }
      function rr(e) {
        nr().location.href = e;
      }
      /**
       * @license
       * Copyright 2020 Google LLC.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function ir() {
        return 'undefined' !== typeof nr()['WorkerGlobalScope'] && 'function' === typeof nr()['importScripts'];
      }
      async function or() {
        if (!(null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker)) return null;
        try {
          const e = await navigator.serviceWorker.ready;
          return e.active;
        } catch (e) {
          return null;
        }
      }
      function sr() {
        var e;
        return (
          (null === (e = null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker) || void 0 === e ? void 0 : e.controller) ||
          null
        );
      }
      function ar() {
        return ir() ? self : null;
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const ur = 'firebaseLocalStorageDb',
        cr = 1,
        lr = 'firebaseLocalStorage',
        hr = 'fbase_key';
      class fr {
        constructor(e) {
          this.request = e;
        }
        toPromise() {
          return new Promise((e, t) => {
            this.request.addEventListener('success', () => {
              e(this.request.result);
            }),
              this.request.addEventListener('error', () => {
                t(this.request.error);
              });
          });
        }
      }
      function dr(e, t) {
        return e.transaction([lr], t ? 'readwrite' : 'readonly').objectStore(lr);
      }
      function pr() {
        const e = indexedDB.deleteDatabase(ur);
        return new fr(e).toPromise();
      }
      function gr() {
        const e = indexedDB.open(ur, cr);
        return new Promise((t, n) => {
          e.addEventListener('error', () => {
            n(e.error);
          }),
            e.addEventListener('upgradeneeded', () => {
              const t = e.result;
              try {
                t.createObjectStore(lr, { keyPath: hr });
              } catch (r) {
                n(r);
              }
            }),
            e.addEventListener('success', async () => {
              const n = e.result;
              n.objectStoreNames.contains(lr) ? t(n) : (n.close(), await pr(), t(await gr()));
            });
        });
      }
      async function mr(e, t, n) {
        const r = dr(e, !0).put({ [hr]: t, value: n });
        return new fr(r).toPromise();
      }
      async function vr(e, t) {
        const n = dr(e, !1).get(t),
          r = await new fr(n).toPromise();
        return void 0 === r ? null : r.value;
      }
      function yr(e, t) {
        const n = dr(e, !0).delete(t);
        return new fr(n).toPromise();
      }
      const wr = 800,
        br = 3;
      class _r {
        constructor() {
          (this.type = 'LOCAL'),
            (this._shouldAllowMigration = !0),
            (this.listeners = {}),
            (this.localCache = {}),
            (this.pollTimer = null),
            (this.pendingWrites = 0),
            (this.receiver = null),
            (this.sender = null),
            (this.serviceWorkerReceiverAvailable = !1),
            (this.activeServiceWorker = null),
            (this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(
              () => {},
              () => {}
            ));
        }
        async _openDb() {
          return this.db || (this.db = await gr()), this.db;
        }
        async _withRetries(e) {
          let t = 0;
          while (1)
            try {
              const t = await this._openDb();
              return await e(t);
            } catch (n) {
              if (t++ > br) throw n;
              this.db && (this.db.close(), (this.db = void 0));
            }
        }
        async initializeServiceWorkerMessaging() {
          return ir() ? this.initializeReceiver() : this.initializeSender();
        }
        async initializeReceiver() {
          (this.receiver = Zn._getInstance(ar())),
            this.receiver._subscribe('keyChanged', async (e, t) => {
              const n = await this._poll();
              return { keyProcessed: n.includes(t.key) };
            }),
            this.receiver._subscribe('ping', async (e, t) => ['keyChanged']);
        }
        async initializeSender() {
          var e, t;
          if (((this.activeServiceWorker = await or()), !this.activeServiceWorker)) return;
          this.sender = new tr(this.activeServiceWorker);
          const n = await this.sender._send('ping', {}, 800);
          n &&
            (null === (e = n[0]) || void 0 === e ? void 0 : e.fulfilled) &&
            (null === (t = n[0]) || void 0 === t ? void 0 : t.value.includes('keyChanged')) &&
            (this.serviceWorkerReceiverAvailable = !0);
        }
        async notifyServiceWorker(e) {
          if (this.sender && this.activeServiceWorker && sr() === this.activeServiceWorker)
            try {
              await this.sender._send('keyChanged', { key: e }, this.serviceWorkerReceiverAvailable ? 800 : 50);
            } catch (t) {}
        }
        async _isAvailable() {
          try {
            if (!indexedDB) return !1;
            const e = await gr();
            return await mr(e, qn, '1'), await yr(e, qn), !0;
          } catch (e) {}
          return !1;
        }
        async _withPendingWrite(e) {
          this.pendingWrites++;
          try {
            await e();
          } finally {
            this.pendingWrites--;
          }
        }
        async _set(e, t) {
          return this._withPendingWrite(
            async () => (await this._withRetries(n => mr(n, e, t)), (this.localCache[e] = t), this.notifyServiceWorker(e))
          );
        }
        async _get(e) {
          const t = await this._withRetries(t => vr(t, e));
          return (this.localCache[e] = t), t;
        }
        async _remove(e) {
          return this._withPendingWrite(async () => (await this._withRetries(t => yr(t, e)), delete this.localCache[e], this.notifyServiceWorker(e)));
        }
        async _poll() {
          const e = await this._withRetries(e => {
            const t = dr(e, !1).getAll();
            return new fr(t).toPromise();
          });
          if (!e) return [];
          if (0 !== this.pendingWrites) return [];
          const t = [],
            n = new Set();
          for (const { fbase_key: r, value: i } of e)
            n.add(r), JSON.stringify(this.localCache[r]) !== JSON.stringify(i) && (this.notifyListeners(r, i), t.push(r));
          for (const r of Object.keys(this.localCache)) this.localCache[r] && !n.has(r) && (this.notifyListeners(r, null), t.push(r));
          return t;
        }
        notifyListeners(e, t) {
          this.localCache[e] = t;
          const n = this.listeners[e];
          if (n) for (const r of Array.from(n)) r(t);
        }
        startPolling() {
          this.stopPolling(), (this.pollTimer = setInterval(async () => this._poll(), wr));
        }
        stopPolling() {
          this.pollTimer && (clearInterval(this.pollTimer), (this.pollTimer = null));
        }
        _addListener(e, t) {
          0 === Object.keys(this.listeners).length && this.startPolling(),
            this.listeners[e] || ((this.listeners[e] = new Set()), this._get(e)),
            this.listeners[e].add(t);
        }
        _removeListener(e, t) {
          this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]),
            0 === Object.keys(this.listeners).length && this.stopPolling();
        }
      }
      _r.type = 'LOCAL';
      const Ir = _r;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Er(e, t) {
        return F(e, 'POST', '/v2/accounts/mfaSignIn:start', M(e, t));
      }
      function Sr(e, t) {
        return F(e, 'POST', '/v2/accounts/mfaSignIn:finalize', M(e, t));
      }
      function Tr(e, t) {
        return F(e, 'POST', '/v2/accounts/mfaSignIn:finalize', M(e, t));
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Ar = 500,
        xr = 6e4,
        Cr = 1e12;
      class kr {
        constructor(e) {
          (this.auth = e), (this.counter = Cr), (this._widgets = new Map());
        }
        render(e, t) {
          const n = this.counter;
          return this._widgets.set(n, new Or(e, this.auth.name, t || {})), this.counter++, n;
        }
        reset(e) {
          var t;
          const n = e || Cr;
          null === (t = this._widgets.get(n)) || void 0 === t || t.delete(), this._widgets.delete(n);
        }
        getResponse(e) {
          var t;
          const n = e || Cr;
          return (null === (t = this._widgets.get(n)) || void 0 === t ? void 0 : t.getResponse()) || '';
        }
        async execute(e) {
          var t;
          const n = e || Cr;
          return null === (t = this._widgets.get(n)) || void 0 === t || t.execute(), '';
        }
      }
      class Or {
        constructor(e, t, n) {
          (this.params = n),
            (this.timerId = null),
            (this.deleted = !1),
            (this.responseToken = null),
            (this.clickHandler = () => {
              this.execute();
            });
          const r = 'string' === typeof e ? document.getElementById(e) : e;
          S(r, 'argument-error', { appName: t }),
            (this.container = r),
            (this.isVisible = 'invisible' !== this.params.size),
            this.isVisible ? this.execute() : this.container.addEventListener('click', this.clickHandler);
        }
        getResponse() {
