remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Em {
        constructor(e, t) {
          (this._firestore = e), (this._commitHandler = t), (this._mutations = []), (this._committed = !1), (this._dataReader = sg(e));
        }
        set(e, t, n) {
          this._verifyNotCommitted();
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'WriteBatch.set', r._key, i, null !== r.converter, n);
          return this._mutations.push(o.toMutation(r._key, nu.none())), this;
        }
        update(e, t, n, ...r) {
          this._verifyNotCommitted();
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'WriteBatch.update', i._key, t, n, r)
                : pg(this._dataReader, 'WriteBatch.update', i._key, t)),
            this._mutations.push(o.toMutation(i._key, nu.exists(!0))),
            this
          );
        }
        delete(e) {
          this._verifyNotCommitted();
          const t = Sm(e, this._firestore);
          return (this._mutations = this._mutations.concat(new gu(t._key, nu.none()))), this;
        }
        commit() {
          return (
            this._verifyNotCommitted(), (this._committed = !0), this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
          );
        }
        _verifyNotCommitted() {
          if (this._committed) throw new li(ci.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() has been called.');
        }
      }
      function Sm(e, t) {
        if ((e = (0, u.m9)(e)).firestore !== t)
          throw new li(ci.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');
        return e;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tm extends class {
        constructor(e, t) {
          (this._firestore = e), (this._transaction = t), (this._dataReader = sg(e));
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new em(this._firestore);
          return this._transaction.lookup([t._key]).then(e => {
            if (!e || 1 !== e.length) return oi();
            const r = e[0];
            if (r.isFoundDocument()) return new Ag(this._firestore, n, r.key, r, t.converter);
            if (r.isNoDocument()) return new Ag(this._firestore, n, t._key, null, t.converter);
            throw oi();
          });
        }
        set(e, t, n) {
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'Transaction.set', r._key, i, null !== r.converter, n);
          return this._transaction.set(r._key, o), this;
        }
        update(e, t, n, ...r) {
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'Transaction.update', i._key, t, n, r)
                : pg(this._dataReader, 'Transaction.update', i._key, t)),
            this._transaction.update(i._key, o),
            this
          );
        }
        delete(e) {
          const t = Sm(e, this._firestore);
          return this._transaction.delete(t._key), this;
        }
      } {
        constructor(e, t) {
          super(e, t), (this._firestore = e);
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new um(this._firestore);
          return super.get(e).then(e => new nm(this._firestore, n, t._key, e._document, new tm(!1, !1), t.converter));
        }
      }
      function Am(e, t, n) {
        e = bp(e, Mp);
        const r = Object.assign(Object.assign({}, Im), n);
        return (
          (function (e) {
            if (e.maxAttempts < 1) throw new li(ci.INVALID_ARGUMENT, 'Max attempts must be at least 1');
          })(r),
          (function (e, t, n) {
            const r = new hi();
            return (
              e.asyncQueue.enqueueAndForget(async () => {
                const i = await np(e);
                new Gd(e.asyncQueue, i, n, t, r).run();
              }),
              r.promise
            );
          })(Fp(e), n => t(new Tm(e, n)), r)
        );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function xm() {
        return new ug('deleteField');
      }
      function Cm() {
        return new lg('serverTimestamp');
      }
      function km(...e) {
        return new hg('arrayUnion', e);
      }
      function Om(...e) {
        return new fg('arrayRemove', e);
      }
      function Nm(e) {
        return new dg('increment', e);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ !(function (e, t = !0) {
        !(function (e) {
          Xr = e;
        })(o.SDK_VERSION),
          (0, o._registerComponent)(
            new s.wA(
              'firestore',
              (e, { instanceIdentifier: n, options: r }) => {
                const i = e.getProvider('app').getImmediate(),
                  o = new Mp(
                    new gi(e.getProvider('auth-internal')),
                    new wi(e.getProvider('app-check-internal')),
                    (function (e, t) {
                      if (!Object.prototype.hasOwnProperty.apply(e.options, ['projectId']))
                        throw new li(ci.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
                      return new rs(e.options.projectId, t);
                    })(i, n),
                    i
                  );
                return (r = Object.assign({ useFetchStreams: t }, r)), o._setSettings(r), o;
              },
              'PUBLIC'
            ).setMultipleInstances(!0)
          ),
          (0, o.registerVersion)(Qr, '3.13.0', e),
          (0, o.registerVersion)(Qr, '3.13.0', 'esm2017');
      })();
      const Rm = '@firebase/firestore-compat',
        Pm = '0.3.12';
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function Dm(e, t) {
        if (void 0 === t) return { merge: !1 };
        if (void 0 !== t.mergeFields && void 0 !== t.merge)
          throw new li('invalid-argument', `Invalid options passed to function ${e}(): You cannot specify both "merge" and "mergeFields".`);
        return t;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Lm() {
        if ('undefined' === typeof Uint8Array) throw new li('unimplemented', 'Uint8Arrays are not available in this environment.');
      }
      function jm() {
        if (!Ho()) throw new li('unimplemented', 'Blobs are unavailable in Firestore in this environment.');
      }
      class Mm {
        constructor(e) {
          this._delegate = e;
        }
        static fromBase64String(e) {
          return jm(), new Mm(Yp.fromBase64String(e));
        }
        static fromUint8Array(e) {
          return Lm(), new Mm(Yp.fromUint8Array(e));
        }
        toBase64() {
          return jm(), this._delegate.toBase64();
        }
        toUint8Array() {
          return Lm(), this._delegate.toUint8Array();
        }
        isEqual(e) {
          return this._delegate.isEqual(e._delegate);
        }
        toString() {
          return 'Blob(base64: ' + this.toBase64() + ')';
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Fm(e) {
        return Um(e, ['next', 'error', 'complete']);
      }
      function Um(e, t) {
        if ('object' !== typeof e || null === e) return !1;
        const n = e;
        for (const r of t) if (r in n && 'function' === typeof n[r]) return !0;
        return !1;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Vm {
        enableIndexedDbPersistence(e, t) {
          return Vp(e._delegate, { forceOwnership: t });
        }
        enableMultiTabIndexedDbPersistence(e) {
          return Bp(e._delegate);
        }
        clearIndexedDbPersistence(e) {
          return qp(e._delegate);
        }
      }
      class Bm {
        constructor(e, t, n) {
          (this._delegate = t),
            (this._persistenceProvider = n),
            (this.INTERNAL = { delete: () => this.terminate() }),
            e instanceof rs || (this._appCompat = e);
        }
        get _databaseId() {
          return this._delegate._databaseId;
        }
        settings(e) {
          const t = this._delegate._getSettings();
          e.merge ||
            t.host === e.host ||
            ri('You are overriding the original host. If you did not intend to override your settings, use {merge: true}.'),
            e.merge && ((e = Object.assign(Object.assign({}, t), e)), delete e.merge),
            this._delegate._setSettings(e);
        }
        useEmulator(e, t, n = {}) {
          Sp(this._delegate, e, t, n);
        }
        enableNetwork() {
          return Gp(this._delegate);
        }
        disableNetwork() {
          return Wp(this._delegate);
        }
        enablePersistence(e) {
          let t = !1,
            n = !1;
          return (
            e && ((t = !!e.synchronizeTabs), (n = !!e.experimentalForceOwningTab), mp('synchronizeTabs', t, 'experimentalForceOwningTab', n)),
            t ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, n)
          );
        }
        clearPersistence() {
          return this._persistenceProvider.clearIndexedDbPersistence(this);
        }
        terminate() {
          return (
            this._appCompat && (this._appCompat._removeServiceInstance('firestore-compat'), this._appCompat._removeServiceInstance('firestore')),
            this._delegate._delete()
          );
        }
        waitForPendingWrites() {
          return zp(this._delegate);
        }
        onSnapshotsInSync(e) {
          return wm(this._delegate, e);
        }
        get app() {
          if (!this._appCompat) throw new li('failed-precondition', "Firestore was not initialized using the Firebase SDK. 'app' is not available");
          return this._appCompat;
        }
        collection(e) {
          try {
            return new nv(this, Cp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collection()', 'Firestore.collection()');
          }
