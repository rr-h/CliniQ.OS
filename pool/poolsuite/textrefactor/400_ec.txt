remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
          if (e.length > 0 && 0 === this.hashCount) throw new Ru(`Invalid hash count: ${n}`);
          if (0 === e.length && 0 !== t) throw new Ru(`Invalid padding when bitmap length is 0: ${t}`);
          (this.It = 8 * e.length - t), (this.Tt = Kr.fromNumber(this.It));
        }
        Et(e, t, n) {
          let r = e.add(t.multiply(Kr.fromNumber(n)));
          return 1 === r.compare(Cu) && (r = new Kr([r.getBits(0), r.getBits(1)], 0)), r.modulo(this.Tt).toNumber();
        }
        At(e) {
          return 0 != (this.bitmap[Math.floor(e / 8)] & (1 << e % 8));
        }
        vt(e) {
          if (0 === this.It) return !1;
          const t = ku(e),
            [n, r] = Ou(t);
          for (let i = 0; i < this.hashCount; i++) {
            const e = this.Et(n, r, i);
            if (!this.At(e)) return !1;
          }
          return !0;
        }
        static create(e, t, n) {
          const r = e % 8 == 0 ? 0 : 8 - (e % 8),
            i = new Uint8Array(Math.ceil(e / 8)),
            o = new Nu(i, r, t);
          return n.forEach(e => o.insert(e)), o;
        }
        insert(e) {
          if (0 === this.It) return;
          const t = ku(e),
            [n, r] = Ou(t);
          for (let i = 0; i < this.hashCount; i++) {
            const e = this.Et(n, r, i);
            this.Rt(e);
          }
        }
        Rt(e) {
          const t = Math.floor(e / 8),
            n = e % 8;
          this.bitmap[t] |= 1 << n;
        }
      }
      class Ru extends Error {
        constructor() {
          super(...arguments), (this.name = 'BloomFilterError');
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Pu {
        constructor(e, t, n, r, i) {
          (this.snapshotVersion = e),
            (this.targetChanges = t),
            (this.targetMismatches = n),
            (this.documentUpdates = r),
            (this.resolvedLimboDocuments = i);
        }
        static createSynthesizedRemoteEventForCurrentChange(e, t, n) {
          const r = new Map();
          return r.set(e, Du.createSynthesizedTargetChangeForCurrentChange(e, t, n)), new Pu(Ai.min(), r, new Uo(Ii), Aa(), La());
        }
      }
      class Du {
        constructor(e, t, n, r, i) {
          (this.resumeToken = e), (this.current = t), (this.addedDocuments = n), (this.modifiedDocuments = r), (this.removedDocuments = i);
        }
        static createSynthesizedTargetChangeForCurrentChange(e, t, n) {
          return new Du(n, t, La(), La(), La());
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Lu {
        constructor(e, t, n, r) {
          (this.Pt = e), (this.removedTargetIds = t), (this.key = n), (this.bt = r);
        }
      }
      class ju {
        constructor(e, t) {
          (this.targetId = e), (this.Vt = t);
        }
      }
      class Mu {
        constructor(e, t, n = Ko.EMPTY_BYTE_STRING, r = null) {
          (this.state = e), (this.targetIds = t), (this.resumeToken = n), (this.cause = r);
        }
      }
      class Fu {
        constructor() {
          (this.St = 0), (this.Dt = Bu()), (this.Ct = Ko.EMPTY_BYTE_STRING), (this.xt = !1), (this.Nt = !0);
        }
        get current() {
          return this.xt;
        }
        get resumeToken() {
          return this.Ct;
        }
        get kt() {
          return 0 !== this.St;
        }
        get Mt() {
          return this.Nt;
        }
        $t(e) {
          e.approximateByteSize() > 0 && ((this.Nt = !0), (this.Ct = e));
        }
        Ot() {
          let e = La(),
            t = La(),
            n = La();
          return (
            this.Dt.forEach((r, i) => {
              switch (i) {
                case 0:
                  e = e.add(r);
                  break;
                case 2:
                  t = t.add(r);
                  break;
                case 1:
                  n = n.add(r);
                  break;
                default:
                  oi();
              }
            }),
            new Du(this.Ct, this.xt, e, t, n)
          );
        }
        Ft() {
          (this.Nt = !1), (this.Dt = Bu());
        }
        Bt(e, t) {
          (this.Nt = !0), (this.Dt = this.Dt.insert(e, t));
        }
        Lt(e) {
          (this.Nt = !0), (this.Dt = this.Dt.remove(e));
        }
        qt() {
          this.St += 1;
        }
        Ut() {
          this.St -= 1;
        }
        Kt() {
          (this.Nt = !0), (this.xt = !0);
        }
      }
      class Uu {
        constructor(e) {
          (this.Gt = e), (this.Qt = new Map()), (this.jt = Aa()), (this.zt = Vu()), (this.Wt = new Uo(Ii));
        }
        Ht(e) {
          for (const t of e.Pt) e.bt && e.bt.isFoundDocument() ? this.Jt(t, e.bt) : this.Yt(t, e.key, e.bt);
          for (const t of e.removedTargetIds) this.Yt(t, e.key, e.bt);
        }
        Xt(e) {
          this.forEachTarget(e, t => {
            const n = this.Zt(t);
            switch (e.state) {
              case 0:
                this.te(t) && n.$t(e.resumeToken);
                break;
              case 1:
                n.Ut(), n.kt || n.Ft(), n.$t(e.resumeToken);
                break;
              case 2:
                n.Ut(), n.kt || this.removeTarget(t);
                break;
              case 3:
                this.te(t) && (n.Kt(), n.$t(e.resumeToken));
                break;
              case 4:
                this.te(t) && (this.ee(t), n.$t(e.resumeToken));
                break;
              default:
                oi();
            }
          });
        }
        forEachTarget(e, t) {
          e.targetIds.length > 0
            ? e.targetIds.forEach(t)
            : this.Qt.forEach((e, n) => {
                this.te(n) && t(n);
              });
        }
        ne(e) {
          var t;
          const n = e.targetId,
            r = e.Vt.count,
            i = this.se(n);
          if (i) {
            const o = i.target;
            if (na(o))
              if (0 === r) {
                const e = new Ni(o.path);
                this.Yt(n, e, xs.newNoDocument(e, Ai.min()));
              } else si(1 === r);
            else {
              const i = this.ie(n);
              if (i !== r) {
                const r = this.re(e, i);
                if (0 !== r) {
                  this.ee(n);
                  const e = 2 === r ? 'TargetPurposeExistenceFilterMismatchBloom' : 'TargetPurposeExistenceFilterMismatch';
                  this.Wt = this.Wt.insert(n, e);
                }
                null === (t = Tu.instance) ||
                  void 0 === t ||
                  t.notifyOnExistenceFilterMismatch(
                    (function (e, t, n) {
                      var r, i, o, s, a, u;
                      const c = { localCacheCount: t, existenceFilterCount: n.count },
                        l = n.unchangedNames;
                      return (
                        l &&
                          (c.bloomFilter = {
                            applied: 0 === e,
                            hashCount: null !== (r = null == l ? void 0 : l.hashCount) && void 0 !== r ? r : 0,
                            bitmapLength:
                              null !==
                                (s =
                                  null === (o = null === (i = null == l ? void 0 : l.bits) || void 0 === i ? void 0 : i.bitmap) || void 0 === o
                                    ? void 0
                                    : o.length) && void 0 !== s
                                ? s
                                : 0,
                            padding:
                              null !== (u = null === (a = null == l ? void 0 : l.bits) || void 0 === a ? void 0 : a.padding) && void 0 !== u ? u : 0
                          }),
                        c
                      );
                    })(
                      /**
                       * @license
                       * Copyright 2017 Google LLC
                       *
                       * Licensed under the Apache License, Version 2.0 (the "License");
                       * you may not use this file except in compliance with the License.
                       * You may obtain a copy of the License at
                       *
                       *   http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */ r,
                      i,
                      e.Vt
                    )
                  );
              }
            }
          }
        }
        re(e, t) {
          const { unchangedNames: n, count: r } = e.Vt;
          if (!n || !n.bits) return 1;
          const {
            bits: { bitmap: i = '', padding: o = 0 },
            hashCount: s = 0
          } = n;
          let a, u;
          try {
            a = Jo(i).toUint8Array();
          } catch (e) {
            if (e instanceof Wo)
              return (
                ri(
                  'Decoding the base64 bloom filter in existence filter failed (' +
                    e.message +
                    '); ignoring the bloom filter and falling back to full re-query.'
                ),
                1
              );
            throw e;
          }
          try {
            u = new Nu(a, o, s);
          } catch (e) {
            return ri(e instanceof Ru ? 'BloomFilter error: ' : 'Applying bloom filter failed: ', e), 1;
          }
          return 0 === u.It ? 1 : r !== t - this.oe(e.targetId, u) ? 2 : 0;
        }
        oe(e, t) {
          const n = this.Gt.getRemoteKeysForTarget(e);
          let r = 0;
          return (
            n.forEach(n => {
              const i = this.Gt.ue(),
                o = `projects/${i.projectId}/databases/${i.database}/documents/${n.path.canonicalString()}`;
              t.vt(o) || (this.Yt(e, n, null), r++);
            }),
            r
          );
        }
        ce(e) {
          const t = new Map();
          this.Qt.forEach((n, r) => {
            const i = this.se(r);
            if (i) {
              if (n.current && na(i.target)) {
                const t = new Ni(i.target.path);
                null !== this.jt.get(t) || this.ae(r, t) || this.Yt(r, t, xs.newNoDocument(t, e));
              }
              n.Mt && (t.set(r, n.Ot()), n.Ft());
            }
          });
          let n = La();
          this.zt.forEach((e, t) => {
            let r = !0;
            t.forEachWhile(e => {
              const t = this.se(e);
              return !t || 'TargetPurposeLimboResolution' === t.purpose || ((r = !1), !1);
            }),
              r && (n = n.add(e));
          }),
            this.jt.forEach((t, n) => n.setReadTime(e));
          const r = new Pu(e, t, this.Wt, this.jt, n);
          return (this.jt = Aa()), (this.zt = Vu()), (this.Wt = new Uo(Ii)), r;
        }
        Jt(e, t) {
          if (!this.te(e)) return;
          const n = this.ae(e, t.key) ? 2 : 0;
          this.Zt(e).Bt(t.key, n), (this.jt = this.jt.insert(t.key, t)), (this.zt = this.zt.insert(t.key, this.he(t.key).add(e)));
        }
        Yt(e, t, n) {
          if (!this.te(e)) return;
          const r = this.Zt(e);
          this.ae(e, t) ? r.Bt(t, 1) : r.Lt(t), (this.zt = this.zt.insert(t, this.he(t).delete(e))), n && (this.jt = this.jt.insert(t, n));
        }
        removeTarget(e) {
          this.Qt.delete(e);
        }
        ie(e) {
          const t = this.Zt(e).Ot();
          return this.Gt.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size;
        }
        qt(e) {
          this.Zt(e).qt();
        }
        Zt(e) {
          let t = this.Qt.get(e);
          return t || ((t = new Fu()), this.Qt.set(e, t)), t;
        }
        he(e) {
          let t = this.zt.get(e);
          return t || ((t = new $o(Ii)), (this.zt = this.zt.insert(e, t))), t;
        }
        te(e) {
          const t = null !== this.se(e);
          return t || ti('WatchChangeAggregator', 'Detected inactive target', e), t;
        }
        se(e) {
          const t = this.Qt.get(e);
          return t && t.kt ? null : this.Gt.le(e);
        }
        ee(e) {
          this.Qt.set(e, new Fu()),
            this.Gt.getRemoteKeysForTarget(e).forEach(t => {
              this.Yt(e, t, null);
            });
        }
        ae(e, t) {
          return this.Gt.getRemoteKeysForTarget(e).has(t);
        }
      }
      function Vu() {
        return new Uo(Ni.comparator);
      }
      function Bu() {
