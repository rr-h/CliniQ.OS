remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
      }
      function fh(e) {
        return Lo(e, 'owner');
      }
      function dh(e) {
        return Lo(e, 'clientMetadata');
      }
      function ph(e, t) {
        let n = e.projectId;
        return e.isDefaultDatabase || (n += '.' + e.database), 'firestore/' + t + '/' + n + '/';
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class gh {
        constructor(e, t, n, r) {
          (this.targetId = e), (this.fromCache = t), (this.Fi = n), (this.Bi = r);
        }
        static Li(e, t) {
          let n = La(),
            r = La();
          for (const i of t.docChanges)
            switch (i.type) {
              case 0:
                n = n.add(i.doc.key);
                break;
              case 1:
                r = r.add(i.doc.key);
            }
          return new gh(e, t.fromCache, n, r);
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class mh {
        constructor() {
          this.qi = !1;
        }
        initialize(e, t) {
          (this.Ui = e), (this.indexManager = t), (this.qi = !0);
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          return this.Ki(e, t)
            .next(i => i || this.Gi(e, t, r, n))
            .next(n => n || this.Qi(e, t));
        }
        Ki(e, t) {
          if (ca(t)) return zi.resolve(null);
          let n = pa(t);
          return this.indexManager.getIndexType(e, n).next(r =>
            0 === r
              ? null
              : (null !== t.limit && 1 === r && ((t = ma(t, null, 'F')), (n = pa(t))),
                this.indexManager.getDocumentsMatchingTarget(e, n).next(r => {
                  const i = La(...r);
                  return this.Ui.getDocuments(e, i).next(r =>
                    this.indexManager.getMinOffset(e, n).next(n => {
                      const o = this.ji(t, r);
                      return this.zi(t, o, i, n.readTime) ? this.Ki(e, ma(t, null, 'F')) : this.Wi(e, o, t, n);
                    })
                  );
                }))
          );
        }
        Gi(e, t, n, r) {
          return ca(t) || r.isEqual(Ai.min())
            ? this.Qi(e, t)
            : this.Ui.getDocuments(e, n).next(i => {
                const o = this.ji(t, i);
                return this.zi(t, o, n, r)
                  ? this.Qi(e, t)
                  : (Zr() <= a['in'].DEBUG && ti('QueryEngine', 'Re-using previous result from %s to execute query: %s', r.toString(), wa(t)),
                    this.Wi(e, o, t, Mi(r, -1)));
              });
        }
        ji(e, t) {
          let n = new $o(Ia(e));
          return (
            t.forEach((t, r) => {
              ba(e, r) && (n = n.add(r));
            }),
            n
          );
        }
        zi(e, t, n, r) {
          if (null === e.limit) return !1;
          if (n.size !== t.size) return !0;
          const i = 'F' === e.limitType ? t.last() : t.first();
          return !!i && (i.hasPendingWrites || i.version.compareTo(r) > 0);
        }
        Qi(e, t) {
          return (
            Zr() <= a['in'].DEBUG && ti('QueryEngine', 'Using full collection scan to execute query:', wa(t)),
            this.Ui.getDocumentsMatchingQuery(e, t, Ui.min())
          );
        }
        Wi(e, t, n, r) {
          return this.Ui.getDocumentsMatchingQuery(e, n, r).next(
            e => (
              t.forEach(t => {
                e = e.insert(t.key, t);
              }),
              e
            )
          );
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class vh {
        constructor(e, t, n, r) {
          (this.persistence = e),
            (this.Hi = t),
            (this.serializer = r),
            (this.Ji = new Uo(Ii)),
            (this.Yi = new Sa(e => ea(e), ta)),
            (this.Xi = new Map()),
            (this.Zi = e.getRemoteDocumentCache()),
            (this.Bs = e.getTargetCache()),
            (this.qs = e.getBundleCache()),
            this.tr(n);
        }
        tr(e) {
          (this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e)),
            (this.indexManager = this.persistence.getIndexManager(e)),
            (this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager)),
            (this.localDocuments = new Yl(this.Zi, this.mutationQueue, this.documentOverlayCache, this.indexManager)),
            this.Zi.setIndexManager(this.indexManager),
            this.Hi.initialize(this.localDocuments, this.indexManager);
        }
        collectGarbage(e) {
          return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', t => e.collect(t, this.Ji));
        }
      }
      function yh(e, t, n, r) {
        return new vh(e, t, n, r);
      }
      async function wh(e, t) {
        const n = ui(e);
        return await n.persistence.runTransaction('Handle user change', 'readonly', e => {
          let r;
          return n.mutationQueue
            .getAllMutationBatches(e)
            .next(i => ((r = i), n.tr(t), n.mutationQueue.getAllMutationBatches(e)))
            .next(t => {
              const i = [],
                o = [];
              let s = La();
              for (const e of r) {
                i.push(e.batchId);
                for (const t of e.mutations) s = s.add(t.key);
              }
              for (const e of t) {
                o.push(e.batchId);
                for (const t of e.mutations) s = s.add(t.key);
              }
              return n.localDocuments.getDocuments(e, s).next(e => ({ er: e, removedBatchIds: i, addedBatchIds: o }));
            });
        });
      }
      function bh(e, t) {
        const n = ui(e);
        return n.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', e => {
          const r = t.batch.keys(),
            i = n.Zi.newChangeBuffer({ trackRemovals: !0 });
          return (function (e, t, n, r) {
            const i = n.batch,
              o = i.keys();
            let s = zi.resolve();
            return (
              o.forEach(e => {
                s = s
                  .next(() => r.getEntry(t, e))
                  .next(t => {
                    const o = n.docVersions.get(e);
                    si(null !== o),
                      t.version.compareTo(o) < 0 &&
                        (i.applyToRemoteDocument(t, n), t.isValidDocument() && (t.setReadTime(n.commitVersion), r.addEntry(t)));
                  });
              }),
              s.next(() => e.mutationQueue.removeMutationBatch(t, i))
            );
          })(n, e, t, i)
            .next(() => i.apply(e))
            .next(() => n.mutationQueue.performConsistencyCheck(e))
            .next(() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t.batch.batchId))
            .next(() =>
              n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(
                e,
                (function (e) {
                  let t = La();
                  for (let n = 0; n < e.mutationResults.length; ++n)
                    e.mutationResults[n].transformResults.length > 0 && (t = t.add(e.batch.mutations[n].key));
                  return t;
                })(t)
              )
            )
            .next(() => n.localDocuments.getDocuments(e, r));
        });
      }
      function _h(e) {
        const t = ui(e);
        return t.persistence.runTransaction('Get last remote snapshot version', 'readonly', e => t.Bs.getLastRemoteSnapshotVersion(e));
      }
      function Ih(e, t) {
        const n = ui(e),
          r = t.snapshotVersion;
        let i = n.Ji;
        return n.persistence
          .runTransaction('Apply remote event', 'readwrite-primary', e => {
            const o = n.Zi.newChangeBuffer({ trackRemovals: !0 });
            i = n.Ji;
            const s = [];
            t.targetChanges.forEach((o, a) => {
              const u = i.get(a);
              if (!u) return;
              s.push(n.Bs.removeMatchingKeys(e, o.removedDocuments, a).next(() => n.Bs.addMatchingKeys(e, o.addedDocuments, a)));
              let c = u.withSequenceNumber(e.currentSequenceNumber);
              null !== t.targetMismatches.get(a)
                ? (c = c.withResumeToken(Ko.EMPTY_BYTE_STRING, Ai.min()).withLastLimboFreeSnapshotVersion(Ai.min()))
                : o.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(o.resumeToken, r)),
                (i = i.insert(a, c)),
                (function (e, t, n) {
                  return (
                    0 === e.resumeToken.approximateByteSize() ||
                    t.snapshotVersion.toMicroseconds() - e.snapshotVersion.toMicroseconds() >= 3e8 ||
                    n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size > 0
                  );
                })(u, c, o) && s.push(n.Bs.updateTargetData(e, c));
            });
            let a = Aa(),
              u = La();
            if (
              (t.documentUpdates.forEach(r => {
                t.resolvedLimboDocuments.has(r) && s.push(n.persistence.referenceDelegate.updateLimboDocument(e, r));
              }),
              s.push(
                Eh(e, o, t.documentUpdates).next(e => {
                  (a = e.nr), (u = e.sr);
                })
              ),
              !r.isEqual(Ai.min()))
            ) {
              const t = n.Bs.getLastRemoteSnapshotVersion(e).next(t => n.Bs.setTargetsMetadata(e, e.currentSequenceNumber, r));
              s.push(t);
            }
            return zi
              .waitFor(s)
              .next(() => o.apply(e))
              .next(() => n.localDocuments.getLocalViewOfDocuments(e, a, u))
              .next(() => a);
          })
          .then(e => ((n.Ji = i), e));
      }
      function Eh(e, t, n) {
        let r = La(),
          i = La();
        return (
          n.forEach(e => (r = r.add(e))),
          t.getEntries(e, r).next(e => {
            let r = Aa();
            return (
              n.forEach((n, o) => {
                const s = e.get(n);
                o.isFoundDocument() !== s.isFoundDocument() && (i = i.add(n)),
                  o.isNoDocument() && o.version.isEqual(Ai.min())
                    ? (t.removeEntry(n, o.readTime), (r = r.insert(n, o)))
                    : !s.isValidDocument() || o.version.compareTo(s.version) > 0 || (0 === o.version.compareTo(s.version) && s.hasPendingWrites)
                      ? (t.addEntry(o), (r = r.insert(n, o)))
                      : ti('LocalStore', 'Ignoring outdated watch update for ', n, '. Current version:', s.version, ' Watch version:', o.version);
              }),
              { nr: r, sr: i }
            );
          })
        );
      }
      function Sh(e, t) {
        const n = ui(e);
        return n.persistence.runTransaction(
          'Get next mutation batch',
          'readonly',
          e => (void 0 === t && (t = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(e, t))
        );
      }
      function Th(e, t) {
        const n = ui(e);
        return n.persistence
          .runTransaction('Allocate target', 'readwrite', e => {
            let r;
            return n.Bs.getTargetData(e, t).next(i =>
              i
                ? ((r = i), zi.resolve(r))
                : n.Bs.allocateTargetId(e).next(
                    i => ((r = new Tc(t, i, 'TargetPurposeListen', e.currentSequenceNumber)), n.Bs.addTargetData(e, r).next(() => r))
                  )
            );
          })
          .then(e => {
            const r = n.Ji.get(e.targetId);
            return (
              (null === r || e.snapshotVersion.compareTo(r.snapshotVersion) > 0) && ((n.Ji = n.Ji.insert(e.targetId, e)), n.Yi.set(t, e.targetId)), e
            );
          });
      }
      async function Ah(e, t, n) {
        const r = ui(e),
          i = r.Ji.get(t),
          o = n ? 'readwrite' : 'readwrite-primary';
        try {
          n || (await r.persistence.runTransaction('Release target', o, e => r.persistence.referenceDelegate.removeTarget(e, i)));
        } catch (e) {
          if (!Qi(e)) throw e;
          ti('LocalStore', `Failed to update sequence numbers for target ${t}: ${e}`);
        }
        (r.Ji = r.Ji.remove(t)), r.Yi.delete(i.target);
      }
      function xh(e, t, n) {
        const r = ui(e);
        let i = Ai.min(),
          o = La();
        return r.persistence.runTransaction('Execute query', 'readonly', e =>
          (function (e, t, n) {
            const r = ui(e),
              i = r.Yi.get(n);
            return void 0 !== i ? zi.resolve(r.Ji.get(i)) : r.Bs.getTargetData(t, n);
          })(r, e, pa(t))
            .next(t => {
              if (t)
                return (
                  (i = t.lastLimboFreeSnapshotVersion),
                  r.Bs.getMatchingKeysForTargetId(e, t.targetId).next(e => {
                    o = e;
                  })
                );
            })
            .next(() => r.Hi.getDocumentsMatchingQuery(e, t, n ? i : Ai.min(), n ? o : La()))
            .next(e => (Oh(r, _a(t), e), { documents: e, ir: o }))
        );
      }
      function Ch(e, t) {
        const n = ui(e),
          r = ui(n.Bs),
          i = n.Ji.get(t);
        return i
          ? Promise.resolve(i.target)
          : n.persistence.runTransaction('Get target data', 'readonly', e => r.le(e, t).next(e => (e ? e.target : null)));
      }
      function kh(e, t) {
        const n = ui(e),
          r = n.Xi.get(t) || Ai.min();
        return n.persistence
          .runTransaction('Get new document changes', 'readonly', e => n.Zi.getAllFromCollectionGroup(e, t, Mi(r, -1), Number.MAX_SAFE_INTEGER))
          .then(e => (Oh(n, t, e), e));
      }
      function Oh(e, t, n) {
        let r = e.Xi.get(t) || Ai.min();
        n.forEach((e, t) => {
          t.readTime.compareTo(r) > 0 && (r = t.readTime);
        }),
          e.Xi.set(t, r);
      }
