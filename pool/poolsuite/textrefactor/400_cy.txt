remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
                  n(e);
                });
            });
          }
          function r(t, n, r) {
            const i = window.grecaptcha;
            De(i)
              ? i.enterprise.ready(() => {
                  i.enterprise
                    .execute(t, { action: e })
                    .then(e => {
                      n(e);
                    })
                    .catch(() => {
                      n(Be);
                    });
                })
              : r(Error('No reCAPTCHA enterprise script loaded.'));
          }
          return new Promise((e, i) => {
            n(this.auth)
              .then(n => {
                if (!t && De(window.grecaptcha)) r(n, e, i);
                else {
                  if ('undefined' === typeof window) return void i(new Error('RecaptchaVerifier is only supported in browser'));
                  Me(Ue + n)
                    .then(() => {
                      r(n, e, i);
                    })
                    .catch(e => {
                      i(e);
                    });
                }
              })
              .catch(e => {
                i(e);
              });
          });
        }
      }
      async function qe(e, t, n, r = !1) {
        const i = new $e(e);
        let o;
        try {
          o = await i.verify(n);
        } catch (a) {
          o = await i.verify(n, !0);
        }
        const s = Object.assign({}, t);
        return (
          r ? Object.assign(s, { captchaResp: o }) : Object.assign(s, { captchaResponse: o }),
          Object.assign(s, { clientType: 'CLIENT_TYPE_WEB' }),
          Object.assign(s, { recaptchaVersion: 'RECAPTCHA_ENTERPRISE' }),
          s
        );
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ze {
        constructor(e) {
          (this.auth = e), (this.queue = []);
        }
        pushCallback(e, t) {
          const n = t =>
            new Promise((n, r) => {
              try {
                const r = e(t);
                n(r);
              } catch (i) {
                r(i);
              }
            });
          (n.onAbort = t), this.queue.push(n);
          const r = this.queue.length - 1;
          return () => {
            this.queue[r] = () => Promise.resolve();
          };
        }
        async runMiddleware(e) {
          if (this.auth.currentUser === e) return;
          const t = [];
          try {
            for (const n of this.queue) await n(e), n.onAbort && t.push(n.onAbort);
          } catch (n) {
            t.reverse();
            for (const e of t)
              try {
                e();
              } catch (r) {}
            throw this.auth._errorFactory.create('login-blocked', { originalMessage: null === n || void 0 === n ? void 0 : n.message });
          }
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ge {
        constructor(e, t, n, r) {
          (this.app = e),
            (this.heartbeatServiceProvider = t),
            (this.appCheckServiceProvider = n),
            (this.config = r),
            (this.currentUser = null),
            (this.emulatorConfig = null),
            (this.operations = Promise.resolve()),
            (this.authStateSubscription = new He(this)),
            (this.idTokenSubscription = new He(this)),
            (this.beforeStateQueue = new ze(this)),
            (this.redirectUser = null),
            (this.isProactiveRefreshEnabled = !1),
            (this._canInitEmulator = !0),
            (this._isInitialized = !1),
            (this._deleted = !1),
            (this._initializationPromise = null),
            (this._popupRedirectResolver = null),
            (this._errorFactory = g),
            (this._agentRecaptchaConfig = null),
            (this._tenantRecaptchaConfigs = {}),
            (this.lastNotifiedUid = void 0),
            (this.languageCode = null),
            (this.tenantId = null),
            (this.settings = { appVerificationDisabledForTesting: !1 }),
            (this.frameworks = []),
            (this.name = e.name),
            (this.clientVersion = r.sdkClientVersion);
        }
        _initializeWithPersistence(e, t) {
          return (
            t && (this._popupRedirectResolver = he(t)),
            (this._initializationPromise = this.queue(async () => {
              var n, r;
              if (!this._deleted && ((this.persistenceManager = await ge.create(this, e)), !this._deleted)) {
                if (null === (n = this._popupRedirectResolver) || void 0 === n ? void 0 : n._shouldInitProactively)
                  try {
                    await this._popupRedirectResolver._initialize(this);
                  } catch (i) {}
                await this.initializeCurrentUser(t),
                  (this.lastNotifiedUid = (null === (r = this.currentUser) || void 0 === r ? void 0 : r.uid) || null),
                  this._deleted || (this._isInitialized = !0);
              }
            })),
            this._initializationPromise
          );
        }
        async _onStorageEvent() {
          if (this._deleted) return;
          const e = await this.assertedPersistence.getCurrentUser();
          return this.currentUser || e
            ? this.currentUser && e && this.currentUser.uid === e.uid
              ? (this._currentUser._assign(e), void (await this.currentUser.getIdToken()))
              : void (await this._updateCurrentUser(e, !0))
            : void 0;
        }
        async initializeCurrentUser(e) {
          var t;
          const n = await this.assertedPersistence.getCurrentUser();
          let r = n,
            i = !1;
          if (e && this.config.authDomain) {
            await this.getOrInitRedirectPersistenceManager();
            const n = null === (t = this.redirectUser) || void 0 === t ? void 0 : t._redirectEventId,
              o = null === r || void 0 === r ? void 0 : r._redirectEventId,
              s = await this.tryRedirectSignIn(e);
            (n && n !== o) || !(null === s || void 0 === s ? void 0 : s.user) || ((r = s.user), (i = !0));
          }
          if (!r) return this.directlySetCurrentUser(null);
          if (!r._redirectEventId) {
            if (i)
              try {
                await this.beforeStateQueue.runMiddleware(r);
              } catch (o) {
                (r = n), this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o));
              }
            return r ? this.reloadAndSetCurrentUserOrClear(r) : this.directlySetCurrentUser(null);
          }
          return (
            S(this._popupRedirectResolver, this, 'argument-error'),
            await this.getOrInitRedirectPersistenceManager(),
            this.redirectUser && this.redirectUser._redirectEventId === r._redirectEventId
              ? this.directlySetCurrentUser(r)
              : this.reloadAndSetCurrentUserOrClear(r)
          );
        }
        async tryRedirectSignIn(e) {
          let t = null;
          try {
            t = await this._popupRedirectResolver._completeRedirectFn(this, e, !0);
          } catch (n) {
            await this._setRedirectUser(null);
          }
          return t;
        }
        async reloadAndSetCurrentUserOrClear(e) {
          try {
            await ne(e);
          } catch (t) {
            if ('auth/network-request-failed' !== (null === t || void 0 === t ? void 0 : t.code)) return this.directlySetCurrentUser(null);
          }
          return this.directlySetCurrentUser(e);
        }
        useDeviceLanguage() {
          this.languageCode = N();
        }
        async _delete() {
          this._deleted = !0;
        }
        async updateCurrentUser(e) {
          const t = e ? (0, i.m9)(e) : null;
          return t && S(t.auth.config.apiKey === this.config.apiKey, this, 'invalid-user-token'), this._updateCurrentUser(t && t._clone(this));
        }
        async _updateCurrentUser(e, t = !1) {
          if (!this._deleted)
            return (
              e && S(this.tenantId === e.tenantId, this, 'tenant-id-mismatch'),
              t || (await this.beforeStateQueue.runMiddleware(e)),
              this.queue(async () => {
                await this.directlySetCurrentUser(e), this.notifyAuthListeners();
              })
            );
        }
        async signOut() {
          return (
            await this.beforeStateQueue.runMiddleware(null),
            (this.redirectPersistenceManager || this._popupRedirectResolver) && (await this._setRedirectUser(null)),
            this._updateCurrentUser(null, !0)
          );
        }
        setPersistence(e) {
          return this.queue(async () => {
            await this.assertedPersistence.setPersistence(he(e));
          });
        }
        async initializeRecaptchaConfig() {
          const e = await Re(this, { clientType: 'CLIENT_TYPE_WEB', version: 'RECAPTCHA_ENTERPRISE' }),
            t = new Le(e);
          if (
            (null == this.tenantId ? (this._agentRecaptchaConfig = t) : (this._tenantRecaptchaConfigs[this.tenantId] = t), t.emailPasswordEnabled)
          ) {
            const e = new $e(this);
            e.verify();
          }
        }
        _getRecaptchaConfig() {
          return null == this.tenantId ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId];
        }
        _getPersistence() {
          return this.assertedPersistence.persistence.type;
        }
        _updateErrorMap(e) {
          this._errorFactory = new i.LL('auth', 'Firebase', e());
        }
        onAuthStateChanged(e, t, n) {
          return this.registerStateListener(this.authStateSubscription, e, t, n);
        }
        beforeAuthStateChanged(e, t) {
          return this.beforeStateQueue.pushCallback(e, t);
        }
        onIdTokenChanged(e, t, n) {
          return this.registerStateListener(this.idTokenSubscription, e, t, n);
        }
        toJSON() {
          var e;
          return {
            apiKey: this.config.apiKey,
            authDomain: this.config.authDomain,
            appName: this.name,
            currentUser: null === (e = this._currentUser) || void 0 === e ? void 0 : e.toJSON()
          };
        }
        async _setRedirectUser(e, t) {
          const n = await this.getOrInitRedirectPersistenceManager(t);
          return null === e ? n.removeCurrentUser() : n.setCurrentUser(e);
        }
        async getOrInitRedirectPersistenceManager(e) {
          if (!this.redirectPersistenceManager) {
            const t = (e && he(e)) || this._popupRedirectResolver;
            S(t, this, 'argument-error'),
              (this.redirectPersistenceManager = await ge.create(this, [he(t._redirectPersistence)], 'redirectUser')),
              (this.redirectUser = await this.redirectPersistenceManager.getCurrentUser());
          }
          return this.redirectPersistenceManager;
        }
        async _redirectUserForId(e) {
          var t, n;
          return (
            this._isInitialized && (await this.queue(async () => {})),
            (null === (t = this._currentUser) || void 0 === t ? void 0 : t._redirectEventId) === e
              ? this._currentUser
              : (null === (n = this.redirectUser) || void 0 === n ? void 0 : n._redirectEventId) === e
                ? this.redirectUser
                : null
          );
        }
        async _persistUserIfCurrent(e) {
          if (e === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(e));
        }
        _notifyListenersIfCurrent(e) {
          e === this.currentUser && this.notifyAuthListeners();
        }
        _key() {
          return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
        }
        _startProactiveRefresh() {
          (this.isProactiveRefreshEnabled = !0), this.currentUser && this._currentUser._startProactiveRefresh();
        }
        _stopProactiveRefresh() {
          (this.isProactiveRefreshEnabled = !1), this.currentUser && this._currentUser._stopProactiveRefresh();
        }
        get _currentUser() {
          return this.currentUser;
        }
        notifyAuthListeners() {
          var e, t;
          if (!this._isInitialized) return;
          this.idTokenSubscription.next(this.currentUser);
          const n = null !== (t = null === (e = this.currentUser) || void 0 === e ? void 0 : e.uid) && void 0 !== t ? t : null;
          this.lastNotifiedUid !== n && ((this.lastNotifiedUid = n), this.authStateSubscription.next(this.currentUser));
        }
        registerStateListener(e, t, n, r) {
          if (this._deleted) return () => {};
          const i = 'function' === typeof t ? t : t.next.bind(t),
            o = this._isInitialized ? Promise.resolve() : this._initializationPromise;
          return S(o, this, 'internal-error'), o.then(() => i(this.currentUser)), 'function' === typeof t ? e.addObserver(t, n, r) : e.addObserver(t);
        }
        async directlySetCurrentUser(e) {
          this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(),
            e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(),
            (this.currentUser = e),
            e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser();
        }
        queue(e) {
          return (this.operations = this.operations.then(e, e)), this.operations;
        }
        get assertedPersistence() {
          return S(this.persistenceManager, this, 'internal-error'), this.persistenceManager;
        }
        _logFramework(e) {
          e &&
            !this.frameworks.includes(e) &&
            (this.frameworks.push(e), this.frameworks.sort(), (this.clientVersion = Oe(this.config.clientPlatform, this._getFrameworks())));
        }
        _getFrameworks() {
          return this.frameworks;
        }
        async _getAdditionalHeaders() {
          var e;
          const t = { ['X-Client-Version']: this.clientVersion };
          this.app.options.appId && (t['X-Firebase-gmpid'] = this.app.options.appId);
          const n = await (null === (e = this.heartbeatServiceProvider.getImmediate({ optional: !0 })) || void 0 === e
            ? void 0
            : e.getHeartbeatsHeader());
          n && (t['X-Firebase-Client'] = n);
          const r = await this._getAppCheckToken();
          return r && (t['X-Firebase-AppCheck'] = r), t;
        }
        async _getAppCheckToken() {
          var e;
          const t = await (null === (e = this.appCheckServiceProvider.getImmediate({ optional: !0 })) || void 0 === e ? void 0 : e.getToken());
          return (
            (null === t || void 0 === t ? void 0 : t.error) && v(`Error while retrieving App Check token: ${t.error}`),
            null === t || void 0 === t ? void 0 : t.token
          );
        }
      }
      function We(e) {
        return (0, i.m9)(e);
      }
      class He {
        constructor(e) {
          (this.auth = e), (this.observer = null), (this.addObserver = (0, i.ne)(e => (this.observer = e)));
        }
        get next() {
          return S(this.observer, this.auth, 'internal-error'), this.observer.next.bind(this.observer);
        }
      }
