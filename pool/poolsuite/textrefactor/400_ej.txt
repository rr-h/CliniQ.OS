remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
      }
      class Ll {
        constructor(e, t, n) {
          (this.garbageCollector = e), (this.asyncQueue = t), (this.localStore = n), (this.Gn = null);
        }
        start() {
          -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Qn(6e4);
        }
        stop() {
          this.Gn && (this.Gn.cancel(), (this.Gn = null));
        }
        get started() {
          return null !== this.Gn;
        }
        Qn(e) {
          ti('LruGarbageCollector', `Garbage collection scheduled in ${e}ms`),
            (this.Gn = this.asyncQueue.enqueueAfterDelay('lru_garbage_collection', e, async () => {
              this.Gn = null;
              try {
                await this.localStore.collectGarbage(this.garbageCollector);
              } catch (e) {
                Qi(e) ? ti('LruGarbageCollector', 'Ignoring IndexedDB error during garbage collection: ', e) : await qi(e);
              }
              await this.Qn(3e5);
            }));
        }
      }
      class jl {
        constructor(e, t) {
          (this.jn = e), (this.params = t);
        }
        calculateTargetCount(e, t) {
          return this.jn.zn(e).next(e => Math.floor((t / 100) * e));
        }
        nthSequenceNumber(e, t) {
          if (0 === t) return zi.resolve(no.ct);
          const n = new Dl(t);
          return this.jn
            .forEachTarget(e, e => n.Kn(e.sequenceNumber))
            .next(() => this.jn.Wn(e, e => n.Kn(e)))
            .next(() => n.maxValue);
        }
        removeTargets(e, t, n) {
          return this.jn.removeTargets(e, t, n);
        }
        removeOrphanedDocuments(e, t) {
          return this.jn.removeOrphanedDocuments(e, t);
        }
        collect(e, t) {
          return -1 === this.params.cacheSizeCollectionThreshold
            ? (ti('LruGarbageCollector', 'Garbage collection skipped; disabled'), zi.resolve(wl))
            : this.getCacheSize(e).next(n =>
                n < this.params.cacheSizeCollectionThreshold
                  ? (ti(
                      'LruGarbageCollector',
                      `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`
                    ),
                    wl)
                  : this.Hn(e, t)
              );
        }
        getCacheSize(e) {
          return this.jn.getCacheSize(e);
        }
        Hn(e, t) {
          let n, r, i, o, s, u, c;
          const l = Date.now();
          return this.calculateTargetCount(e, this.params.percentileToCollect)
            .next(
              t => (
                t > this.params.maximumSequenceNumbersToCollect
                  ? (ti(
                      'LruGarbageCollector',
                      `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${t}`
                    ),
                    (r = this.params.maximumSequenceNumbersToCollect))
                  : (r = t),
                (o = Date.now()),
                this.nthSequenceNumber(e, r)
              )
            )
            .next(r => ((n = r), (s = Date.now()), this.removeTargets(e, n, t)))
            .next(t => ((i = t), (u = Date.now()), this.removeOrphanedDocuments(e, n)))
            .next(
              e => (
                (c = Date.now()),
                Zr() <= a['in'].DEBUG &&
                  ti(
                    'LruGarbageCollector',
                    `LRU Garbage Collection\n\tCounted targets in ${o - l}ms\n\tDetermined least recently used ${r} in ` +
                      (s - o) +
                      'ms\n' +
                      `\tRemoved ${i} targets in ` +
                      (u - s) +
                      'ms\n' +
                      `\tRemoved ${e} documents in ` +
                      (c - u) +
                      'ms\n' +
                      `Total Duration: ${c - l}ms`
                  ),
                zi.resolve({ didRun: !0, sequenceNumbersCollected: r, targetsRemoved: i, documentsRemoved: e })
              )
            );
        }
      }
      function Ml(e, t) {
        return new jl(e, t);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Fl {
        constructor(e, t) {
          (this.db = e), (this.garbageCollector = Ml(this, t));
        }
        zn(e) {
          const t = this.Jn(e);
          return this.db
            .getTargetCache()
            .getTargetCount(e)
            .next(e => t.next(t => e + t));
        }
        Jn(e) {
          let t = 0;
          return this.Wn(e, e => {
            t++;
          }).next(() => t);
        }
        forEachTarget(e, t) {
          return this.db.getTargetCache().forEachTarget(e, t);
        }
        Wn(e, t) {
          return this.Yn(e, (e, n) => t(n));
        }
        addReference(e, t, n) {
          return Ul(e, n);
        }
        removeReference(e, t, n) {
          return Ul(e, n);
        }
        removeTargets(e, t, n) {
          return this.db.getTargetCache().removeTargets(e, t, n);
        }
        markPotentiallyOrphaned(e, t) {
          return Ul(e, t);
        }
        Xn(e, t) {
          return (function (e, t) {
            let n = !1;
            return xl(e)
              .Z(r => Sl(e, r, t).next(e => (e && (n = !0), zi.resolve(!e))))
              .next(() => n);
          })(e, t);
        }
        removeOrphanedDocuments(e, t) {
          const n = this.db.getRemoteDocumentCache().newChangeBuffer(),
            r = [];
          let i = 0;
          return this.Yn(e, (o, s) => {
            if (s <= t) {
              const t = this.Xn(e, o).next(t => {
                if (!t) return i++, n.getEntry(e, o).next(() => (n.removeEntry(o, Ai.min()), Rl(e).delete([0, so(o.path)])));
              });
              r.push(t);
            }
          })
            .next(() => zi.waitFor(r))
            .next(() => n.apply(e))
            .next(() => i);
        }
        removeTarget(e, t) {
          const n = t.withSequenceNumber(e.currentSequenceNumber);
          return this.db.getTargetCache().updateTargetData(e, n);
        }
        updateLimboDocument(e, t) {
          return Ul(e, t);
        }
        Yn(e, t) {
          const n = Rl(e);
          let r,
            i = no.ct;
          return n
            .X({ index: 'documentTargetsIndex' }, ([e, n], { path: o, sequenceNumber: s }) => {
              0 === e ? (i !== no.ct && t(new Ni(co(r)), i), (i = s), (r = o)) : (i = no.ct);
            })
            .next(() => {
              i !== no.ct && t(new Ni(co(r)), i);
            });
        }
        getCacheSize(e) {
          return this.db.getRemoteDocumentCache().getSize(e);
        }
      }
      function Ul(e, t) {
        return Rl(e).put(
          (function (e, t) {
            return { targetId: 0, path: so(e.path), sequenceNumber: t };
          })(t, e.currentSequenceNumber)
        );
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Vl {
        constructor() {
          (this.changes = new Sa(
            e => e.toString(),
            (e, t) => e.isEqual(t)
          )),
            (this.changesApplied = !1);
        }
        addEntry(e) {
          this.assertNotApplied(), this.changes.set(e.key, e);
        }
        removeEntry(e, t) {
          this.assertNotApplied(), this.changes.set(e, xs.newInvalidDocument(e).setReadTime(t));
        }
        getEntry(e, t) {
          this.assertNotApplied();
          const n = this.changes.get(t);
          return void 0 !== n ? zi.resolve(n) : this.getFromCache(e, t);
        }
        getEntries(e, t) {
          return this.getAllFromCache(e, t);
        }
        apply(e) {
          return this.assertNotApplied(), (this.changesApplied = !0), this.applyChanges(e);
        }
        assertNotApplied() {}
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Bl {
        constructor(e) {
          this.serializer = e;
        }
        setIndexManager(e) {
          this.indexManager = e;
        }
        addEntry(e, t, n) {
          return Gl(e).put(n);
        }
        removeEntry(e, t, n) {
          return Gl(e).delete(
            (function (e, t) {
              const n = e.path.toArray();
              return [n.slice(0, n.length - 2), n[n.length - 2], kc(t), n[n.length - 1]];
            })(t, n)
          );
        }
        updateMetadata(e, t) {
          return this.getMetadata(e).next(n => ((n.byteSize += t), this.Zn(e, n)));
        }
        getEntry(e, t) {
          let n = xs.newInvalidDocument(t);
          return Gl(e)
            .X({ index: 'documentKeyIndex', range: IDBKeyRange.only(Wl(t)) }, (e, r) => {
              n = this.ts(t, r);
            })
            .next(() => n);
        }
        es(e, t) {
          let n = { size: 0, document: xs.newInvalidDocument(t) };
          return Gl(e)
            .X({ index: 'documentKeyIndex', range: IDBKeyRange.only(Wl(t)) }, (e, r) => {
              n = { document: this.ts(t, r), size: Il(r) };
            })
            .next(() => n);
        }
        getEntries(e, t) {
          let n = Aa();
          return this.ns(e, t, (e, t) => {
            const r = this.ts(e, t);
            n = n.insert(e, r);
          }).next(() => n);
        }
        ss(e, t) {
          let n = Aa(),
            r = new Uo(Ni.comparator);
          return this.ns(e, t, (e, t) => {
            const i = this.ts(e, t);
            (n = n.insert(e, i)), (r = r.insert(e, Il(t)));
          }).next(() => ({ documents: n, rs: r }));
        }
        ns(e, t, n) {
          if (t.isEmpty()) return zi.resolve();
          let r = new $o(Kl);
          t.forEach(e => (r = r.add(e)));
          const i = IDBKeyRange.bound(Wl(r.first()), Wl(r.last())),
            o = r.getIterator();
          let s = o.getNext();
          return Gl(e)
            .X({ index: 'documentKeyIndex', range: i }, (e, t, r) => {
              const i = Ni.fromSegments([...t.prefixPath, t.collectionGroup, t.documentId]);
              for (; s && Kl(s, i) < 0; ) n(s, null), (s = o.getNext());
              s && s.isEqual(i) && (n(s, t), (s = o.hasNext() ? o.getNext() : null)), s ? r.G(Wl(s)) : r.done();
            })
            .next(() => {
              for (; s; ) n(s, null), (s = o.hasNext() ? o.getNext() : null);
            });
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          const i = t.path,
            o = [i.popLast().toArray(), i.lastSegment(), kc(n.readTime), n.documentKey.path.isEmpty() ? '' : n.documentKey.path.lastSegment()],
            s = [i.popLast().toArray(), i.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ''];
          return Gl(e)
            .j(IDBKeyRange.bound(o, s, !0))
            .next(e => {
              let n = Aa();
              for (const i of e) {
                const e = this.ts(Ni.fromSegments(i.prefixPath.concat(i.collectionGroup, i.documentId)), i);
                e.isFoundDocument() && (ba(t, e) || r.has(e.key)) && (n = n.insert(e.key, e));
              }
              return n;
            });
        }
        getAllFromCollectionGroup(e, t, n, r) {
          let i = Aa();
          const o = Hl(t, n),
            s = Hl(t, Ui.max());
          return Gl(e)
            .X({ index: 'collectionGroupIndex', range: IDBKeyRange.bound(o, s, !0) }, (e, t, n) => {
              const o = this.ts(Ni.fromSegments(t.prefixPath.concat(t.collectionGroup, t.documentId)), t);
              (i = i.insert(o.key, o)), i.size === r && n.done();
            })
            .next(() => i);
        }
        newChangeBuffer(e) {
          return new ql(this, !!e && e.trackRemovals);
        }
        getSize(e) {
          return this.getMetadata(e).next(e => e.byteSize);
        }
        getMetadata(e) {
          return zl(e)
            .get('remoteDocumentGlobalKey')
            .next(e => (si(!!e), e));
        }
        Zn(e, t) {
          return zl(e).put('remoteDocumentGlobalKey', t);
        }
        ts(e, t) {
          if (t) {
            const e = xc(this.serializer, t);
            if (!e.isNoDocument() || !e.version.isEqual(Ai.min())) return e;
          }
          return xs.newInvalidDocument(e);
        }
      }
      function $l(e) {
        return new Bl(e);
      }
      class ql extends Vl {
        constructor(e, t) {
          super(),
            (this.os = e),
            (this.trackRemovals = t),
            (this.us = new Sa(
              e => e.toString(),
              (e, t) => e.isEqual(t)
            ));
        }
        applyChanges(e) {
