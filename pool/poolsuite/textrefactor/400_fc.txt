remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Zg(e, t, n) {
        let r;
        return (r = e ? (n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t)) : t), r;
      }
      class em extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Yp(e);
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return new Tp(this.firestore, null, t);
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class tm {
        constructor(e, t) {
          (this.hasPendingWrites = e), (this.fromCache = t);
        }
        isEqual(e) {
          return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache;
        }
      }
      class nm extends Ag {
        constructor(e, t, n, r, i, o) {
          super(e, t, n, r, o), (this._firestore = e), (this._firestoreImpl = e), (this.metadata = i);
        }
        exists() {
          return super.exists();
        }
        data(e = {}) {
          if (this._document) {
            if (this._converter) {
              const t = new rm(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
              return this._converter.fromFirestore(t, e);
            }
            return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps);
          }
        }
        get(e, t = {}) {
          if (this._document) {
            const n = this._document.data.field(Cg('DocumentSnapshot.get', e));
            if (null !== n) return this._userDataWriter.convertValue(n, t.serverTimestamps);
          }
        }
      }
      class rm extends nm {
        data(e = {}) {
          return super.data(e);
        }
      }
      class im {
        constructor(e, t, n, r) {
          (this._firestore = e),
            (this._userDataWriter = t),
            (this._snapshot = r),
            (this.metadata = new tm(r.hasPendingWrites, r.fromCache)),
            (this.query = n);
        }
        get docs() {
          const e = [];
          return this.forEach(t => e.push(t)), e;
        }
        get size() {
          return this._snapshot.docs.size;
        }
        get empty() {
          return 0 === this.size;
        }
        forEach(e, t) {
          this._snapshot.docs.forEach(n => {
            e.call(
              t,
              new rm(
                this._firestore,
                this._userDataWriter,
                n.key,
                n,
                new tm(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache),
                this.query.converter
              )
            );
          });
        }
        docChanges(e = {}) {
          const t = !!e.includeMetadataChanges;
          if (t && this._snapshot.excludesMetadataChanges)
            throw new li(
              ci.INVALID_ARGUMENT,
              'To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().'
            );
          return (
            (this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t) ||
              ((this._cachedChanges = (function (e, t) {
                if (e._snapshot.oldDocs.isEmpty()) {
                  let t = 0;
                  return e._snapshot.docChanges.map(n => {
                    const r = new rm(
                      e._firestore,
                      e._userDataWriter,
                      n.doc.key,
                      n.doc,
                      new tm(e._snapshot.mutatedKeys.has(n.doc.key), e._snapshot.fromCache),
                      e.query.converter
                    );
                    return n.doc, { type: 'added', doc: r, oldIndex: -1, newIndex: t++ };
                  });
                }
                {
                  let n = e._snapshot.oldDocs;
                  return e._snapshot.docChanges
                    .filter(e => t || 3 !== e.type)
                    .map(t => {
                      const r = new rm(
                        e._firestore,
                        e._userDataWriter,
                        t.doc.key,
                        t.doc,
                        new tm(e._snapshot.mutatedKeys.has(t.doc.key), e._snapshot.fromCache),
                        e.query.converter
                      );
                      let i = -1,
                        o = -1;
                      return (
                        0 !== t.type && ((i = n.indexOf(t.doc.key)), (n = n.delete(t.doc.key))),
                        1 !== t.type && ((n = n.add(t.doc)), (o = n.indexOf(t.doc.key))),
                        { type: om(t.type), doc: r, oldIndex: i, newIndex: o }
                      );
                    });
                }
              })(this, t)),
              (this._cachedChangesIncludeMetadataChanges = t)),
            this._cachedChanges
          );
        }
      }
      function om(e) {
        switch (e) {
          case 0:
            return 'added';
          case 2:
          case 3:
            return 'modified';
          case 1:
            return 'removed';
          default:
            return oi();
        }
      }
      function sm(e, t) {
        return e instanceof nm && t instanceof nm
          ? e._firestore === t._firestore &&
              e._key.isEqual(t._key) &&
              (null === e._document ? null === t._document : e._document.isEqual(t._document)) &&
              e._converter === t._converter
          : e instanceof im &&
              t instanceof im &&
              e._firestore === t._firestore &&
              Rp(e.query, t.query) &&
              e.metadata.isEqual(t.metadata) &&
              e._snapshot.isEqual(t._snapshot);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function am(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp);
        return ap(Fp(t), e._key).then(n => _m(t, e, n));
      }
      class um extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Yp(e);
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return new Tp(this.firestore, null, t);
        }
      }
      function cm(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return sp(n, e._key).then(n => new nm(t, r, e._key, n, new tm(null !== n && n.hasLocalMutations, !0), e.converter));
      }
      function lm(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp);
        return ap(Fp(t), e._key, { source: 'server' }).then(n => _m(t, e, n));
      }
      function hm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return kg(e._query), cp(n, e._query).then(n => new im(t, r, e, n));
      }
      function fm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return up(n, e._query).then(n => new im(t, r, e, n));
      }
      function dm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return cp(n, e._query, { source: 'server' }).then(n => new im(t, r, e, n));
      }
      function pm(e, t, n) {
        e = bp(e, Tp);
        const r = bp(e.firestore, Mp),
          i = Zg(e.converter, t, n);
        return bm(r, [ag(sg(r), 'setDoc', e._key, i, null !== e.converter, n).toMutation(e._key, nu.none())]);
      }
      function gm(e, t, n, ...r) {
        e = bp(e, Tp);
        const i = bp(e.firestore, Mp),
          o = sg(i);
        let s;
        return (
          (s = 'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp ? gg(o, 'updateDoc', e._key, t, n, r) : pg(o, 'updateDoc', e._key, t)),
          bm(i, [s.toMutation(e._key, nu.exists(!0))])
        );
      }
      function mm(e) {
        return bm(bp(e.firestore, Mp), [new gu(e._key, nu.none())]);
      }
      function vm(e, t) {
        const n = bp(e.firestore, Mp),
          r = Op(e),
          i = Zg(e.converter, t);
        return bm(n, [ag(sg(e.firestore), 'addDoc', r._key, i, null !== e.converter, {}).toMutation(r._key, nu.exists(!1))]).then(() => r);
      }
      function ym(e, ...t) {
        var n, r, i;
        e = (0, u.m9)(e);
        let o = { includeMetadataChanges: !1 },
          s = 0;
        'object' != typeof t[s] || Dp(t[s]) || ((o = t[s]), s++);
        const a = { includeMetadataChanges: o.includeMetadataChanges };
        if (Dp(t[s])) {
          const e = t[s];
          (t[s] = null === (n = e.next) || void 0 === n ? void 0 : n.bind(e)),
            (t[s + 1] = null === (r = e.error) || void 0 === r ? void 0 : r.bind(e)),
            (t[s + 2] = null === (i = e.complete) || void 0 === i ? void 0 : i.bind(e));
        }
        let c, l, h;
        if (e instanceof Tp)
          (l = bp(e.firestore, Mp)),
            (h = ua(e._key.path)),
            (c = {
              next: n => {
                t[s] && t[s](_m(l, e, n));
              },
              error: t[s + 1],
              complete: t[s + 2]
            });
        else {
          const n = bp(e, Ap);
          (l = bp(n.firestore, Mp)), (h = n._query);
          const r = new um(l);
          (c = {
            next: e => {
              t[s] && t[s](new im(l, r, n, e));
            },
            error: t[s + 1],
            complete: t[s + 2]
          }),
            kg(e._query);
        }
        return (function (e, t, n, r) {
          const i = new $d(r),
            o = new Kf(t, i, n);
          return (
            e.asyncQueue.enqueueAndForget(async () => qf(await rp(e), o)),
            () => {
              i.Dc(), e.asyncQueue.enqueueAndForget(async () => zf(await rp(e), o));
            }
          );
        })(Fp(l), h, a, c);
      }
      function wm(e, t) {
        return lp(Fp((e = bp(e, Mp))), Dp(t) ? t : { next: t });
      }
      function bm(e, t) {
        return (function (e, t) {
          const n = new hi();
          return e.asyncQueue.enqueueAndForget(async () => ud(await tp(e), t, n)), n.promise;
        })(Fp(e), t);
      }
      function _m(e, t, n) {
        const r = n.docs.get(t._key),
          i = new um(e);
        return new nm(e, i, t._key, r, new tm(n.hasPendingWrites, n.fromCache), t.converter);
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const Im = { maxAttempts: 5 };
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
