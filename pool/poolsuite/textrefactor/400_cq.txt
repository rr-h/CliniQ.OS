remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Be(e) {
        he(new r.wA('platform-logger', e => new k(e), 'PRIVATE')),
          he(new r.wA('heartbeat', e => new je(e), 'PRIVATE')),
          Ee(N, R, e),
          Ee(N, R, 'esm2017'),
          Ee('fire-js', '');
      }
      Be('');
    },
    8463: (e, t, n) => {
      'use strict';
      n.d(t, { H0: () => c, wA: () => i });
      var r = n(74444);
      class i {
        constructor(e, t, n) {
          (this.name = e),
            (this.instanceFactory = t),
            (this.type = n),
            (this.multipleInstances = !1),
            (this.serviceProps = {}),
            (this.instantiationMode = 'LAZY'),
            (this.onInstanceCreated = null);
        }
        setInstantiationMode(e) {
          return (this.instantiationMode = e), this;
        }
        setMultipleInstances(e) {
          return (this.multipleInstances = e), this;
        }
        setServiceProps(e) {
          return (this.serviceProps = e), this;
        }
        setInstanceCreatedCallback(e) {
          return (this.onInstanceCreated = e), this;
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const o = '[DEFAULT]';
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class s {
        constructor(e, t) {
          (this.name = e),
            (this.container = t),
            (this.component = null),
            (this.instances = new Map()),
            (this.instancesDeferred = new Map()),
            (this.instancesOptions = new Map()),
            (this.onInitCallbacks = new Map());
        }
        get(e) {
          const t = this.normalizeInstanceIdentifier(e);
          if (!this.instancesDeferred.has(t)) {
            const e = new r.BH();
            if ((this.instancesDeferred.set(t, e), this.isInitialized(t) || this.shouldAutoInitialize()))
              try {
                const n = this.getOrInitializeService({ instanceIdentifier: t });
                n && e.resolve(n);
              } catch (n) {}
          }
          return this.instancesDeferred.get(t).promise;
        }
        getImmediate(e) {
          var t;
          const n = this.normalizeInstanceIdentifier(null === e || void 0 === e ? void 0 : e.identifier),
            r = null !== (t = null === e || void 0 === e ? void 0 : e.optional) && void 0 !== t && t;
          if (!this.isInitialized(n) && !this.shouldAutoInitialize()) {
            if (r) return null;
            throw Error(`Service ${this.name} is not available`);
          }
          try {
            return this.getOrInitializeService({ instanceIdentifier: n });
          } catch (i) {
            if (r) return null;
            throw i;
          }
        }
        getComponent() {
          return this.component;
        }
        setComponent(e) {
          if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
          if (this.component) throw Error(`Component for ${this.name} has already been provided`);
          if (((this.component = e), this.shouldAutoInitialize())) {
            if (u(e))
              try {
                this.getOrInitializeService({ instanceIdentifier: o });
              } catch (t) {}
            for (const [e, n] of this.instancesDeferred.entries()) {
              const r = this.normalizeInstanceIdentifier(e);
              try {
                const e = this.getOrInitializeService({ instanceIdentifier: r });
                n.resolve(e);
              } catch (t) {}
            }
          }
        }
        clearInstance(e = o) {
          this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
        }
        async delete() {
          const e = Array.from(this.instances.values());
          await Promise.all([
            ...e.filter(e => 'INTERNAL' in e).map(e => e.INTERNAL.delete()),
            ...e.filter(e => '_delete' in e).map(e => e._delete())
          ]);
        }
        isComponentSet() {
          return null != this.component;
        }
        isInitialized(e = o) {
          return this.instances.has(e);
        }
        getOptions(e = o) {
          return this.instancesOptions.get(e) || {};
        }
        initialize(e = {}) {
          const { options: t = {} } = e,
            n = this.normalizeInstanceIdentifier(e.instanceIdentifier);
          if (this.isInitialized(n)) throw Error(`${this.name}(${n}) has already been initialized`);
          if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
          const r = this.getOrInitializeService({ instanceIdentifier: n, options: t });
          for (const [i, o] of this.instancesDeferred.entries()) {
            const e = this.normalizeInstanceIdentifier(i);
            n === e && o.resolve(r);
          }
          return r;
        }
        onInit(e, t) {
          var n;
          const r = this.normalizeInstanceIdentifier(t),
            i = null !== (n = this.onInitCallbacks.get(r)) && void 0 !== n ? n : new Set();
          i.add(e), this.onInitCallbacks.set(r, i);
          const o = this.instances.get(r);
          return (
            o && e(o, r),
            () => {
              i.delete(e);
            }
          );
        }
        invokeOnInitCallbacks(e, t) {
          const n = this.onInitCallbacks.get(t);
          if (n)
            for (const i of n)
              try {
                i(e, t);
              } catch (r) {}
        }
        getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
          let n = this.instances.get(e);
          if (
            !n &&
            this.component &&
            ((n = this.component.instanceFactory(this.container, { instanceIdentifier: a(e), options: t })),
            this.instances.set(e, n),
            this.instancesOptions.set(e, t),
            this.invokeOnInitCallbacks(n, e),
            this.component.onInstanceCreated)
          )
            try {
              this.component.onInstanceCreated(this.container, e, n);
            } catch (r) {}
          return n || null;
        }
        normalizeInstanceIdentifier(e = o) {
          return this.component ? (this.component.multipleInstances ? e : o) : e;
        }
        shouldAutoInitialize() {
          return !!this.component && 'EXPLICIT' !== this.component.instantiationMode;
        }
      }
      function a(e) {
        return e === o ? void 0 : e;
      }
      function u(e) {
        return 'EAGER' === e.instantiationMode;
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class c {
        constructor(e) {
          (this.name = e), (this.providers = new Map());
        }
        addComponent(e) {
          const t = this.getProvider(e.name);
          if (t.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
          t.setComponent(e);
        }
        addOrOverwriteComponent(e) {
          const t = this.getProvider(e.name);
          t.isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
        }
        getProvider(e) {
          if (this.providers.has(e)) return this.providers.get(e);
          const t = new s(e, this);
          return this.providers.set(e, t), t;
        }
        getProviders() {
          return Array.from(this.providers.values());
        }
      }
    },
    53333: (e, t, n) => {
      'use strict';
      n.d(t, { Am: () => h, Ub: () => l, Yd: () => c, in: () => i });
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const r = [];
      var i;
      (function (e) {
        (e[(e['DEBUG'] = 0)] = 'DEBUG'),
          (e[(e['VERBOSE'] = 1)] = 'VERBOSE'),
          (e[(e['INFO'] = 2)] = 'INFO'),
          (e[(e['WARN'] = 3)] = 'WARN'),
          (e[(e['ERROR'] = 4)] = 'ERROR'),
          (e[(e['SILENT'] = 5)] = 'SILENT');
      })(i || (i = {}));
      const o = { debug: i.DEBUG, verbose: i.VERBOSE, info: i.INFO, warn: i.WARN, error: i.ERROR, silent: i.SILENT },
        s = i.INFO,
        a = { [i.DEBUG]: 'log', [i.VERBOSE]: 'log', [i.INFO]: 'info', [i.WARN]: 'warn', [i.ERROR]: 'error' },
        u = (e, t, ...n) => {
          if (t < e.logLevel) return;
          const r = new Date().toISOString(),
            i = a[t];
          if (!i) throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
          console[i](`[${r}]  ${e.name}:`, ...n);
        };
      class c {
        constructor(e) {
          (this.name = e), (this._logLevel = s), (this._logHandler = u), (this._userLogHandler = null), r.push(this);
        }
        get logLevel() {
          return this._logLevel;
        }
        set logLevel(e) {
          if (!(e in i)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
          this._logLevel = e;
        }
        setLogLevel(e) {
          this._logLevel = 'string' === typeof e ? o[e] : e;
        }
        get logHandler() {
          return this._logHandler;
        }
        set logHandler(e) {
          if ('function' !== typeof e) throw new TypeError('Value assigned to `logHandler` must be a function');
          this._logHandler = e;
        }
        get userLogHandler() {
          return this._userLogHandler;
        }
        set userLogHandler(e) {
          this._userLogHandler = e;
        }
        debug(...e) {
          this._userLogHandler && this._userLogHandler(this, i.DEBUG, ...e), this._logHandler(this, i.DEBUG, ...e);
        }
        log(...e) {
          this._userLogHandler && this._userLogHandler(this, i.VERBOSE, ...e), this._logHandler(this, i.VERBOSE, ...e);
        }
        info(...e) {
          this._userLogHandler && this._userLogHandler(this, i.INFO, ...e), this._logHandler(this, i.INFO, ...e);
        }
        warn(...e) {
          this._userLogHandler && this._userLogHandler(this, i.WARN, ...e), this._logHandler(this, i.WARN, ...e);
        }
        error(...e) {
          this._userLogHandler && this._userLogHandler(this, i.ERROR, ...e), this._logHandler(this, i.ERROR, ...e);
        }
      }
      function l(e) {
        r.forEach(t => {
          t.setLogLevel(e);
        });
      }
      function h(e, t) {
        for (const n of r) {
          let r = null;
          t && t.level && (r = o[t.level]),
            (n.userLogHandler =
              null === e
                ? null
                : (t, n, ...o) => {
                    const s = o
                      .map(e => {
                        if (null == e) return null;
                        if ('string' === typeof e) return e;
                        if ('number' === typeof e || 'boolean' === typeof e) return e.toString();
                        if (e instanceof Error) return e.message;
                        try {
                          return JSON.stringify(e);
                        } catch (t) {
                          return null;
                        }
                      })
                      .filter(e => e)
                      .join(' ');
                    n >= (null !== r && void 0 !== r ? r : t.logLevel) && e({ level: i[n].toLowerCase(), message: s, args: o, type: t.name });
                  });
        }
      }
    },
    79865: (e, t, n) => {
      'use strict';
      var r = n(98180),
        i = n(25816),
        o = n(53333),
        s = n(74444),
        a = n(8463);
      const u = (e, t) => t.some(t => e instanceof t);
      let c, l;
      function h() {
        return c || (c = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
      }
      function f() {
        return l || (l = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);
      }
      const d = new WeakMap(),
        p = new WeakMap(),
        g = new WeakMap(),
        m = new WeakMap(),
        v = new WeakMap();
      function y(e) {
        const t = new Promise((t, n) => {
          const r = () => {
              e.removeEventListener('success', i), e.removeEventListener('error', o);
            },
            i = () => {
              t(S(e.result)), r();
            },
            o = () => {
              n(e.error), r();
            };
          e.addEventListener('success', i), e.addEventListener('error', o);
        });
        return (
          t
