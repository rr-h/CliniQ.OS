remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
            const e = o.getNext().value;
            if (e.getKey().getCollectionGroup() === t && e.largestBatchId > n) {
              let t = i.get(e.largestBatchId);
              null === t && ((t = Oa()), (i = i.insert(e.largestBatchId, t))), t.set(e.getKey(), e);
            }
          }
          const s = Oa(),
            a = i.getIterator();
          for (; a.hasNext(); ) if ((a.getNext().value.forEach((e, t) => s.set(e, t)), s.size() >= r)) break;
          return zi.resolve(s);
        }
        we(e, t, n) {
          const r = this.overlays.get(n.key);
          if (null !== r) {
            const e = this.ls.get(r.largestBatchId).delete(n.key);
            this.ls.set(r.largestBatchId, e);
          }
          this.overlays = this.overlays.insert(n.key, new wu(t, n));
          let i = this.ls.get(t);
          void 0 === i && ((i = La()), this.ls.set(t, i)), this.ls.set(t, i.add(n.key));
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Zl {
        constructor() {
          (this.fs = new $o(eh.ds)), (this.ws = new $o(eh._s));
        }
        isEmpty() {
          return this.fs.isEmpty();
        }
        addReference(e, t) {
          const n = new eh(e, t);
          (this.fs = this.fs.add(n)), (this.ws = this.ws.add(n));
        }
        gs(e, t) {
          e.forEach(e => this.addReference(e, t));
        }
        removeReference(e, t) {
          this.ys(new eh(e, t));
        }
        ps(e, t) {
          e.forEach(e => this.removeReference(e, t));
        }
        Is(e) {
          const t = new Ni(new Ci([])),
            n = new eh(t, e),
            r = new eh(t, e + 1),
            i = [];
          return (
            this.ws.forEachInRange([n, r], e => {
              this.ys(e), i.push(e.key);
            }),
            i
          );
        }
        Ts() {
          this.fs.forEach(e => this.ys(e));
        }
        ys(e) {
          (this.fs = this.fs.delete(e)), (this.ws = this.ws.delete(e));
        }
        Es(e) {
          const t = new Ni(new Ci([])),
            n = new eh(t, e),
            r = new eh(t, e + 1);
          let i = La();
          return (
            this.ws.forEachInRange([n, r], e => {
              i = i.add(e.key);
            }),
            i
          );
        }
        containsKey(e) {
          const t = new eh(e, 0),
            n = this.fs.firstAfterOrEqual(t);
          return null !== n && e.isEqual(n.key);
        }
      }
      class eh {
        constructor(e, t) {
          (this.key = e), (this.As = t);
        }
        static ds(e, t) {
          return Ni.comparator(e.key, t.key) || Ii(e.As, t.As);
        }
        static _s(e, t) {
          return Ii(e.As, t.As) || Ni.comparator(e.key, t.key);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class th {
        constructor(e, t) {
          (this.indexManager = e), (this.referenceDelegate = t), (this.mutationQueue = []), (this.vs = 1), (this.Rs = new $o(eh.ds));
        }
        checkEmpty(e) {
          return zi.resolve(0 === this.mutationQueue.length);
        }
        addMutationBatch(e, t, n, r) {
          const i = this.vs;
          this.vs++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
          const o = new vu(i, t, n, r);
          this.mutationQueue.push(o);
          for (const s of r) (this.Rs = this.Rs.add(new eh(s.key, i))), this.indexManager.addToCollectionParentIndex(e, s.key.path.popLast());
          return zi.resolve(o);
        }
        lookupMutationBatch(e, t) {
          return zi.resolve(this.Ps(t));
        }
        getNextMutationBatchAfterBatchId(e, t) {
          const n = t + 1,
            r = this.bs(n),
            i = r < 0 ? 0 : r;
          return zi.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);
        }
        getHighestUnacknowledgedBatchId() {
          return zi.resolve(0 === this.mutationQueue.length ? -1 : this.vs - 1);
        }
        getAllMutationBatches(e) {
          return zi.resolve(this.mutationQueue.slice());
        }
        getAllMutationBatchesAffectingDocumentKey(e, t) {
          const n = new eh(t, 0),
            r = new eh(t, Number.POSITIVE_INFINITY),
            i = [];
          return (
            this.Rs.forEachInRange([n, r], e => {
              const t = this.Ps(e.As);
              i.push(t);
            }),
            zi.resolve(i)
          );
        }
        getAllMutationBatchesAffectingDocumentKeys(e, t) {
          let n = new $o(Ii);
          return (
            t.forEach(e => {
              const t = new eh(e, 0),
                r = new eh(e, Number.POSITIVE_INFINITY);
              this.Rs.forEachInRange([t, r], e => {
                n = n.add(e.As);
              });
            }),
            zi.resolve(this.Vs(n))
          );
        }
        getAllMutationBatchesAffectingQuery(e, t) {
          const n = t.path,
            r = n.length + 1;
          let i = n;
          Ni.isDocumentKey(i) || (i = i.child(''));
          const o = new eh(new Ni(i), 0);
          let s = new $o(Ii);
          return (
            this.Rs.forEachWhile(e => {
              const t = e.key.path;
              return !!n.isPrefixOf(t) && (t.length === r && (s = s.add(e.As)), !0);
            }, o),
            zi.resolve(this.Vs(s))
          );
        }
        Vs(e) {
          const t = [];
          return (
            e.forEach(e => {
              const n = this.Ps(e);
              null !== n && t.push(n);
            }),
            t
          );
        }
        removeMutationBatch(e, t) {
          si(0 === this.Ss(t.batchId, 'removed')), this.mutationQueue.shift();
          let n = this.Rs;
          return zi
            .forEach(t.mutations, r => {
              const i = new eh(r.key, t.batchId);
              return (n = n.delete(i)), this.referenceDelegate.markPotentiallyOrphaned(e, r.key);
            })
            .next(() => {
              this.Rs = n;
            });
        }
        Cn(e) {}
        containsKey(e, t) {
          const n = new eh(t, 0),
            r = this.Rs.firstAfterOrEqual(n);
          return zi.resolve(t.isEqual(r && r.key));
        }
        performConsistencyCheck(e) {
          return this.mutationQueue.length, zi.resolve();
        }
        Ss(e, t) {
          return this.bs(e);
        }
        bs(e) {
          return 0 === this.mutationQueue.length ? 0 : e - this.mutationQueue[0].batchId;
        }
        Ps(e) {
          const t = this.bs(e);
          return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t];
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class nh {
        constructor(e) {
          (this.Ds = e), (this.docs = new Uo(Ni.comparator)), (this.size = 0);
        }
        setIndexManager(e) {
          this.indexManager = e;
        }
        addEntry(e, t) {
          const n = t.key,
            r = this.docs.get(n),
            i = r ? r.size : 0,
            o = this.Ds(t);
          return (
            (this.docs = this.docs.insert(n, { document: t.mutableCopy(), size: o })),
            (this.size += o - i),
            this.indexManager.addToCollectionParentIndex(e, n.path.popLast())
          );
        }
        removeEntry(e) {
          const t = this.docs.get(e);
          t && ((this.docs = this.docs.remove(e)), (this.size -= t.size));
        }
        getEntry(e, t) {
          const n = this.docs.get(t);
          return zi.resolve(n ? n.document.mutableCopy() : xs.newInvalidDocument(t));
        }
        getEntries(e, t) {
          let n = Aa();
          return (
            t.forEach(e => {
              const t = this.docs.get(e);
              n = n.insert(e, t ? t.document.mutableCopy() : xs.newInvalidDocument(e));
            }),
            zi.resolve(n)
          );
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          let i = Aa();
          const o = t.path,
            s = new Ni(o.child('')),
            a = this.docs.getIteratorFrom(s);
          for (; a.hasNext(); ) {
            const {
              key: e,
              value: { document: s }
            } = a.getNext();
            if (!o.isPrefixOf(e.path)) break;
            e.path.length > o.length + 1 || Vi(Fi(s), n) <= 0 || ((r.has(s.key) || ba(t, s)) && (i = i.insert(s.key, s.mutableCopy())));
          }
          return zi.resolve(i);
        }
        getAllFromCollectionGroup(e, t, n, r) {
          oi();
        }
        Cs(e, t) {
          return zi.forEach(this.docs, e => t(e));
        }
        newChangeBuffer(e) {
          return new rh(this);
        }
        getSize(e) {
          return zi.resolve(this.size);
        }
      }
      class rh extends Vl {
        constructor(e) {
          super(), (this.os = e);
        }
        applyChanges(e) {
          const t = [];
          return (
            this.changes.forEach((n, r) => {
              r.isValidDocument() ? t.push(this.os.addEntry(e, r)) : this.os.removeEntry(n);
            }),
            zi.waitFor(t)
          );
        }
        getFromCache(e, t) {
          return this.os.getEntry(e, t);
        }
        getAllFromCache(e, t) {
          return this.os.getEntries(e, t);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ih {
        constructor(e) {
          (this.persistence = e),
            (this.xs = new Sa(e => ea(e), ta)),
            (this.lastRemoteSnapshotVersion = Ai.min()),
            (this.highestTargetId = 0),
            (this.Ns = 0),
            (this.ks = new Zl()),
            (this.targetCount = 0),
            (this.Ms = Cl.kn());
        }
        forEachTarget(e, t) {
          return this.xs.forEach((e, n) => t(n)), zi.resolve();
        }
        getLastRemoteSnapshotVersion(e) {
          return zi.resolve(this.lastRemoteSnapshotVersion);
        }
        getHighestSequenceNumber(e) {
          return zi.resolve(this.Ns);
        }
        allocateTargetId(e) {
          return (this.highestTargetId = this.Ms.next()), zi.resolve(this.highestTargetId);
        }
        setTargetsMetadata(e, t, n) {
          return n && (this.lastRemoteSnapshotVersion = n), t > this.Ns && (this.Ns = t), zi.resolve();
        }
        Fn(e) {
          this.xs.set(e.target, e);
          const t = e.targetId;
          t > this.highestTargetId && ((this.Ms = new Cl(t)), (this.highestTargetId = t)), e.sequenceNumber > this.Ns && (this.Ns = e.sequenceNumber);
        }
        addTargetData(e, t) {
          return this.Fn(t), (this.targetCount += 1), zi.resolve();
        }
        updateTargetData(e, t) {
          return this.Fn(t), zi.resolve();
        }
        removeTargetData(e, t) {
          return this.xs.delete(t.target), this.ks.Is(t.targetId), (this.targetCount -= 1), zi.resolve();
        }
        removeTargets(e, t, n) {
          let r = 0;
          const i = [];
          return (
            this.xs.forEach((o, s) => {
              s.sequenceNumber <= t &&
                null === n.get(s.targetId) &&
                (this.xs.delete(o), i.push(this.removeMatchingKeysForTargetId(e, s.targetId)), r++);
            }),
            zi.waitFor(i).next(() => r)
          );
        }
        getTargetCount(e) {
          return zi.resolve(this.targetCount);
        }
