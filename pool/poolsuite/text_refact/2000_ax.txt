remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
            const e = o.getNext().value;
            if (e.getKey().getCollectionGroup() === t && e.largestBatchId > n) {
              let t = i.get(e.largestBatchId);
              null === t && ((t = Oa()), (i = i.insert(e.largestBatchId, t))), t.set(e.getKey(), e);
            }
          }
          const s = Oa(),
            a = i.getIterator();
          for (; a.hasNext(); ) if ((a.getNext().value.forEach((e, t) => s.set(e, t)), s.size() >= r)) break;
          return zi.resolve(s);
        }
        we(e, t, n) {
          const r = this.overlays.get(n.key);
          if (null !== r) {
            const e = this.ls.get(r.largestBatchId).delete(n.key);
            this.ls.set(r.largestBatchId, e);
          }
          this.overlays = this.overlays.insert(n.key, new wu(t, n));
          let i = this.ls.get(t);
          void 0 === i && ((i = La()), this.ls.set(t, i)), this.ls.set(t, i.add(n.key));
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Zl {
        constructor() {
          (this.fs = new $o(eh.ds)), (this.ws = new $o(eh._s));
        }
        isEmpty() {
          return this.fs.isEmpty();
        }
        addReference(e, t) {
          const n = new eh(e, t);
          (this.fs = this.fs.add(n)), (this.ws = this.ws.add(n));
        }
        gs(e, t) {
          e.forEach(e => this.addReference(e, t));
        }
        removeReference(e, t) {
          this.ys(new eh(e, t));
        }
        ps(e, t) {
          e.forEach(e => this.removeReference(e, t));
        }
        Is(e) {
          const t = new Ni(new Ci([])),
            n = new eh(t, e),
            r = new eh(t, e + 1),
            i = [];
          return (
            this.ws.forEachInRange([n, r], e => {
              this.ys(e), i.push(e.key);
            }),
            i
          );
        }
        Ts() {
          this.fs.forEach(e => this.ys(e));
        }
        ys(e) {
          (this.fs = this.fs.delete(e)), (this.ws = this.ws.delete(e));
        }
        Es(e) {
          const t = new Ni(new Ci([])),
            n = new eh(t, e),
            r = new eh(t, e + 1);
          let i = La();
          return (
            this.ws.forEachInRange([n, r], e => {
              i = i.add(e.key);
            }),
            i
          );
        }
        containsKey(e) {
          const t = new eh(e, 0),
            n = this.fs.firstAfterOrEqual(t);
          return null !== n && e.isEqual(n.key);
        }
      }
      class eh {
        constructor(e, t) {
          (this.key = e), (this.As = t);
        }
        static ds(e, t) {
          return Ni.comparator(e.key, t.key) || Ii(e.As, t.As);
        }
        static _s(e, t) {
          return Ii(e.As, t.As) || Ni.comparator(e.key, t.key);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class th {
        constructor(e, t) {
          (this.indexManager = e), (this.referenceDelegate = t), (this.mutationQueue = []), (this.vs = 1), (this.Rs = new $o(eh.ds));
        }
        checkEmpty(e) {
          return zi.resolve(0 === this.mutationQueue.length);
        }
        addMutationBatch(e, t, n, r) {
          const i = this.vs;
          this.vs++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
          const o = new vu(i, t, n, r);
          this.mutationQueue.push(o);
          for (const s of r) (this.Rs = this.Rs.add(new eh(s.key, i))), this.indexManager.addToCollectionParentIndex(e, s.key.path.popLast());
          return zi.resolve(o);
        }
        lookupMutationBatch(e, t) {
          return zi.resolve(this.Ps(t));
        }
        getNextMutationBatchAfterBatchId(e, t) {
          const n = t + 1,
            r = this.bs(n),
            i = r < 0 ? 0 : r;
          return zi.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);
        }
        getHighestUnacknowledgedBatchId() {
          return zi.resolve(0 === this.mutationQueue.length ? -1 : this.vs - 1);
        }
        getAllMutationBatches(e) {
          return zi.resolve(this.mutationQueue.slice());
        }
        getAllMutationBatchesAffectingDocumentKey(e, t) {
          const n = new eh(t, 0),
            r = new eh(t, Number.POSITIVE_INFINITY),
            i = [];
          return (
            this.Rs.forEachInRange([n, r], e => {
              const t = this.Ps(e.As);
              i.push(t);
            }),
            zi.resolve(i)
          );
        }
        getAllMutationBatchesAffectingDocumentKeys(e, t) {
          let n = new $o(Ii);
          return (
            t.forEach(e => {
              const t = new eh(e, 0),
                r = new eh(e, Number.POSITIVE_INFINITY);
              this.Rs.forEachInRange([t, r], e => {
                n = n.add(e.As);
              });
            }),
            zi.resolve(this.Vs(n))
          );
        }
        getAllMutationBatchesAffectingQuery(e, t) {
          const n = t.path,
            r = n.length + 1;
          let i = n;
          Ni.isDocumentKey(i) || (i = i.child(''));
          const o = new eh(new Ni(i), 0);
          let s = new $o(Ii);
          return (
            this.Rs.forEachWhile(e => {
              const t = e.key.path;
              return !!n.isPrefixOf(t) && (t.length === r && (s = s.add(e.As)), !0);
            }, o),
            zi.resolve(this.Vs(s))
          );
        }
        Vs(e) {
          const t = [];
          return (
            e.forEach(e => {
              const n = this.Ps(e);
              null !== n && t.push(n);
            }),
            t
          );
        }
        removeMutationBatch(e, t) {
          si(0 === this.Ss(t.batchId, 'removed')), this.mutationQueue.shift();
          let n = this.Rs;
          return zi
            .forEach(t.mutations, r => {
              const i = new eh(r.key, t.batchId);
              return (n = n.delete(i)), this.referenceDelegate.markPotentiallyOrphaned(e, r.key);
            })
            .next(() => {
              this.Rs = n;
            });
        }
        Cn(e) {}
        containsKey(e, t) {
          const n = new eh(t, 0),
            r = this.Rs.firstAfterOrEqual(n);
          return zi.resolve(t.isEqual(r && r.key));
        }
        performConsistencyCheck(e) {
          return this.mutationQueue.length, zi.resolve();
        }
        Ss(e, t) {
          return this.bs(e);
        }
        bs(e) {
          return 0 === this.mutationQueue.length ? 0 : e - this.mutationQueue[0].batchId;
        }
        Ps(e) {
          const t = this.bs(e);
          return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t];
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class nh {
        constructor(e) {
          (this.Ds = e), (this.docs = new Uo(Ni.comparator)), (this.size = 0);
        }
        setIndexManager(e) {
          this.indexManager = e;
        }
        addEntry(e, t) {
          const n = t.key,
            r = this.docs.get(n),
            i = r ? r.size : 0,
            o = this.Ds(t);
          return (
            (this.docs = this.docs.insert(n, { document: t.mutableCopy(), size: o })),
            (this.size += o - i),
            this.indexManager.addToCollectionParentIndex(e, n.path.popLast())
          );
        }
        removeEntry(e) {
          const t = this.docs.get(e);
          t && ((this.docs = this.docs.remove(e)), (this.size -= t.size));
        }
        getEntry(e, t) {
          const n = this.docs.get(t);
          return zi.resolve(n ? n.document.mutableCopy() : xs.newInvalidDocument(t));
        }
        getEntries(e, t) {
          let n = Aa();
          return (
            t.forEach(e => {
              const t = this.docs.get(e);
              n = n.insert(e, t ? t.document.mutableCopy() : xs.newInvalidDocument(e));
            }),
            zi.resolve(n)
          );
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          let i = Aa();
          const o = t.path,
            s = new Ni(o.child('')),
            a = this.docs.getIteratorFrom(s);
          for (; a.hasNext(); ) {
            const {
              key: e,
              value: { document: s }
            } = a.getNext();
            if (!o.isPrefixOf(e.path)) break;
            e.path.length > o.length + 1 || Vi(Fi(s), n) <= 0 || ((r.has(s.key) || ba(t, s)) && (i = i.insert(s.key, s.mutableCopy())));
          }
          return zi.resolve(i);
        }
        getAllFromCollectionGroup(e, t, n, r) {
          oi();
        }
        Cs(e, t) {
          return zi.forEach(this.docs, e => t(e));
        }
        newChangeBuffer(e) {
          return new rh(this);
        }
        getSize(e) {
          return zi.resolve(this.size);
        }
      }
      class rh extends Vl {
        constructor(e) {
          super(), (this.os = e);
        }
        applyChanges(e) {
          const t = [];
          return (
            this.changes.forEach((n, r) => {
              r.isValidDocument() ? t.push(this.os.addEntry(e, r)) : this.os.removeEntry(n);
            }),
            zi.waitFor(t)
          );
        }
        getFromCache(e, t) {
          return this.os.getEntry(e, t);
        }
        getAllFromCache(e, t) {
          return this.os.getEntries(e, t);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ih {
        constructor(e) {
          (this.persistence = e),
            (this.xs = new Sa(e => ea(e), ta)),
            (this.lastRemoteSnapshotVersion = Ai.min()),
            (this.highestTargetId = 0),
            (this.Ns = 0),
            (this.ks = new Zl()),
            (this.targetCount = 0),
            (this.Ms = Cl.kn());
        }
        forEachTarget(e, t) {
          return this.xs.forEach((e, n) => t(n)), zi.resolve();
        }
        getLastRemoteSnapshotVersion(e) {
          return zi.resolve(this.lastRemoteSnapshotVersion);
        }
        getHighestSequenceNumber(e) {
          return zi.resolve(this.Ns);
        }
        allocateTargetId(e) {
          return (this.highestTargetId = this.Ms.next()), zi.resolve(this.highestTargetId);
        }
        setTargetsMetadata(e, t, n) {
          return n && (this.lastRemoteSnapshotVersion = n), t > this.Ns && (this.Ns = t), zi.resolve();
        }
        Fn(e) {
          this.xs.set(e.target, e);
          const t = e.targetId;
          t > this.highestTargetId && ((this.Ms = new Cl(t)), (this.highestTargetId = t)), e.sequenceNumber > this.Ns && (this.Ns = e.sequenceNumber);
        }
        addTargetData(e, t) {
          return this.Fn(t), (this.targetCount += 1), zi.resolve();
        }
        updateTargetData(e, t) {
          return this.Fn(t), zi.resolve();
        }
        removeTargetData(e, t) {
          return this.xs.delete(t.target), this.ks.Is(t.targetId), (this.targetCount -= 1), zi.resolve();
        }
        removeTargets(e, t, n) {
          let r = 0;
          const i = [];
          return (
            this.xs.forEach((o, s) => {
              s.sequenceNumber <= t &&
                null === n.get(s.targetId) &&
                (this.xs.delete(o), i.push(this.removeMatchingKeysForTargetId(e, s.targetId)), r++);
            }),
            zi.waitFor(i).next(() => r)
          );
        }
        getTargetCount(e) {
          return zi.resolve(this.targetCount);
        }
        getTargetData(e, t) {
          const n = this.xs.get(t) || null;
          return zi.resolve(n);
        }
        addMatchingKeys(e, t, n) {
          return this.ks.gs(t, n), zi.resolve();
        }
        removeMatchingKeys(e, t, n) {
          this.ks.ps(t, n);
          const r = this.persistence.referenceDelegate,
            i = [];
          return (
            r &&
              t.forEach(t => {
                i.push(r.markPotentiallyOrphaned(e, t));
              }),
            zi.waitFor(i)
          );
        }
        removeMatchingKeysForTargetId(e, t) {
          return this.ks.Is(t), zi.resolve();
        }
        getMatchingKeysForTargetId(e, t) {
          const n = this.ks.Es(t);
          return zi.resolve(n);
        }
        containsKey(e, t) {
          return zi.resolve(this.ks.containsKey(t));
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class oh {
        constructor(e, t) {
          (this.$s = {}),
            (this.overlays = {}),
            (this.Os = new no(0)),
            (this.Fs = !1),
            (this.Fs = !0),
            (this.referenceDelegate = e(this)),
            (this.Bs = new ih(this)),
            (this.indexManager = new ll()),
            (this.remoteDocumentCache = (function (e) {
              return new nh(e);
            })(e => this.referenceDelegate.Ls(e))),
            (this.serializer = new Ac(t)),
            (this.qs = new Xl(this.serializer));
        }
        start() {
          return Promise.resolve();
        }
        shutdown() {
          return (this.Fs = !1), Promise.resolve();
        }
        get started() {
          return this.Fs;
        }
        setDatabaseDeletedListener() {}
        setNetworkEnabled() {}
        getIndexManager(e) {
          return this.indexManager;
        }
        getDocumentOverlayCache(e) {
          let t = this.overlays[e.toKey()];
          return t || ((t = new Jl()), (this.overlays[e.toKey()] = t)), t;
        }
        getMutationQueue(e, t) {
          let n = this.$s[e.toKey()];
          return n || ((n = new th(t, this.referenceDelegate)), (this.$s[e.toKey()] = n)), n;
        }
        getTargetCache() {
          return this.Bs;
        }
        getRemoteDocumentCache() {
          return this.remoteDocumentCache;
        }
        getBundleCache() {
          return this.qs;
        }
        runTransaction(e, t, n) {
          ti('MemoryPersistence', 'Starting transaction:', e);
          const r = new sh(this.Os.next());
          return (
            this.referenceDelegate.Us(),
            n(r)
              .next(e => this.referenceDelegate.Ks(r).next(() => e))
              .toPromise()
              .then(e => (r.raiseOnCommittedEvent(), e))
          );
        }
        Gs(e, t) {
          return zi.or(Object.values(this.$s).map(n => () => n.containsKey(e, t)));
        }
      }
      class sh extends $i {
        constructor(e) {
          super(), (this.currentSequenceNumber = e);
        }
      }
      class ah {
        constructor(e) {
          (this.persistence = e), (this.Qs = new Zl()), (this.js = null);
        }
        static zs(e) {
          return new ah(e);
        }
        get Ws() {
          if (this.js) return this.js;
          throw oi();
        }
        addReference(e, t, n) {
          return this.Qs.addReference(n, t), this.Ws.delete(n.toString()), zi.resolve();
        }
        removeReference(e, t, n) {
          return this.Qs.removeReference(n, t), this.Ws.add(n.toString()), zi.resolve();
        }
        markPotentiallyOrphaned(e, t) {
          return this.Ws.add(t.toString()), zi.resolve();
        }
        removeTarget(e, t) {
          this.Qs.Is(t.targetId).forEach(e => this.Ws.add(e.toString()));
          const n = this.persistence.getTargetCache();
          return n
            .getMatchingKeysForTargetId(e, t.targetId)
            .next(e => {
              e.forEach(e => this.Ws.add(e.toString()));
            })
            .next(() => n.removeTargetData(e, t));
        }
        Us() {
          this.js = new Set();
        }
        Ks(e) {
          const t = this.persistence.getRemoteDocumentCache().newChangeBuffer();
          return zi
            .forEach(this.Ws, n => {
              const r = Ni.fromPath(n);
              return this.Hs(e, r).next(e => {
                e || t.removeEntry(r, Ai.min());
              });
            })
            .next(() => ((this.js = null), t.apply(e)));
        }
        updateLimboDocument(e, t) {
          return this.Hs(e, t).next(e => {
            e ? this.Ws.delete(t.toString()) : this.Ws.add(t.toString());
          });
        }
        Ls(e) {
          return 0;
        }
        Hs(e, t) {
          return zi.or([
            () => zi.resolve(this.Qs.containsKey(t)),
            () => this.persistence.getTargetCache().containsKey(e, t),
            () => this.persistence.Gs(e, t)
          ]);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class uh {
        constructor(e) {
          this.serializer = e;
        }
        O(e, t, n, r) {
          const i = new Gi('createOrUpgrade', t);
          n < 1 &&
            r >= 1 &&
            ((function (e) {
              e.createObjectStore('owner');
            })(e),
            (function (e) {
              e.createObjectStore('mutationQueues', { keyPath: 'userId' }),
                e.createObjectStore('mutations', { keyPath: 'batchId', autoIncrement: !0 }).createIndex('userMutationsIndex', lo, { unique: !0 }),
                e.createObjectStore('documentMutations');
            })(e),
            ch(e),
            (function (e) {
              e.createObjectStore('remoteDocuments');
            })(e));
          let o = zi.resolve();
          return (
            n < 3 &&
              r >= 3 &&
              (0 !== n &&
                ((function (e) {
                  e.deleteObjectStore('targetDocuments'), e.deleteObjectStore('targets'), e.deleteObjectStore('targetGlobal');
                })(e),
                ch(e)),
              (o = o.next(() =>
                (function (e) {
                  const t = e.store('targetGlobal'),
                    n = { highestTargetId: 0, highestListenSequenceNumber: 0, lastRemoteSnapshotVersion: Ai.min().toTimestamp(), targetCount: 0 };
                  return t.put('targetGlobalKey', n);
                })(i)
              ))),
            n < 4 &&
              r >= 4 &&
              (0 !== n &&
                (o = o.next(() =>
                  (function (e, t) {
                    return t
                      .store('mutations')
                      .j()
                      .next(n => {
                        e.deleteObjectStore('mutations'),
                          e
                            .createObjectStore('mutations', { keyPath: 'batchId', autoIncrement: !0 })
                            .createIndex('userMutationsIndex', lo, { unique: !0 });
                        const r = t.store('mutations'),
                          i = n.map(e => r.put(e));
                        return zi.waitFor(i);
                      });
                  })(e, i)
                )),
              (o = o.next(() => {
                !(function (e) {
                  e.createObjectStore('clientMetadata', { keyPath: 'clientId' });
                })(e);
              }))),
            n < 5 && r >= 5 && (o = o.next(() => this.Ys(i))),
            n < 6 &&
              r >= 6 &&
              (o = o.next(
                () => (
                  (function (e) {
                    e.createObjectStore('remoteDocumentGlobal');
                  })(e),
                  this.Xs(i)
                )
              )),
            n < 7 && r >= 7 && (o = o.next(() => this.Zs(i))),
            n < 8 && r >= 8 && (o = o.next(() => this.ti(e, i))),
            n < 9 &&
              r >= 9 &&
              (o = o.next(() => {
                !(function (e) {
                  e.objectStoreNames.contains('remoteDocumentChanges') && e.deleteObjectStore('remoteDocumentChanges');
                })(e);
              })),
            n < 10 && r >= 10 && (o = o.next(() => this.ei(i))),
            n < 11 &&
              r >= 11 &&
              (o = o.next(() => {
                !(function (e) {
                  e.createObjectStore('bundles', { keyPath: 'bundleId' });
                })(e),
                  (function (e) {
                    e.createObjectStore('namedQueries', { keyPath: 'name' });
                  })(e);
              })),
            n < 12 &&
              r >= 12 &&
              (o = o.next(() => {
                !(function (e) {
                  const t = e.createObjectStore('documentOverlays', { keyPath: Ao });
                  t.createIndex('collectionPathOverlayIndex', xo, { unique: !1 }), t.createIndex('collectionGroupOverlayIndex', Co, { unique: !1 });
                })(e);
              })),
            n < 13 &&
              r >= 13 &&
              (o = o
                .next(() =>
                  (function (e) {
                    const t = e.createObjectStore('remoteDocumentsV14', { keyPath: go });
                    t.createIndex('documentKeyIndex', mo), t.createIndex('collectionGroupIndex', vo);
                  })(e)
                )
                .next(() => this.ni(e, i))
                .next(() => e.deleteObjectStore('remoteDocuments'))),
            n < 14 && r >= 14 && (o = o.next(() => this.si(e, i))),
            n < 15 &&
              r >= 15 &&
              (o = o.next(() =>
                (function (e) {
                  e
                    .createObjectStore('indexConfiguration', { keyPath: 'indexId', autoIncrement: !0 })
                    .createIndex('collectionGroupIndex', 'collectionGroup', { unique: !1 }),
                    e.createObjectStore('indexState', { keyPath: Io }).createIndex('sequenceNumberIndex', Eo, { unique: !1 }),
                    e.createObjectStore('indexEntries', { keyPath: So }).createIndex('documentKeyIndex', To, { unique: !1 });
                })(e)
              )),
            o
          );
        }
        Xs(e) {
          let t = 0;
          return e
            .store('remoteDocuments')
            .X((e, n) => {
              t += Il(n);
            })
            .next(() => {
              const n = { byteSize: t };
              return e.store('remoteDocumentGlobal').put('remoteDocumentGlobalKey', n);
            });
        }
        Ys(e) {
          const t = e.store('mutationQueues'),
            n = e.store('mutations');
          return t.j().next(t =>
            zi.forEach(t, t => {
              const r = IDBKeyRange.bound([t.userId, -1], [t.userId, t.lastAcknowledgedBatchId]);
              return n.j('userMutationsIndex', r).next(n =>
                zi.forEach(n, n => {
                  si(n.userId === t.userId);
                  const r = Rc(this.serializer, n);
                  return _l(e, t.userId, r).next(() => {});
                })
              );
            })
          );
        }
        Zs(e) {
          const t = e.store('targetDocuments'),
            n = e.store('remoteDocuments');
          return e
            .store('targetGlobal')
            .get('targetGlobalKey')
            .next(e => {
              const r = [];
              return n
                .X((n, i) => {
                  const o = new Ci(n),
                    s = (function (e) {
                      return [0, so(e)];
                    })(o);
                  r.push(
                    t
                      .get(s)
                      .next(n => (n ? zi.resolve() : (n => t.put({ targetId: 0, path: so(n), sequenceNumber: e.highestListenSequenceNumber }))(o)))
                  );
                })
                .next(() => zi.waitFor(r));
            });
        }
        ti(e, t) {
          e.createObjectStore('collectionParents', { keyPath: _o });
          const n = t.store('collectionParents'),
            r = new hl(),
            i = e => {
              if (r.add(e)) {
                const t = e.lastSegment(),
                  r = e.popLast();
                return n.put({ collectionId: t, parent: so(r) });
              }
            };
          return t
            .store('remoteDocuments')
            .X({ Y: !0 }, (e, t) => {
              const n = new Ci(e);
              return i(n.popLast());
            })
            .next(() =>
              t.store('documentMutations').X({ Y: !0 }, ([e, t, n], r) => {
                const o = co(t);
                return i(o.popLast());
              })
            );
        }
        ei(e) {
          const t = e.store('targets');
          return t.X((e, n) => {
            const r = Pc(n),
              i = Dc(this.serializer, r);
            return t.put(i);
          });
        }
        ni(e, t) {
          const n = t.store('remoteDocuments'),
            r = [];
          return n
            .X((e, n) => {
              const i = t.store('remoteDocumentsV14'),
                o = ((s = n),
                s.document
                  ? new Ni(Ci.fromString(s.document.name).popFirst(5))
                  : s.noDocument
                    ? Ni.fromSegments(s.noDocument.path)
                    : s.unknownDocument
                      ? Ni.fromSegments(s.unknownDocument.path)
                      : oi()).path.toArray();
              var s;
              /**
               * @license
               * Copyright 2017 Google LLC
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *   http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */ const a = {
                prefixPath: o.slice(0, o.length - 2),
                collectionGroup: o[o.length - 2],
                documentId: o[o.length - 1],
                readTime: n.readTime || [0, 0],
                unknownDocument: n.unknownDocument,
                noDocument: n.noDocument,
                document: n.document,
                hasCommittedMutations: !!n.hasCommittedMutations
              };
              r.push(i.put(a));
            })
            .next(() => zi.waitFor(r));
        }
        si(e, t) {
          const n = t.store('mutations'),
            r = $l(this.serializer),
            i = new oh(ah.zs, this.serializer.fe);
          return n.j().next(e => {
            const n = new Map();
            return (
              e.forEach(e => {
                var t;
                let r = null !== (t = n.get(e.userId)) && void 0 !== t ? t : La();
                Rc(this.serializer, e)
                  .keys()
                  .forEach(e => (r = r.add(e))),
                  n.set(e.userId, r);
              }),
              zi.forEach(n, (e, n) => {
                const o = new Yr(n),
                  s = $c.de(this.serializer, o),
                  a = i.getIndexManager(o),
                  u = El.de(o, this.serializer, a, i.referenceDelegate);
                return new Yl(r, u, s, a).recalculateAndSaveOverlaysForDocumentKeys(new Do(t, no.ct), e).next();
              })
            );
          });
        }
      }
      function ch(e) {
        e.createObjectStore('targetDocuments', { keyPath: wo }).createIndex('documentTargetsIndex', bo, { unique: !0 }),
          e.createObjectStore('targets', { keyPath: 'targetId' }).createIndex('queryTargetsIndex', yo, { unique: !0 }),
          e.createObjectStore('targetGlobal');
      }
      const lh =
        'Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.';
      class hh {
        constructor(e, t, n, r, i, o, s, a, u, c, l = 15) {
          if (
            ((this.allowTabSynchronization = e),
            (this.persistenceKey = t),
            (this.clientId = n),
            (this.ii = i),
            (this.window = o),
            (this.document = s),
            (this.ri = u),
            (this.oi = c),
            (this.ui = l),
            (this.Os = null),
            (this.Fs = !1),
            (this.isPrimary = !1),
            (this.networkEnabled = !0),
            (this.ci = null),
            (this.inForeground = !1),
            (this.ai = null),
            (this.hi = null),
            (this.li = Number.NEGATIVE_INFINITY),
            (this.fi = e => Promise.resolve()),
            !hh.D())
          )
            throw new li(
              ci.UNIMPLEMENTED,
              'This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.'
            );
          (this.referenceDelegate = new Fl(this, r)),
            (this.di = t + 'main'),
            (this.serializer = new Ac(a)),
            (this.wi = new Wi(this.di, this.ui, new uh(this.serializer))),
            (this.Bs = new kl(this.referenceDelegate, this.serializer)),
            (this.remoteDocumentCache = $l(this.serializer)),
            (this.qs = new Uc()),
            this.window && this.window.localStorage
              ? (this._i = this.window.localStorage)
              : ((this._i = null),
                !1 === c &&
                  ni(
                    'IndexedDbPersistence',
                    'LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.'
                  ));
        }
        start() {
          return this.mi()
            .then(() => {
              if (!this.isPrimary && !this.allowTabSynchronization) throw new li(ci.FAILED_PRECONDITION, lh);
              return (
                this.gi(),
                this.yi(),
                this.pi(),
                this.runTransaction('getHighestListenSequenceNumber', 'readonly', e => this.Bs.getHighestSequenceNumber(e))
              );
            })
            .then(e => {
              this.Os = new no(e, this.ri);
            })
            .then(() => {
              this.Fs = !0;
            })
            .catch(e => (this.wi && this.wi.close(), Promise.reject(e)));
        }
        Ii(e) {
          return (
            (this.fi = async t => {
              if (this.started) return e(t);
            }),
            e(this.isPrimary)
          );
        }
        setDatabaseDeletedListener(e) {
          this.wi.B(async t => {
            null === t.newVersion && (await e());
          });
        }
        setNetworkEnabled(e) {
          this.networkEnabled !== e &&
            ((this.networkEnabled = e),
            this.ii.enqueueAndForget(async () => {
              this.started && (await this.mi());
            }));
        }
        mi() {
          return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', e =>
            dh(e)
              .put({ clientId: this.clientId, updateTimeMs: Date.now(), networkEnabled: this.networkEnabled, inForeground: this.inForeground })
              .next(() => {
                if (this.isPrimary)
                  return this.Ti(e).next(e => {
                    e || ((this.isPrimary = !1), this.ii.enqueueRetryable(() => this.fi(!1)));
                  });
              })
              .next(() => this.Ei(e))
              .next(t => (this.isPrimary && !t ? this.Ai(e).next(() => !1) : !!t && this.vi(e).next(() => !0)))
          )
            .catch(e => {
              if (Qi(e)) return ti('IndexedDbPersistence', 'Failed to extend owner lease: ', e), this.isPrimary;
              if (!this.allowTabSynchronization) throw e;
              return ti('IndexedDbPersistence', 'Releasing owner lease after error during lease refresh', e), !1;
            })
            .then(e => {
              this.isPrimary !== e && this.ii.enqueueRetryable(() => this.fi(e)), (this.isPrimary = e);
            });
        }
        Ti(e) {
          return fh(e)
            .get('owner')
            .next(e => zi.resolve(this.Ri(e)));
        }
        Pi(e) {
          return dh(e).delete(this.clientId);
        }
        async bi() {
          if (this.isPrimary && !this.Vi(this.li, 18e5)) {
            this.li = Date.now();
            const e = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', e => {
              const t = Lo(e, 'clientMetadata');
              return t.j().next(e => {
                const n = this.Si(e, 18e5),
                  r = e.filter(e => -1 === n.indexOf(e));
                return zi.forEach(r, e => t.delete(e.clientId)).next(() => r);
              });
            }).catch(() => []);
            if (this._i) for (const t of e) this._i.removeItem(this.Di(t.clientId));
          }
        }
        pi() {
          this.hi = this.ii.enqueueAfterDelay('client_metadata_refresh', 4e3, () =>
            this.mi()
              .then(() => this.bi())
              .then(() => this.pi())
          );
        }
        Ri(e) {
          return !!e && e.ownerId === this.clientId;
        }
        Ei(e) {
          return this.oi
            ? zi.resolve(!0)
            : fh(e)
                .get('owner')
                .next(t => {
                  if (null !== t && this.Vi(t.leaseTimestampMs, 5e3) && !this.Ci(t.ownerId)) {
                    if (this.Ri(t) && this.networkEnabled) return !0;
                    if (!this.Ri(t)) {
                      if (!t.allowTabSynchronization) throw new li(ci.FAILED_PRECONDITION, lh);
                      return !1;
                    }
                  }
                  return (
                    !(!this.networkEnabled || !this.inForeground) ||
                    dh(e)
                      .j()
                      .next(
                        e =>
                          void 0 ===
                          this.Si(e, 5e3).find(e => {
                            if (this.clientId !== e.clientId) {
                              const t = !this.networkEnabled && e.networkEnabled,
                                n = !this.inForeground && e.inForeground,
                                r = this.networkEnabled === e.networkEnabled;
                              if (t || (n && r)) return !0;
                            }
                            return !1;
                          })
                      )
                  );
                })
                .next(e => (this.isPrimary !== e && ti('IndexedDbPersistence', `Client ${e ? 'is' : 'is not'} eligible for a primary lease.`), e));
        }
        async shutdown() {
          (this.Fs = !1),
            this.xi(),
            this.hi && (this.hi.cancel(), (this.hi = null)),
            this.Ni(),
            this.ki(),
            await this.wi.runTransaction('shutdown', 'readwrite', ['owner', 'clientMetadata'], e => {
              const t = new Do(e, no.ct);
              return this.Ai(t).next(() => this.Pi(t));
            }),
            this.wi.close(),
            this.Mi();
        }
        Si(e, t) {
          return e.filter(e => this.Vi(e.updateTimeMs, t) && !this.Ci(e.clientId));
        }
        $i() {
          return this.runTransaction('getActiveClients', 'readonly', e =>
            dh(e)
              .j()
              .next(e => this.Si(e, 18e5).map(e => e.clientId))
          );
        }
        get started() {
          return this.Fs;
        }
        getMutationQueue(e, t) {
          return El.de(e, this.serializer, t, this.referenceDelegate);
        }
        getTargetCache() {
          return this.Bs;
        }
        getRemoteDocumentCache() {
          return this.remoteDocumentCache;
        }
        getIndexManager(e) {
          return new dl(e, this.serializer.fe.databaseId);
        }
        getDocumentOverlayCache(e) {
          return $c.de(this.serializer, e);
        }
        getBundleCache() {
          return this.qs;
        }
        runTransaction(e, t, n) {
          ti('IndexedDbPersistence', 'Starting transaction:', e);
          const r = 'readonly' === t ? 'readonly' : 'readwrite',
            i = 15 === (o = this.ui) ? Po : 14 === o ? Ro : 13 === o ? No : 12 === o ? Oo : 11 === o ? ko : void oi();
          var o;
          let s;
          return this.wi
            .runTransaction(
              e,
              r,
              i,
              r => (
                (s = new Do(r, this.Os ? this.Os.next() : no.ct)),
                'readwrite-primary' === t
                  ? this.Ti(s)
                      .next(e => !!e || this.Ei(s))
                      .next(t => {
                        if (!t)
                          throw (
                            (ni(`Failed to obtain primary lease for action '${e}'.`),
                            (this.isPrimary = !1),
                            this.ii.enqueueRetryable(() => this.fi(!1)),
                            new li(ci.FAILED_PRECONDITION, Bi))
                          );
                        return n(s);
                      })
                      .next(e => this.vi(s).next(() => e))
                  : this.Oi(s).next(() => n(s))
              )
            )
            .then(e => (s.raiseOnCommittedEvent(), e));
        }
        Oi(e) {
          return fh(e)
            .get('owner')
            .next(e => {
              if (
                null !== e &&
                this.Vi(e.leaseTimestampMs, 5e3) &&
                !this.Ci(e.ownerId) &&
                !this.Ri(e) &&
                !(this.oi || (this.allowTabSynchronization && e.allowTabSynchronization))
              )
                throw new li(ci.FAILED_PRECONDITION, lh);
            });
        }
        vi(e) {
          const t = { ownerId: this.clientId, allowTabSynchronization: this.allowTabSynchronization, leaseTimestampMs: Date.now() };
          return fh(e).put('owner', t);
        }
        static D() {
          return Wi.D();
        }
        Ai(e) {
          const t = fh(e);
          return t.get('owner').next(e => (this.Ri(e) ? (ti('IndexedDbPersistence', 'Releasing primary lease.'), t.delete('owner')) : zi.resolve()));
        }
        Vi(e, t) {
          const n = Date.now();
          return !(e < n - t) && (!(e > n) || (ni(`Detected an update time that is in the future: ${e} > ${n}`), !1));
        }
        gi() {
          null !== this.document &&
            'function' == typeof this.document.addEventListener &&
            ((this.ai = () => {
              this.ii.enqueueAndForget(() => ((this.inForeground = 'visible' === this.document.visibilityState), this.mi()));
            }),
            this.document.addEventListener('visibilitychange', this.ai),
            (this.inForeground = 'visible' === this.document.visibilityState));
        }
        Ni() {
          this.ai && (this.document.removeEventListener('visibilitychange', this.ai), (this.ai = null));
        }
        yi() {
          var e;
          'function' == typeof (null === (e = this.window) || void 0 === e ? void 0 : e.addEventListener) &&
            ((this.ci = () => {
              this.xi();
              const e = /(?:Version|Mobile)\/1[456]/;
              (0, u.G6)() && (navigator.appVersion.match(e) || navigator.userAgent.match(e)) && this.ii.enterRestrictedMode(!0),
                this.ii.enqueueAndForget(() => this.shutdown());
            }),
            this.window.addEventListener('pagehide', this.ci));
        }
        ki() {
          this.ci && (this.window.removeEventListener('pagehide', this.ci), (this.ci = null));
        }
        Ci(e) {
          var t;
          try {
            const n = null !== (null === (t = this._i) || void 0 === t ? void 0 : t.getItem(this.Di(e)));
            return ti('IndexedDbPersistence', `Client '${e}' ${n ? 'is' : 'is not'} zombied in LocalStorage`), n;
          } catch (e) {
            return ni('IndexedDbPersistence', 'Failed to get zombied client id.', e), !1;
          }
        }
        xi() {
          if (this._i)
            try {
              this._i.setItem(this.Di(this.clientId), String(Date.now()));
            } catch (e) {
              ni('Failed to set zombie client id.', e);
            }
        }
        Mi() {
          if (this._i)
            try {
              this._i.removeItem(this.Di(this.clientId));
            } catch (e) {}
        }
        Di(e) {
          return `firestore_zombie_${this.persistenceKey}_${e}`;
        }
      }
      function fh(e) {
        return Lo(e, 'owner');
      }
      function dh(e) {
        return Lo(e, 'clientMetadata');
      }
      function ph(e, t) {
        let n = e.projectId;
        return e.isDefaultDatabase || (n += '.' + e.database), 'firestore/' + t + '/' + n + '/';
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class gh {
        constructor(e, t, n, r) {
          (this.targetId = e), (this.fromCache = t), (this.Fi = n), (this.Bi = r);
        }
        static Li(e, t) {
          let n = La(),
            r = La();
          for (const i of t.docChanges)
            switch (i.type) {
              case 0:
                n = n.add(i.doc.key);
                break;
              case 1:
                r = r.add(i.doc.key);
            }
          return new gh(e, t.fromCache, n, r);
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class mh {
        constructor() {
          this.qi = !1;
        }
        initialize(e, t) {
          (this.Ui = e), (this.indexManager = t), (this.qi = !0);
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          return this.Ki(e, t)
            .next(i => i || this.Gi(e, t, r, n))
            .next(n => n || this.Qi(e, t));
        }
        Ki(e, t) {
          if (ca(t)) return zi.resolve(null);
          let n = pa(t);
          return this.indexManager.getIndexType(e, n).next(r =>
            0 === r
              ? null
              : (null !== t.limit && 1 === r && ((t = ma(t, null, 'F')), (n = pa(t))),
                this.indexManager.getDocumentsMatchingTarget(e, n).next(r => {
                  const i = La(...r);
                  return this.Ui.getDocuments(e, i).next(r =>
                    this.indexManager.getMinOffset(e, n).next(n => {
                      const o = this.ji(t, r);
                      return this.zi(t, o, i, n.readTime) ? this.Ki(e, ma(t, null, 'F')) : this.Wi(e, o, t, n);
                    })
                  );
                }))
          );
        }
        Gi(e, t, n, r) {
          return ca(t) || r.isEqual(Ai.min())
            ? this.Qi(e, t)
            : this.Ui.getDocuments(e, n).next(i => {
                const o = this.ji(t, i);
                return this.zi(t, o, n, r)
                  ? this.Qi(e, t)
                  : (Zr() <= a['in'].DEBUG && ti('QueryEngine', 'Re-using previous result from %s to execute query: %s', r.toString(), wa(t)),
                    this.Wi(e, o, t, Mi(r, -1)));
              });
        }
        ji(e, t) {
          let n = new $o(Ia(e));
          return (
            t.forEach((t, r) => {
              ba(e, r) && (n = n.add(r));
            }),
            n
          );
        }
        zi(e, t, n, r) {
          if (null === e.limit) return !1;
          if (n.size !== t.size) return !0;
          const i = 'F' === e.limitType ? t.last() : t.first();
          return !!i && (i.hasPendingWrites || i.version.compareTo(r) > 0);
        }
        Qi(e, t) {
          return (
            Zr() <= a['in'].DEBUG && ti('QueryEngine', 'Using full collection scan to execute query:', wa(t)),
            this.Ui.getDocumentsMatchingQuery(e, t, Ui.min())
          );
        }
        Wi(e, t, n, r) {
          return this.Ui.getDocumentsMatchingQuery(e, n, r).next(
            e => (
              t.forEach(t => {
                e = e.insert(t.key, t);
              }),
              e
            )
          );
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class vh {
        constructor(e, t, n, r) {
          (this.persistence = e),
            (this.Hi = t),
            (this.serializer = r),
            (this.Ji = new Uo(Ii)),
            (this.Yi = new Sa(e => ea(e), ta)),
            (this.Xi = new Map()),
            (this.Zi = e.getRemoteDocumentCache()),
            (this.Bs = e.getTargetCache()),
            (this.qs = e.getBundleCache()),
            this.tr(n);
        }
        tr(e) {
          (this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e)),
            (this.indexManager = this.persistence.getIndexManager(e)),
            (this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager)),
            (this.localDocuments = new Yl(this.Zi, this.mutationQueue, this.documentOverlayCache, this.indexManager)),
            this.Zi.setIndexManager(this.indexManager),
            this.Hi.initialize(this.localDocuments, this.indexManager);
        }
        collectGarbage(e) {
          return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', t => e.collect(t, this.Ji));
        }
      }
      function yh(e, t, n, r) {
        return new vh(e, t, n, r);
      }
      async function wh(e, t) {
        const n = ui(e);
        return await n.persistence.runTransaction('Handle user change', 'readonly', e => {
          let r;
          return n.mutationQueue
            .getAllMutationBatches(e)
            .next(i => ((r = i), n.tr(t), n.mutationQueue.getAllMutationBatches(e)))
            .next(t => {
              const i = [],
                o = [];
              let s = La();
              for (const e of r) {
                i.push(e.batchId);
                for (const t of e.mutations) s = s.add(t.key);
              }
              for (const e of t) {
                o.push(e.batchId);
                for (const t of e.mutations) s = s.add(t.key);
              }
              return n.localDocuments.getDocuments(e, s).next(e => ({ er: e, removedBatchIds: i, addedBatchIds: o }));
            });
        });
      }
      function bh(e, t) {
        const n = ui(e);
        return n.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', e => {
          const r = t.batch.keys(),
            i = n.Zi.newChangeBuffer({ trackRemovals: !0 });
          return (function (e, t, n, r) {
            const i = n.batch,
              o = i.keys();
            let s = zi.resolve();
            return (
              o.forEach(e => {
                s = s
                  .next(() => r.getEntry(t, e))
                  .next(t => {
                    const o = n.docVersions.get(e);
                    si(null !== o),
                      t.version.compareTo(o) < 0 &&
                        (i.applyToRemoteDocument(t, n), t.isValidDocument() && (t.setReadTime(n.commitVersion), r.addEntry(t)));
                  });
              }),
              s.next(() => e.mutationQueue.removeMutationBatch(t, i))
            );
          })(n, e, t, i)
            .next(() => i.apply(e))
            .next(() => n.mutationQueue.performConsistencyCheck(e))
            .next(() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t.batch.batchId))
            .next(() =>
              n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(
                e,
                (function (e) {
                  let t = La();
                  for (let n = 0; n < e.mutationResults.length; ++n)
                    e.mutationResults[n].transformResults.length > 0 && (t = t.add(e.batch.mutations[n].key));
                  return t;
                })(t)
              )
            )
            .next(() => n.localDocuments.getDocuments(e, r));
        });
      }
      function _h(e) {
        const t = ui(e);
        return t.persistence.runTransaction('Get last remote snapshot version', 'readonly', e => t.Bs.getLastRemoteSnapshotVersion(e));
      }
      function Ih(e, t) {
        const n = ui(e),
          r = t.snapshotVersion;
        let i = n.Ji;
        return n.persistence
          .runTransaction('Apply remote event', 'readwrite-primary', e => {
            const o = n.Zi.newChangeBuffer({ trackRemovals: !0 });
            i = n.Ji;
            const s = [];
            t.targetChanges.forEach((o, a) => {
              const u = i.get(a);
              if (!u) return;
              s.push(n.Bs.removeMatchingKeys(e, o.removedDocuments, a).next(() => n.Bs.addMatchingKeys(e, o.addedDocuments, a)));
              let c = u.withSequenceNumber(e.currentSequenceNumber);
              null !== t.targetMismatches.get(a)
                ? (c = c.withResumeToken(Ko.EMPTY_BYTE_STRING, Ai.min()).withLastLimboFreeSnapshotVersion(Ai.min()))
                : o.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(o.resumeToken, r)),
                (i = i.insert(a, c)),
                (function (e, t, n) {
                  return (
                    0 === e.resumeToken.approximateByteSize() ||
                    t.snapshotVersion.toMicroseconds() - e.snapshotVersion.toMicroseconds() >= 3e8 ||
                    n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size > 0
                  );
                })(u, c, o) && s.push(n.Bs.updateTargetData(e, c));
            });
            let a = Aa(),
              u = La();
            if (
              (t.documentUpdates.forEach(r => {
                t.resolvedLimboDocuments.has(r) && s.push(n.persistence.referenceDelegate.updateLimboDocument(e, r));
              }),
              s.push(
                Eh(e, o, t.documentUpdates).next(e => {
                  (a = e.nr), (u = e.sr);
                })
              ),
              !r.isEqual(Ai.min()))
            ) {
              const t = n.Bs.getLastRemoteSnapshotVersion(e).next(t => n.Bs.setTargetsMetadata(e, e.currentSequenceNumber, r));
              s.push(t);
            }
            return zi
              .waitFor(s)
              .next(() => o.apply(e))
              .next(() => n.localDocuments.getLocalViewOfDocuments(e, a, u))
              .next(() => a);
          })
          .then(e => ((n.Ji = i), e));
      }
      function Eh(e, t, n) {
        let r = La(),
          i = La();
        return (
          n.forEach(e => (r = r.add(e))),
          t.getEntries(e, r).next(e => {
            let r = Aa();
            return (
              n.forEach((n, o) => {
                const s = e.get(n);
                o.isFoundDocument() !== s.isFoundDocument() && (i = i.add(n)),
                  o.isNoDocument() && o.version.isEqual(Ai.min())
                    ? (t.removeEntry(n, o.readTime), (r = r.insert(n, o)))
                    : !s.isValidDocument() || o.version.compareTo(s.version) > 0 || (0 === o.version.compareTo(s.version) && s.hasPendingWrites)
                      ? (t.addEntry(o), (r = r.insert(n, o)))
                      : ti('LocalStore', 'Ignoring outdated watch update for ', n, '. Current version:', s.version, ' Watch version:', o.version);
              }),
              { nr: r, sr: i }
            );
          })
        );
      }
      function Sh(e, t) {
        const n = ui(e);
        return n.persistence.runTransaction(
          'Get next mutation batch',
          'readonly',
          e => (void 0 === t && (t = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(e, t))
        );
      }
      function Th(e, t) {
        const n = ui(e);
        return n.persistence
          .runTransaction('Allocate target', 'readwrite', e => {
            let r;
            return n.Bs.getTargetData(e, t).next(i =>
              i
                ? ((r = i), zi.resolve(r))
                : n.Bs.allocateTargetId(e).next(
                    i => ((r = new Tc(t, i, 'TargetPurposeListen', e.currentSequenceNumber)), n.Bs.addTargetData(e, r).next(() => r))
                  )
            );
          })
          .then(e => {
            const r = n.Ji.get(e.targetId);
            return (
              (null === r || e.snapshotVersion.compareTo(r.snapshotVersion) > 0) && ((n.Ji = n.Ji.insert(e.targetId, e)), n.Yi.set(t, e.targetId)), e
            );
          });
      }
      async function Ah(e, t, n) {
        const r = ui(e),
          i = r.Ji.get(t),
          o = n ? 'readwrite' : 'readwrite-primary';
        try {
          n || (await r.persistence.runTransaction('Release target', o, e => r.persistence.referenceDelegate.removeTarget(e, i)));
        } catch (e) {
          if (!Qi(e)) throw e;
          ti('LocalStore', `Failed to update sequence numbers for target ${t}: ${e}`);
        }
        (r.Ji = r.Ji.remove(t)), r.Yi.delete(i.target);
      }
      function xh(e, t, n) {
        const r = ui(e);
        let i = Ai.min(),
          o = La();
        return r.persistence.runTransaction('Execute query', 'readonly', e =>
          (function (e, t, n) {
            const r = ui(e),
              i = r.Yi.get(n);
            return void 0 !== i ? zi.resolve(r.Ji.get(i)) : r.Bs.getTargetData(t, n);
          })(r, e, pa(t))
            .next(t => {
              if (t)
                return (
                  (i = t.lastLimboFreeSnapshotVersion),
                  r.Bs.getMatchingKeysForTargetId(e, t.targetId).next(e => {
                    o = e;
                  })
                );
            })
            .next(() => r.Hi.getDocumentsMatchingQuery(e, t, n ? i : Ai.min(), n ? o : La()))
            .next(e => (Oh(r, _a(t), e), { documents: e, ir: o }))
        );
      }
      function Ch(e, t) {
        const n = ui(e),
          r = ui(n.Bs),
          i = n.Ji.get(t);
        return i
          ? Promise.resolve(i.target)
          : n.persistence.runTransaction('Get target data', 'readonly', e => r.le(e, t).next(e => (e ? e.target : null)));
      }
      function kh(e, t) {
        const n = ui(e),
          r = n.Xi.get(t) || Ai.min();
        return n.persistence
          .runTransaction('Get new document changes', 'readonly', e => n.Zi.getAllFromCollectionGroup(e, t, Mi(r, -1), Number.MAX_SAFE_INTEGER))
          .then(e => (Oh(n, t, e), e));
      }
      function Oh(e, t, n) {
        let r = e.Xi.get(t) || Ai.min();
        n.forEach((e, t) => {
          t.readTime.compareTo(r) > 0 && (r = t.readTime);
        }),
          e.Xi.set(t, r);
      }
      async function Nh(e, t, n, r) {
        const i = ui(e);
        let o = La(),
          s = Aa();
        for (const c of n) {
          const e = t.rr(c.metadata.name);
          c.document && (o = o.add(e));
          const n = t.ur(c);
          n.setReadTime(t.cr(c.metadata.readTime)), (s = s.insert(e, n));
        }
        const a = i.Zi.newChangeBuffer({ trackRemovals: !0 }),
          u = await Th(
            i,
            (function (e) {
              return pa(ua(Ci.fromString(`__bundle__/docs/${e}`)));
            })(r)
          );
        return i.persistence.runTransaction('Apply bundle documents', 'readwrite', e =>
          Eh(e, a, s)
            .next(t => (a.apply(e), t))
            .next(t =>
              i.Bs.removeMatchingKeysForTargetId(e, u.targetId)
                .next(() => i.Bs.addMatchingKeys(e, o, u.targetId))
                .next(() => i.localDocuments.getLocalViewOfDocuments(e, t.nr, t.sr))
                .next(() => t.nr)
            )
        );
      }
      async function Rh(e, t, n = La()) {
        const r = await Th(e, pa(Lc(t.bundledQuery))),
          i = ui(e);
        return i.persistence.runTransaction('Save named query', 'readwrite', e => {
          const o = Yu(t.readTime);
          if (r.snapshotVersion.compareTo(o) >= 0) return i.qs.saveNamedQuery(e, t);
          const s = r.withResumeToken(Ko.EMPTY_BYTE_STRING, o);
          return (
            (i.Ji = i.Ji.insert(s.targetId, s)),
            i.Bs.updateTargetData(e, s)
              .next(() => i.Bs.removeMatchingKeysForTargetId(e, r.targetId))
              .next(() => i.Bs.addMatchingKeys(e, n, r.targetId))
              .next(() => i.qs.saveNamedQuery(e, t))
          );
        });
      }
      function Ph(e, t) {
        return `firestore_clients_${e}_${t}`;
      }
      function Dh(e, t, n) {
        let r = `firestore_mutations_${e}_${n}`;
        return t.isAuthenticated() && (r += `_${t.uid}`), r;
      }
      function Lh(e, t) {
        return `firestore_targets_${e}_${t}`;
      }
      class jh {
        constructor(e, t, n, r) {
          (this.user = e), (this.batchId = t), (this.state = n), (this.error = r);
        }
        static ar(e, t, n) {
          const r = JSON.parse(n);
          let i,
            o =
              'object' == typeof r &&
              -1 !== ['pending', 'acknowledged', 'rejected'].indexOf(r.state) &&
              (void 0 === r.error || 'object' == typeof r.error);
          return (
            o &&
              r.error &&
              ((o = 'string' == typeof r.error.message && 'string' == typeof r.error.code), o && (i = new li(r.error.code, r.error.message))),
            o ? new jh(e, t, r.state, i) : (ni('SharedClientState', `Failed to parse mutation state for ID '${t}': ${n}`), null)
          );
        }
        hr() {
          const e = { state: this.state, updateTimeMs: Date.now() };
          return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e);
        }
      }
      class Mh {
        constructor(e, t, n) {
          (this.targetId = e), (this.state = t), (this.error = n);
        }
        static ar(e, t) {
          const n = JSON.parse(t);
          let r,
            i =
              'object' == typeof n &&
              -1 !== ['not-current', 'current', 'rejected'].indexOf(n.state) &&
              (void 0 === n.error || 'object' == typeof n.error);
          return (
            i &&
              n.error &&
              ((i = 'string' == typeof n.error.message && 'string' == typeof n.error.code), i && (r = new li(n.error.code, n.error.message))),
            i ? new Mh(e, n.state, r) : (ni('SharedClientState', `Failed to parse target state for ID '${e}': ${t}`), null)
          );
        }
        hr() {
          const e = { state: this.state, updateTimeMs: Date.now() };
          return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e);
        }
      }
      class Fh {
        constructor(e, t) {
          (this.clientId = e), (this.activeTargetIds = t);
        }
        static ar(e, t) {
          const n = JSON.parse(t);
          let r = 'object' == typeof n && n.activeTargetIds instanceof Array,
            i = Ma();
          for (let o = 0; r && o < n.activeTargetIds.length; ++o) (r = oo(n.activeTargetIds[o])), (i = i.add(n.activeTargetIds[o]));
          return r ? new Fh(e, i) : (ni('SharedClientState', `Failed to parse client data for instance '${e}': ${t}`), null);
        }
      }
      class Uh {
        constructor(e, t) {
          (this.clientId = e), (this.onlineState = t);
        }
        static ar(e) {
          const t = JSON.parse(e);
          return 'object' == typeof t && -1 !== ['Unknown', 'Online', 'Offline'].indexOf(t.onlineState) && 'string' == typeof t.clientId
            ? new Uh(t.clientId, t.onlineState)
            : (ni('SharedClientState', `Failed to parse online state: ${e}`), null);
        }
      }
      class Vh {
        constructor() {
          this.activeTargetIds = Ma();
        }
        lr(e) {
          this.activeTargetIds = this.activeTargetIds.add(e);
        }
        dr(e) {
          this.activeTargetIds = this.activeTargetIds.delete(e);
        }
        hr() {
          const e = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() };
          return JSON.stringify(e);
        }
      }
      class Bh {
        constructor(e, t, n, r, i) {
          (this.window = e),
            (this.ii = t),
            (this.persistenceKey = n),
            (this.wr = r),
            (this.syncEngine = null),
            (this.onlineStateHandler = null),
            (this.sequenceNumberHandler = null),
            (this._r = this.mr.bind(this)),
            (this.gr = new Uo(Ii)),
            (this.started = !1),
            (this.yr = []);
          const o = n.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          (this.storage = this.window.localStorage),
            (this.currentUser = i),
            (this.pr = Ph(this.persistenceKey, this.wr)),
            (this.Ir = (function (e) {
              return `firestore_sequence_number_${e}`;
            })(
              /**
               * @license
               * Copyright 2018 Google LLC
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *   http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */ this.persistenceKey
            )),
            (this.gr = this.gr.insert(this.wr, new Vh())),
            (this.Tr = new RegExp(`^firestore_clients_${o}_([^_]*)$`)),
            (this.Er = new RegExp(`^firestore_mutations_${o}_(\\d+)(?:_(.*))?$`)),
            (this.Ar = new RegExp(`^firestore_targets_${o}_(\\d+)$`)),
            (this.vr = (function (e) {
              return `firestore_online_state_${e}`;
            })(this.persistenceKey)),
            (this.Rr = (function (e) {
              return `firestore_bundle_loaded_v2_${e}`;
            })(this.persistenceKey)),
            this.window.addEventListener('storage', this._r);
        }
        static D(e) {
          return !(!e || !e.localStorage);
        }
        async start() {
          const e = await this.syncEngine.$i();
          for (const n of e) {
            if (n === this.wr) continue;
            const e = this.getItem(Ph(this.persistenceKey, n));
            if (e) {
              const t = Fh.ar(n, e);
              t && (this.gr = this.gr.insert(t.clientId, t));
            }
          }
          this.Pr();
          const t = this.storage.getItem(this.vr);
          if (t) {
            const e = this.br(t);
            e && this.Vr(e);
          }
          for (const n of this.yr) this.mr(n);
          (this.yr = []), this.window.addEventListener('pagehide', () => this.shutdown()), (this.started = !0);
        }
        writeSequenceNumber(e) {
          this.setItem(this.Ir, JSON.stringify(e));
        }
        getAllActiveQueryTargets() {
          return this.Sr(this.gr);
        }
        isActiveQueryTarget(e) {
          let t = !1;
          return (
            this.gr.forEach((n, r) => {
              r.activeTargetIds.has(e) && (t = !0);
            }),
            t
          );
        }
        addPendingMutation(e) {
          this.Dr(e, 'pending');
        }
        updateMutationState(e, t, n) {
          this.Dr(e, t, n), this.Cr(e);
        }
        addLocalQueryTarget(e) {
          let t = 'not-current';
          if (this.isActiveQueryTarget(e)) {
            const n = this.storage.getItem(Lh(this.persistenceKey, e));
            if (n) {
              const r = Mh.ar(e, n);
              r && (t = r.state);
            }
          }
          return this.Nr.lr(e), this.Pr(), t;
        }
        removeLocalQueryTarget(e) {
          this.Nr.dr(e), this.Pr();
        }
        isLocalQueryTarget(e) {
          return this.Nr.activeTargetIds.has(e);
        }
        clearQueryState(e) {
          this.removeItem(Lh(this.persistenceKey, e));
        }
        updateQueryState(e, t, n) {
          this.kr(e, t, n);
        }
        handleUserChange(e, t, n) {
          t.forEach(e => {
            this.Cr(e);
          }),
            (this.currentUser = e),
            n.forEach(e => {
              this.addPendingMutation(e);
            });
        }
        setOnlineState(e) {
          this.Mr(e);
        }
        notifyBundleLoaded(e) {
          this.$r(e);
        }
        shutdown() {
          this.started && (this.window.removeEventListener('storage', this._r), this.removeItem(this.pr), (this.started = !1));
        }
        getItem(e) {
          const t = this.storage.getItem(e);
          return ti('SharedClientState', 'READ', e, t), t;
        }
        setItem(e, t) {
          ti('SharedClientState', 'SET', e, t), this.storage.setItem(e, t);
        }
        removeItem(e) {
          ti('SharedClientState', 'REMOVE', e), this.storage.removeItem(e);
        }
        mr(e) {
          const t = e;
          if (t.storageArea === this.storage) {
            if ((ti('SharedClientState', 'EVENT', t.key, t.newValue), t.key === this.pr))
              return void ni('Received WebStorage notification for local change. Another client might have garbage-collected our state');
            this.ii.enqueueRetryable(async () => {
              if (this.started) {
                if (null !== t.key)
                  if (this.Tr.test(t.key)) {
                    if (null == t.newValue) {
                      const e = this.Or(t.key);
                      return this.Fr(e, null);
                    }
                    {
                      const e = this.Br(t.key, t.newValue);
                      if (e) return this.Fr(e.clientId, e);
                    }
                  } else if (this.Er.test(t.key)) {
                    if (null !== t.newValue) {
                      const e = this.Lr(t.key, t.newValue);
                      if (e) return this.qr(e);
                    }
                  } else if (this.Ar.test(t.key)) {
                    if (null !== t.newValue) {
                      const e = this.Ur(t.key, t.newValue);
                      if (e) return this.Kr(e);
                    }
                  } else if (t.key === this.vr) {
                    if (null !== t.newValue) {
                      const e = this.br(t.newValue);
                      if (e) return this.Vr(e);
                    }
                  } else if (t.key === this.Ir) {
                    const e = (function (e) {
                      let t = no.ct;
                      if (null != e)
                        try {
                          const n = JSON.parse(e);
                          si('number' == typeof n), (t = n);
                        } catch (e) {
                          ni('SharedClientState', 'Failed to read sequence number from WebStorage', e);
                        }
                      return t;
                    })(t.newValue);
                    e !== no.ct && this.sequenceNumberHandler(e);
                  } else if (t.key === this.Rr) {
                    const e = this.Gr(t.newValue);
                    await Promise.all(e.map(e => this.syncEngine.Qr(e)));
                  }
              } else this.yr.push(t);
            });
          }
        }
        get Nr() {
          return this.gr.get(this.wr);
        }
        Pr() {
          this.setItem(this.pr, this.Nr.hr());
        }
        Dr(e, t, n) {
          const r = new jh(this.currentUser, e, t, n),
            i = Dh(this.persistenceKey, this.currentUser, e);
          this.setItem(i, r.hr());
        }
        Cr(e) {
          const t = Dh(this.persistenceKey, this.currentUser, e);
          this.removeItem(t);
        }
        Mr(e) {
          const t = { clientId: this.wr, onlineState: e };
          this.storage.setItem(this.vr, JSON.stringify(t));
        }
        kr(e, t, n) {
          const r = Lh(this.persistenceKey, e),
            i = new Mh(e, t, n);
          this.setItem(r, i.hr());
        }
        $r(e) {
          const t = JSON.stringify(Array.from(e));
          this.setItem(this.Rr, t);
        }
        Or(e) {
          const t = this.Tr.exec(e);
          return t ? t[1] : null;
        }
        Br(e, t) {
          const n = this.Or(e);
          return Fh.ar(n, t);
        }
        Lr(e, t) {
          const n = this.Er.exec(e),
            r = Number(n[1]),
            i = void 0 !== n[2] ? n[2] : null;
          return jh.ar(new Yr(i), r, t);
        }
        Ur(e, t) {
          const n = this.Ar.exec(e),
            r = Number(n[1]);
          return Mh.ar(r, t);
        }
        br(e) {
          return Uh.ar(e);
        }
        Gr(e) {
          return JSON.parse(e);
        }
        async qr(e) {
          if (e.user.uid === this.currentUser.uid) return this.syncEngine.jr(e.batchId, e.state, e.error);
          ti('SharedClientState', `Ignoring mutation for non-active user ${e.user.uid}`);
        }
        Kr(e) {
          return this.syncEngine.zr(e.targetId, e.state, e.error);
        }
        Fr(e, t) {
          const n = t ? this.gr.insert(e, t) : this.gr.remove(e),
            r = this.Sr(this.gr),
            i = this.Sr(n),
            o = [],
            s = [];
