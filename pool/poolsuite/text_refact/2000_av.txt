remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
        for (const r of e.fieldTransforms) {
          const e = t.data.field(r.field),
            i = za(r.transform, e || null);
          null != i && (null === n && (n = Ts.empty()), n.set(r.field, i));
        }
        return n || null;
      }
      function cu(e, t) {
        return (
          e.type === t.type &&
          !!e.key.isEqual(t.key) &&
          !!e.precondition.isEqual(t.precondition) &&
          !!(function (e, t) {
            return (void 0 === e && void 0 === t) || (!(!e || !t) && Ei(e, t, (e, t) => eu(e, t)));
          })(e.fieldTransforms, t.fieldTransforms) &&
          (0 === e.type ? e.value.isEqual(t.value) : 1 !== e.type || (e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask)))
        );
      }
      class lu extends iu {
        constructor(e, t, n, r = []) {
          super(), (this.key = e), (this.value = t), (this.precondition = n), (this.fieldTransforms = r), (this.type = 0);
        }
        getFieldMask() {
          return null;
        }
      }
      class hu extends iu {
        constructor(e, t, n, r, i = []) {
          super(), (this.key = e), (this.data = t), (this.fieldMask = n), (this.precondition = r), (this.fieldTransforms = i), (this.type = 1);
        }
        getFieldMask() {
          return this.fieldMask;
        }
      }
      function fu(e) {
        const t = new Map();
        return (
          e.fieldMask.fields.forEach(n => {
            if (!n.isEmpty()) {
              const r = e.data.field(n);
              t.set(n, r);
            }
          }),
          t
        );
      }
      function du(e, t, n) {
        const r = new Map();
        si(e.length === n.length);
        for (let i = 0; i < n.length; i++) {
          const o = e[i],
            s = o.transform,
            a = t.data.field(o.field);
          r.set(o.field, qa(s, a, n[i]));
        }
        return r;
      }
      function pu(e, t, n) {
        const r = new Map();
        for (const i of e) {
          const e = i.transform,
            o = n.data.field(i.field);
          r.set(i.field, $a(e, o, t));
        }
        return r;
      }
      class gu extends iu {
        constructor(e, t) {
          super(), (this.key = e), (this.precondition = t), (this.type = 2), (this.fieldTransforms = []);
        }
        getFieldMask() {
          return null;
        }
      }
      class mu extends iu {
        constructor(e, t) {
          super(), (this.key = e), (this.precondition = t), (this.type = 3), (this.fieldTransforms = []);
        }
        getFieldMask() {
          return null;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class vu {
        constructor(e, t, n, r) {
          (this.batchId = e), (this.localWriteTime = t), (this.baseMutations = n), (this.mutations = r);
        }
        applyToRemoteDocument(e, t) {
          const n = t.mutationResults;
          for (let r = 0; r < this.mutations.length; r++) {
            const t = this.mutations[r];
            t.key.isEqual(e.key) && su(t, e, n[r]);
          }
        }
        applyToLocalView(e, t) {
          for (const n of this.baseMutations) n.key.isEqual(e.key) && (t = au(n, e, t, this.localWriteTime));
          for (const n of this.mutations) n.key.isEqual(e.key) && (t = au(n, e, t, this.localWriteTime));
          return t;
        }
        applyToLocalDocumentSet(e, t) {
          const n = Na();
          return (
            this.mutations.forEach(r => {
              const i = e.get(r.key),
                o = i.overlayedDocument;
              let s = this.applyToLocalView(o, i.mutatedFields);
              s = t.has(r.key) ? null : s;
              const a = ou(o, s);
              null !== a && n.set(r.key, a), o.isValidDocument() || o.convertToNoDocument(Ai.min());
            }),
            n
          );
        }
        keys() {
          return this.mutations.reduce((e, t) => e.add(t.key), La());
        }
        isEqual(e) {
          return (
            this.batchId === e.batchId &&
            Ei(this.mutations, e.mutations, (e, t) => cu(e, t)) &&
            Ei(this.baseMutations, e.baseMutations, (e, t) => cu(e, t))
          );
        }
      }
      class yu {
        constructor(e, t, n, r) {
          (this.batch = e), (this.commitVersion = t), (this.mutationResults = n), (this.docVersions = r);
        }
        static from(e, t, n) {
          si(e.mutations.length === n.length);
          let r = Pa;
          const i = e.mutations;
          for (let o = 0; o < i.length; o++) r = r.insert(i[o].key, n[o].version);
          return new yu(e, t, n, r);
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class wu {
        constructor(e, t) {
          (this.largestBatchId = e), (this.mutation = t);
        }
        getKey() {
          return this.mutation.key;
        }
        isEqual(e) {
          return null !== e && this.mutation === e.mutation;
        }
        toString() {
          return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`;
        }
      }
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class bu {
        constructor(e, t) {
          (this.count = e), (this.unchangedNames = t);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ var _u, Iu;
      function Eu(e) {
        switch (e) {
          default:
            return oi();
          case ci.CANCELLED:
          case ci.UNKNOWN:
          case ci.DEADLINE_EXCEEDED:
          case ci.RESOURCE_EXHAUSTED:
          case ci.INTERNAL:
          case ci.UNAVAILABLE:
          case ci.UNAUTHENTICATED:
            return !1;
          case ci.INVALID_ARGUMENT:
          case ci.NOT_FOUND:
          case ci.ALREADY_EXISTS:
          case ci.PERMISSION_DENIED:
          case ci.FAILED_PRECONDITION:
          case ci.ABORTED:
          case ci.OUT_OF_RANGE:
          case ci.UNIMPLEMENTED:
          case ci.DATA_LOSS:
            return !0;
        }
      }
      function Su(e) {
        if (void 0 === e) return ni('GRPC error has no .code'), ci.UNKNOWN;
        switch (e) {
          case _u.OK:
            return ci.OK;
          case _u.CANCELLED:
            return ci.CANCELLED;
          case _u.UNKNOWN:
            return ci.UNKNOWN;
          case _u.DEADLINE_EXCEEDED:
            return ci.DEADLINE_EXCEEDED;
          case _u.RESOURCE_EXHAUSTED:
            return ci.RESOURCE_EXHAUSTED;
          case _u.INTERNAL:
            return ci.INTERNAL;
          case _u.UNAVAILABLE:
            return ci.UNAVAILABLE;
          case _u.UNAUTHENTICATED:
            return ci.UNAUTHENTICATED;
          case _u.INVALID_ARGUMENT:
            return ci.INVALID_ARGUMENT;
          case _u.NOT_FOUND:
            return ci.NOT_FOUND;
          case _u.ALREADY_EXISTS:
            return ci.ALREADY_EXISTS;
          case _u.PERMISSION_DENIED:
            return ci.PERMISSION_DENIED;
          case _u.FAILED_PRECONDITION:
            return ci.FAILED_PRECONDITION;
          case _u.ABORTED:
            return ci.ABORTED;
          case _u.OUT_OF_RANGE:
            return ci.OUT_OF_RANGE;
          case _u.UNIMPLEMENTED:
            return ci.UNIMPLEMENTED;
          case _u.DATA_LOSS:
            return ci.DATA_LOSS;
          default:
            return oi();
        }
      }
      ((Iu = _u || (_u = {}))[(Iu.OK = 0)] = 'OK'),
        (Iu[(Iu.CANCELLED = 1)] = 'CANCELLED'),
        (Iu[(Iu.UNKNOWN = 2)] = 'UNKNOWN'),
        (Iu[(Iu.INVALID_ARGUMENT = 3)] = 'INVALID_ARGUMENT'),
        (Iu[(Iu.DEADLINE_EXCEEDED = 4)] = 'DEADLINE_EXCEEDED'),
        (Iu[(Iu.NOT_FOUND = 5)] = 'NOT_FOUND'),
        (Iu[(Iu.ALREADY_EXISTS = 6)] = 'ALREADY_EXISTS'),
        (Iu[(Iu.PERMISSION_DENIED = 7)] = 'PERMISSION_DENIED'),
        (Iu[(Iu.UNAUTHENTICATED = 16)] = 'UNAUTHENTICATED'),
        (Iu[(Iu.RESOURCE_EXHAUSTED = 8)] = 'RESOURCE_EXHAUSTED'),
        (Iu[(Iu.FAILED_PRECONDITION = 9)] = 'FAILED_PRECONDITION'),
        (Iu[(Iu.ABORTED = 10)] = 'ABORTED'),
        (Iu[(Iu.OUT_OF_RANGE = 11)] = 'OUT_OF_RANGE'),
        (Iu[(Iu.UNIMPLEMENTED = 12)] = 'UNIMPLEMENTED'),
        (Iu[(Iu.INTERNAL = 13)] = 'INTERNAL'),
        (Iu[(Iu.UNAVAILABLE = 14)] = 'UNAVAILABLE'),
        (Iu[(Iu.DATA_LOSS = 15)] = 'DATA_LOSS');
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class Tu {
        constructor() {
          this.onExistenceFilterMismatchCallbacks = new Map();
        }
        static get instance() {
          return Au;
        }
        static getOrCreateInstance() {
          return null === Au && (Au = new Tu()), Au;
        }
        onExistenceFilterMismatch(e) {
          const t = Symbol();
          return this.onExistenceFilterMismatchCallbacks.set(t, e), () => this.onExistenceFilterMismatchCallbacks.delete(t);
        }
        notifyOnExistenceFilterMismatch(e) {
          this.onExistenceFilterMismatchCallbacks.forEach(t => t(e));
        }
      }
      let Au = null;
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function xu() {
        return new TextEncoder();
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Cu = new Kr([4294967295, 4294967295], 0);
      function ku(e) {
        const t = xu().encode(e),
          n = new Hr();
        return n.update(t), new Uint8Array(n.digest());
      }
      function Ou(e) {
        const t = new DataView(e.buffer),
          n = t.getUint32(0, !0),
          r = t.getUint32(4, !0),
          i = t.getUint32(8, !0),
          o = t.getUint32(12, !0);
        return [new Kr([n, r], 0), new Kr([i, o], 0)];
      }
      class Nu {
        constructor(e, t, n) {
          if (((this.bitmap = e), (this.padding = t), (this.hashCount = n), t < 0 || t >= 8)) throw new Ru(`Invalid padding: ${t}`);
          if (n < 0) throw new Ru(`Invalid hash count: ${n}`);
          if (e.length > 0 && 0 === this.hashCount) throw new Ru(`Invalid hash count: ${n}`);
          if (0 === e.length && 0 !== t) throw new Ru(`Invalid padding when bitmap length is 0: ${t}`);
          (this.It = 8 * e.length - t), (this.Tt = Kr.fromNumber(this.It));
        }
        Et(e, t, n) {
          let r = e.add(t.multiply(Kr.fromNumber(n)));
          return 1 === r.compare(Cu) && (r = new Kr([r.getBits(0), r.getBits(1)], 0)), r.modulo(this.Tt).toNumber();
        }
        At(e) {
          return 0 != (this.bitmap[Math.floor(e / 8)] & (1 << e % 8));
        }
        vt(e) {
          if (0 === this.It) return !1;
          const t = ku(e),
            [n, r] = Ou(t);
          for (let i = 0; i < this.hashCount; i++) {
            const e = this.Et(n, r, i);
            if (!this.At(e)) return !1;
          }
          return !0;
        }
        static create(e, t, n) {
          const r = e % 8 == 0 ? 0 : 8 - (e % 8),
            i = new Uint8Array(Math.ceil(e / 8)),
            o = new Nu(i, r, t);
          return n.forEach(e => o.insert(e)), o;
        }
        insert(e) {
          if (0 === this.It) return;
          const t = ku(e),
            [n, r] = Ou(t);
          for (let i = 0; i < this.hashCount; i++) {
            const e = this.Et(n, r, i);
            this.Rt(e);
          }
        }
        Rt(e) {
          const t = Math.floor(e / 8),
            n = e % 8;
          this.bitmap[t] |= 1 << n;
        }
      }
      class Ru extends Error {
        constructor() {
          super(...arguments), (this.name = 'BloomFilterError');
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Pu {
        constructor(e, t, n, r, i) {
          (this.snapshotVersion = e),
            (this.targetChanges = t),
            (this.targetMismatches = n),
            (this.documentUpdates = r),
            (this.resolvedLimboDocuments = i);
        }
        static createSynthesizedRemoteEventForCurrentChange(e, t, n) {
          const r = new Map();
          return r.set(e, Du.createSynthesizedTargetChangeForCurrentChange(e, t, n)), new Pu(Ai.min(), r, new Uo(Ii), Aa(), La());
        }
      }
      class Du {
        constructor(e, t, n, r, i) {
          (this.resumeToken = e), (this.current = t), (this.addedDocuments = n), (this.modifiedDocuments = r), (this.removedDocuments = i);
        }
        static createSynthesizedTargetChangeForCurrentChange(e, t, n) {
          return new Du(n, t, La(), La(), La());
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Lu {
        constructor(e, t, n, r) {
          (this.Pt = e), (this.removedTargetIds = t), (this.key = n), (this.bt = r);
        }
      }
      class ju {
        constructor(e, t) {
          (this.targetId = e), (this.Vt = t);
        }
      }
      class Mu {
        constructor(e, t, n = Ko.EMPTY_BYTE_STRING, r = null) {
          (this.state = e), (this.targetIds = t), (this.resumeToken = n), (this.cause = r);
        }
      }
      class Fu {
        constructor() {
          (this.St = 0), (this.Dt = Bu()), (this.Ct = Ko.EMPTY_BYTE_STRING), (this.xt = !1), (this.Nt = !0);
        }
        get current() {
          return this.xt;
        }
        get resumeToken() {
          return this.Ct;
        }
        get kt() {
          return 0 !== this.St;
        }
        get Mt() {
          return this.Nt;
        }
        $t(e) {
          e.approximateByteSize() > 0 && ((this.Nt = !0), (this.Ct = e));
        }
        Ot() {
          let e = La(),
            t = La(),
            n = La();
          return (
            this.Dt.forEach((r, i) => {
              switch (i) {
                case 0:
                  e = e.add(r);
                  break;
                case 2:
                  t = t.add(r);
                  break;
                case 1:
                  n = n.add(r);
                  break;
                default:
                  oi();
              }
            }),
            new Du(this.Ct, this.xt, e, t, n)
          );
        }
        Ft() {
          (this.Nt = !1), (this.Dt = Bu());
        }
        Bt(e, t) {
          (this.Nt = !0), (this.Dt = this.Dt.insert(e, t));
        }
        Lt(e) {
          (this.Nt = !0), (this.Dt = this.Dt.remove(e));
        }
        qt() {
          this.St += 1;
        }
        Ut() {
          this.St -= 1;
        }
        Kt() {
          (this.Nt = !0), (this.xt = !0);
        }
      }
      class Uu {
        constructor(e) {
          (this.Gt = e), (this.Qt = new Map()), (this.jt = Aa()), (this.zt = Vu()), (this.Wt = new Uo(Ii));
        }
        Ht(e) {
          for (const t of e.Pt) e.bt && e.bt.isFoundDocument() ? this.Jt(t, e.bt) : this.Yt(t, e.key, e.bt);
          for (const t of e.removedTargetIds) this.Yt(t, e.key, e.bt);
        }
        Xt(e) {
          this.forEachTarget(e, t => {
            const n = this.Zt(t);
            switch (e.state) {
              case 0:
                this.te(t) && n.$t(e.resumeToken);
                break;
              case 1:
                n.Ut(), n.kt || n.Ft(), n.$t(e.resumeToken);
                break;
              case 2:
                n.Ut(), n.kt || this.removeTarget(t);
                break;
              case 3:
                this.te(t) && (n.Kt(), n.$t(e.resumeToken));
                break;
              case 4:
                this.te(t) && (this.ee(t), n.$t(e.resumeToken));
                break;
              default:
                oi();
            }
          });
        }
        forEachTarget(e, t) {
          e.targetIds.length > 0
            ? e.targetIds.forEach(t)
            : this.Qt.forEach((e, n) => {
                this.te(n) && t(n);
              });
        }
        ne(e) {
          var t;
          const n = e.targetId,
            r = e.Vt.count,
            i = this.se(n);
          if (i) {
            const o = i.target;
            if (na(o))
              if (0 === r) {
                const e = new Ni(o.path);
                this.Yt(n, e, xs.newNoDocument(e, Ai.min()));
              } else si(1 === r);
            else {
              const i = this.ie(n);
              if (i !== r) {
                const r = this.re(e, i);
                if (0 !== r) {
                  this.ee(n);
                  const e = 2 === r ? 'TargetPurposeExistenceFilterMismatchBloom' : 'TargetPurposeExistenceFilterMismatch';
                  this.Wt = this.Wt.insert(n, e);
                }
                null === (t = Tu.instance) ||
                  void 0 === t ||
                  t.notifyOnExistenceFilterMismatch(
                    (function (e, t, n) {
                      var r, i, o, s, a, u;
                      const c = { localCacheCount: t, existenceFilterCount: n.count },
                        l = n.unchangedNames;
                      return (
                        l &&
                          (c.bloomFilter = {
                            applied: 0 === e,
                            hashCount: null !== (r = null == l ? void 0 : l.hashCount) && void 0 !== r ? r : 0,
                            bitmapLength:
                              null !==
                                (s =
                                  null === (o = null === (i = null == l ? void 0 : l.bits) || void 0 === i ? void 0 : i.bitmap) || void 0 === o
                                    ? void 0
                                    : o.length) && void 0 !== s
                                ? s
                                : 0,
                            padding:
                              null !== (u = null === (a = null == l ? void 0 : l.bits) || void 0 === a ? void 0 : a.padding) && void 0 !== u ? u : 0
                          }),
                        c
                      );
                    })(
                      /**
                       * @license
                       * Copyright 2017 Google LLC
                       *
                       * Licensed under the Apache License, Version 2.0 (the "License");
                       * you may not use this file except in compliance with the License.
                       * You may obtain a copy of the License at
                       *
                       *   http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */ r,
                      i,
                      e.Vt
                    )
                  );
              }
            }
          }
        }
        re(e, t) {
          const { unchangedNames: n, count: r } = e.Vt;
          if (!n || !n.bits) return 1;
          const {
            bits: { bitmap: i = '', padding: o = 0 },
            hashCount: s = 0
          } = n;
          let a, u;
          try {
            a = Jo(i).toUint8Array();
          } catch (e) {
            if (e instanceof Wo)
              return (
                ri(
                  'Decoding the base64 bloom filter in existence filter failed (' +
                    e.message +
                    '); ignoring the bloom filter and falling back to full re-query.'
                ),
                1
              );
            throw e;
          }
          try {
            u = new Nu(a, o, s);
          } catch (e) {
            return ri(e instanceof Ru ? 'BloomFilter error: ' : 'Applying bloom filter failed: ', e), 1;
          }
          return 0 === u.It ? 1 : r !== t - this.oe(e.targetId, u) ? 2 : 0;
        }
        oe(e, t) {
          const n = this.Gt.getRemoteKeysForTarget(e);
          let r = 0;
          return (
            n.forEach(n => {
              const i = this.Gt.ue(),
                o = `projects/${i.projectId}/databases/${i.database}/documents/${n.path.canonicalString()}`;
              t.vt(o) || (this.Yt(e, n, null), r++);
            }),
            r
          );
        }
        ce(e) {
          const t = new Map();
          this.Qt.forEach((n, r) => {
            const i = this.se(r);
            if (i) {
              if (n.current && na(i.target)) {
                const t = new Ni(i.target.path);
                null !== this.jt.get(t) || this.ae(r, t) || this.Yt(r, t, xs.newNoDocument(t, e));
              }
              n.Mt && (t.set(r, n.Ot()), n.Ft());
            }
          });
          let n = La();
          this.zt.forEach((e, t) => {
            let r = !0;
            t.forEachWhile(e => {
              const t = this.se(e);
              return !t || 'TargetPurposeLimboResolution' === t.purpose || ((r = !1), !1);
            }),
              r && (n = n.add(e));
          }),
            this.jt.forEach((t, n) => n.setReadTime(e));
          const r = new Pu(e, t, this.Wt, this.jt, n);
          return (this.jt = Aa()), (this.zt = Vu()), (this.Wt = new Uo(Ii)), r;
        }
        Jt(e, t) {
          if (!this.te(e)) return;
          const n = this.ae(e, t.key) ? 2 : 0;
          this.Zt(e).Bt(t.key, n), (this.jt = this.jt.insert(t.key, t)), (this.zt = this.zt.insert(t.key, this.he(t.key).add(e)));
        }
        Yt(e, t, n) {
          if (!this.te(e)) return;
          const r = this.Zt(e);
          this.ae(e, t) ? r.Bt(t, 1) : r.Lt(t), (this.zt = this.zt.insert(t, this.he(t).delete(e))), n && (this.jt = this.jt.insert(t, n));
        }
        removeTarget(e) {
          this.Qt.delete(e);
        }
        ie(e) {
          const t = this.Zt(e).Ot();
          return this.Gt.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size;
        }
        qt(e) {
          this.Zt(e).qt();
        }
        Zt(e) {
          let t = this.Qt.get(e);
          return t || ((t = new Fu()), this.Qt.set(e, t)), t;
        }
        he(e) {
          let t = this.zt.get(e);
          return t || ((t = new $o(Ii)), (this.zt = this.zt.insert(e, t))), t;
        }
        te(e) {
          const t = null !== this.se(e);
          return t || ti('WatchChangeAggregator', 'Detected inactive target', e), t;
        }
        se(e) {
          const t = this.Qt.get(e);
          return t && t.kt ? null : this.Gt.le(e);
        }
        ee(e) {
          this.Qt.set(e, new Fu()),
            this.Gt.getRemoteKeysForTarget(e).forEach(t => {
              this.Yt(e, t, null);
            });
        }
        ae(e, t) {
          return this.Gt.getRemoteKeysForTarget(e).has(t);
        }
      }
      function Vu() {
        return new Uo(Ni.comparator);
      }
      function Bu() {
        return new Uo(Ni.comparator);
      }
      const $u = (() => {
          const e = { asc: 'ASCENDING', desc: 'DESCENDING' };
          return e;
        })(),
        qu = (() => {
          const e = {
            '<': 'LESS_THAN',
            '<=': 'LESS_THAN_OR_EQUAL',
            '>': 'GREATER_THAN',
            '>=': 'GREATER_THAN_OR_EQUAL',
            '==': 'EQUAL',
            '!=': 'NOT_EQUAL',
            'array-contains': 'ARRAY_CONTAINS',
            in: 'IN',
            'not-in': 'NOT_IN',
            'array-contains-any': 'ARRAY_CONTAINS_ANY'
          };
          return e;
        })(),
        zu = (() => {
          const e = { and: 'AND', or: 'OR' };
          return e;
        })();
      class Gu {
        constructor(e, t) {
          (this.databaseId = e), (this.useProto3Json = t);
        }
      }
      function Wu(e, t) {
        return e.useProto3Json || ro(t) ? t : { value: t };
      }
      function Hu(e, t) {
        return e.useProto3Json
          ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, '').replace('Z', '')}.${('000000000' + t.nanoseconds).slice(-9)}Z`
          : { seconds: '' + t.seconds, nanos: t.nanoseconds };
      }
      function Ku(e, t) {
        return e.useProto3Json ? t.toBase64() : t.toUint8Array();
      }
      function Qu(e, t) {
        return Hu(e, t.toTimestamp());
      }
      function Yu(e) {
        return (
          si(!!e),
          Ai.fromTimestamp(
            (function (e) {
              const t = Yo(e);
              return new Ti(t.seconds, t.nanos);
            })(e)
          )
        );
      }
      function Xu(e, t) {
        return (function (e) {
          return new Ci(['projects', e.projectId, 'databases', e.database]);
        })(e)
          .child('documents')
          .child(t)
          .canonicalString();
      }
      function Ju(e) {
        const t = Ci.fromString(e);
        return si(Sc(t)), t;
      }
      function Zu(e, t) {
        return Xu(e.databaseId, t.path);
      }
      function ec(e, t) {
        const n = Ju(t);
        if (n.get(1) !== e.databaseId.projectId)
          throw new li(ci.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' + n.get(1) + ' vs ' + e.databaseId.projectId);
        if (n.get(3) !== e.databaseId.database)
          throw new li(ci.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' + n.get(3) + ' vs ' + e.databaseId.database);
        return new Ni(ic(n));
      }
      function tc(e, t) {
        return Xu(e.databaseId, t);
      }
      function nc(e) {
        const t = Ju(e);
        return 4 === t.length ? Ci.emptyPath() : ic(t);
      }
      function rc(e) {
        return new Ci(['projects', e.databaseId.projectId, 'databases', e.databaseId.database]).canonicalString();
      }
      function ic(e) {
        return si(e.length > 4 && 'documents' === e.get(4)), e.popFirst(5);
      }
      function oc(e, t, n) {
        return { name: Zu(e, t), fields: n.value.mapValue.fields };
      }
      function sc(e, t, n) {
        const r = ec(e, t.name),
          i = Yu(t.updateTime),
          o = t.createTime ? Yu(t.createTime) : Ai.min(),
          s = new Ts({ mapValue: { fields: t.fields } }),
          a = xs.newFoundDocument(r, i, o, s);
        return n && a.setHasCommittedMutations(), n ? a.setHasCommittedMutations() : a;
      }
      function ac(e, t) {
        return 'found' in t
          ? (function (e, t) {
              si(!!t.found), t.found.name, t.found.updateTime;
              const n = ec(e, t.found.name),
                r = Yu(t.found.updateTime),
                i = t.found.createTime ? Yu(t.found.createTime) : Ai.min(),
                o = new Ts({ mapValue: { fields: t.found.fields } });
              return xs.newFoundDocument(n, r, i, o);
            })(e, t)
          : 'missing' in t
            ? (function (e, t) {
                si(!!t.missing), si(!!t.readTime);
                const n = ec(e, t.missing),
                  r = Yu(t.readTime);
                return xs.newNoDocument(n, r);
              })(e, t)
            : oi();
      }
      function uc(e, t) {
        let n;
        if ('targetChange' in t) {
          t.targetChange;
          const r = (function (e) {
              return 'NO_CHANGE' === e ? 0 : 'ADD' === e ? 1 : 'REMOVE' === e ? 2 : 'CURRENT' === e ? 3 : 'RESET' === e ? 4 : oi();
            })(t.targetChange.targetChangeType || 'NO_CHANGE'),
            i = t.targetChange.targetIds || [],
            o = (function (e, t) {
              return e.useProto3Json
                ? (si(void 0 === t || 'string' == typeof t), Ko.fromBase64String(t || ''))
                : (si(void 0 === t || t instanceof Uint8Array), Ko.fromUint8Array(t || new Uint8Array()));
            })(e, t.targetChange.resumeToken),
            s = t.targetChange.cause,
            a =
              s &&
              (function (e) {
                const t = void 0 === e.code ? ci.UNKNOWN : Su(e.code);
                return new li(t, e.message || '');
              })(s);
          n = new Mu(r, i, o, a || null);
        } else if ('documentChange' in t) {
          t.documentChange;
          const r = t.documentChange;
          r.document, r.document.name, r.document.updateTime;
          const i = ec(e, r.document.name),
            o = Yu(r.document.updateTime),
            s = r.document.createTime ? Yu(r.document.createTime) : Ai.min(),
            a = new Ts({ mapValue: { fields: r.document.fields } }),
            u = xs.newFoundDocument(i, o, s, a),
            c = r.targetIds || [],
            l = r.removedTargetIds || [];
          n = new Lu(c, l, u.key, u);
        } else if ('documentDelete' in t) {
          t.documentDelete;
          const r = t.documentDelete;
          r.document;
          const i = ec(e, r.document),
            o = r.readTime ? Yu(r.readTime) : Ai.min(),
            s = xs.newNoDocument(i, o),
            a = r.removedTargetIds || [];
          n = new Lu([], a, s.key, s);
        } else if ('documentRemove' in t) {
          t.documentRemove;
          const r = t.documentRemove;
          r.document;
          const i = ec(e, r.document),
            o = r.removedTargetIds || [];
          n = new Lu([], o, i, null);
        } else {
          if (!('filter' in t)) return oi();
          {
            t.filter;
            const e = t.filter;
            e.targetId;
            const { count: r = 0, unchangedNames: i } = e,
              o = new bu(r, i),
              s = e.targetId;
            n = new ju(s, o);
          }
        }
        return n;
      }
      function cc(e, t) {
        let n;
        if (t instanceof lu) n = { update: oc(e, t.key, t.value) };
        else if (t instanceof gu) n = { delete: Zu(e, t.key) };
        else if (t instanceof hu) n = { update: oc(e, t.key, t.data), updateMask: Ec(t.fieldMask) };
        else {
          if (!(t instanceof mu)) return oi();
          n = { verify: Zu(e, t.key) };
        }
        return (
          t.fieldTransforms.length > 0 &&
            (n.updateTransforms = t.fieldTransforms.map(e =>
              (function (e, t) {
                const n = t.transform;
                if (n instanceof Ga) return { fieldPath: t.field.canonicalString(), setToServerValue: 'REQUEST_TIME' };
                if (n instanceof Wa) return { fieldPath: t.field.canonicalString(), appendMissingElements: { values: n.elements } };
                if (n instanceof Ka) return { fieldPath: t.field.canonicalString(), removeAllFromArray: { values: n.elements } };
                if (n instanceof Ya) return { fieldPath: t.field.canonicalString(), increment: n.gt };
                throw oi();
              })(0, e)
            )),
          t.precondition.isNone ||
            (n.currentDocument = (function (e, t) {
              return void 0 !== t.updateTime ? { updateTime: Qu(e, t.updateTime) } : void 0 !== t.exists ? { exists: t.exists } : oi();
            })(e, t.precondition)),
          n
        );
      }
      function lc(e, t) {
        const n = t.currentDocument
            ? (function (e) {
                return void 0 !== e.updateTime ? nu.updateTime(Yu(e.updateTime)) : void 0 !== e.exists ? nu.exists(e.exists) : nu.none();
              })(t.currentDocument)
            : nu.none(),
          r = t.updateTransforms
            ? t.updateTransforms.map(t =>
                (function (e, t) {
                  let n = null;
                  if ('setToServerValue' in t) si('REQUEST_TIME' === t.setToServerValue), (n = new Ga());
                  else if ('appendMissingElements' in t) {
                    const e = t.appendMissingElements.values || [];
                    n = new Wa(e);
                  } else if ('removeAllFromArray' in t) {
                    const e = t.removeAllFromArray.values || [];
                    n = new Ka(e);
                  } else 'increment' in t ? (n = new Ya(e, t.increment)) : oi();
                  const r = Oi.fromServerFormat(t.fieldPath);
                  return new Za(r, n);
                })(e, t)
              )
            : [];
        if (t.update) {
          t.update.name;
          const i = ec(e, t.update.name),
            o = new Ts({ mapValue: { fields: t.update.fields } });
          if (t.updateMask) {
            const e = (function (e) {
              const t = e.fieldPaths || [];
              return new Go(t.map(e => Oi.fromServerFormat(e)));
            })(t.updateMask);
            return new hu(i, o, e, n, r);
          }
          return new lu(i, o, n, r);
        }
        if (t.delete) {
          const r = ec(e, t.delete);
          return new gu(r, n);
        }
        if (t.verify) {
          const r = ec(e, t.verify);
          return new mu(r, n);
        }
        return oi();
      }
      function hc(e, t) {
        return e && e.length > 0
          ? (si(void 0 !== t),
            e.map(e =>
              (function (e, t) {
                let n = e.updateTime ? Yu(e.updateTime) : Yu(t);
                return n.isEqual(Ai.min()) && (n = Yu(t)), new tu(n, e.transformResults || []);
              })(e, t)
            ))
          : [];
      }
      function fc(e, t) {
        return { documents: [tc(e, t.path)] };
      }
      function dc(e, t) {
        const n = { structuredQuery: {} },
          r = t.path;
        null !== t.collectionGroup
          ? ((n.parent = tc(e, r)), (n.structuredQuery.from = [{ collectionId: t.collectionGroup, allDescendants: !0 }]))
          : ((n.parent = tc(e, r.popLast())), (n.structuredQuery.from = [{ collectionId: r.lastSegment() }]));
        const i = (function (e) {
          if (0 !== e.length) return Ic(Ls.create(e, 'and'));
        })(t.filters);
        i && (n.structuredQuery.where = i);
        const o = (function (e) {
          if (0 !== e.length)
            return e.map(e =>
              (function (e) {
                return { field: bc(e.field), direction: vc(e.dir) };
              })(e)
            );
        })(t.orderBy);
        o && (n.structuredQuery.orderBy = o);
        const s = Wu(e, t.limit);
        var a;
        return (
          null !== s && (n.structuredQuery.limit = s),
          t.startAt && (n.structuredQuery.startAt = { before: (a = t.startAt).inclusive, values: a.position }),
          t.endAt &&
            (n.structuredQuery.endAt = (function (e) {
              return { before: !e.inclusive, values: e.position };
            })(t.endAt)),
          n
        );
      }
      function pc(e) {
        let t = nc(e.parent);
        const n = e.structuredQuery,
          r = n.from ? n.from.length : 0;
        let i = null;
        if (r > 0) {
          si(1 === r);
          const e = n.from[0];
          e.allDescendants ? (i = e.collectionId) : (t = t.child(e.collectionId));
        }
        let o = [];
        n.where &&
          (o = (function (e) {
            const t = mc(e);
            return t instanceof Ls && Fs(t) ? t.getFilters() : [t];
          })(n.where));
        let s = [];
        n.orderBy &&
          (s = n.orderBy.map(e =>
            (function (e) {
              return new Ns(
                _c(e.field),
                (function (e) {
                  switch (e) {
                    case 'ASCENDING':
                      return 'asc';
                    case 'DESCENDING':
                      return 'desc';
                    default:
                      return;
                  }
                })(e.direction)
              );
            })(e)
          ));
        let a = null;
        n.limit &&
          (a = (function (e) {
            let t;
            return (t = 'object' == typeof e ? e.value : e), ro(t) ? null : t;
          })(n.limit));
        let u = null;
        n.startAt &&
          (u = (function (e) {
            const t = !!e.before,
              n = e.values || [];
            return new Cs(n, t);
          })(n.startAt));
        let c = null;
        return (
          n.endAt &&
            (c = (function (e) {
              const t = !e.before,
                n = e.values || [];
              return new Cs(n, t);
            })(n.endAt)),
          aa(t, i, s, o, a, 'F', u, c)
        );
      }
      function gc(e, t) {
        const n = (function (e) {
          switch (e) {
            case 'TargetPurposeListen':
              return null;
            case 'TargetPurposeExistenceFilterMismatch':
              return 'existence-filter-mismatch';
            case 'TargetPurposeExistenceFilterMismatchBloom':
              return 'existence-filter-mismatch-bloom';
            case 'TargetPurposeLimboResolution':
              return 'limbo-document';
            default:
              return oi();
          }
        })(t.purpose);
        return null == n ? null : { 'goog-listen-tags': n };
      }
      function mc(e) {
        return void 0 !== e.unaryFilter
          ? (function (e) {
              switch (e.unaryFilter.op) {
                case 'IS_NAN':
                  const t = _c(e.unaryFilter.field);
                  return Ds.create(t, '==', { doubleValue: NaN });
                case 'IS_NULL':
                  const n = _c(e.unaryFilter.field);
                  return Ds.create(n, '==', { nullValue: 'NULL_VALUE' });
                case 'IS_NOT_NAN':
                  const r = _c(e.unaryFilter.field);
                  return Ds.create(r, '!=', { doubleValue: NaN });
                case 'IS_NOT_NULL':
                  const i = _c(e.unaryFilter.field);
                  return Ds.create(i, '!=', { nullValue: 'NULL_VALUE' });
                default:
                  return oi();
              }
            })(e)
          : void 0 !== e.fieldFilter
            ? (function (e) {
                return Ds.create(
                  _c(e.fieldFilter.field),
                  (function (e) {
                    switch (e) {
                      case 'EQUAL':
                        return '==';
                      case 'NOT_EQUAL':
                        return '!=';
                      case 'GREATER_THAN':
                        return '>';
                      case 'GREATER_THAN_OR_EQUAL':
                        return '>=';
                      case 'LESS_THAN':
                        return '<';
                      case 'LESS_THAN_OR_EQUAL':
                        return '<=';
                      case 'ARRAY_CONTAINS':
                        return 'array-contains';
                      case 'IN':
                        return 'in';
                      case 'NOT_IN':
                        return 'not-in';
                      case 'ARRAY_CONTAINS_ANY':
                        return 'array-contains-any';
                      default:
                        return oi();
                    }
                  })(e.fieldFilter.op),
                  e.fieldFilter.value
                );
              })(e)
            : void 0 !== e.compositeFilter
              ? (function (e) {
                  return Ls.create(
                    e.compositeFilter.filters.map(e => mc(e)),
                    (function (e) {
                      switch (e) {
                        case 'AND':
                          return 'and';
                        case 'OR':
                          return 'or';
                        default:
                          return oi();
                      }
                    })(e.compositeFilter.op)
                  );
                })(e)
              : oi();
      }
      function vc(e) {
        return $u[e];
      }
      function yc(e) {
        return qu[e];
      }
      function wc(e) {
        return zu[e];
      }
      function bc(e) {
        return { fieldPath: e.canonicalString() };
      }
      function _c(e) {
        return Oi.fromServerFormat(e.fieldPath);
      }
      function Ic(e) {
        return e instanceof Ds
          ? (function (e) {
              if ('==' === e.op) {
                if (vs(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NAN' } };
                if (ms(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NULL' } };
              } else if ('!=' === e.op) {
                if (vs(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NOT_NAN' } };
                if (ms(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NOT_NULL' } };
              }
              return { fieldFilter: { field: bc(e.field), op: yc(e.op), value: e.value } };
            })(e)
          : e instanceof Ls
            ? (function (e) {
                const t = e.getFilters().map(e => Ic(e));
                return 1 === t.length ? t[0] : { compositeFilter: { op: wc(e.op), filters: t } };
              })(e)
            : oi();
      }
      function Ec(e) {
        const t = [];
        return e.fields.forEach(e => t.push(e.canonicalString())), { fieldPaths: t };
      }
      function Sc(e) {
        return e.length >= 4 && 'projects' === e.get(0) && 'databases' === e.get(2);
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tc {
        constructor(e, t, n, r, i = Ai.min(), o = Ai.min(), s = Ko.EMPTY_BYTE_STRING, a = null) {
          (this.target = e),
            (this.targetId = t),
            (this.purpose = n),
            (this.sequenceNumber = r),
            (this.snapshotVersion = i),
            (this.lastLimboFreeSnapshotVersion = o),
            (this.resumeToken = s),
            (this.expectedCount = a);
        }
        withSequenceNumber(e) {
          return new Tc(
            this.target,
            this.targetId,
            this.purpose,
            e,
            this.snapshotVersion,
            this.lastLimboFreeSnapshotVersion,
            this.resumeToken,
            this.expectedCount
          );
        }
        withResumeToken(e, t) {
          return new Tc(this.target, this.targetId, this.purpose, this.sequenceNumber, t, this.lastLimboFreeSnapshotVersion, e, null);
        }
        withExpectedCount(e) {
          return new Tc(
            this.target,
            this.targetId,
            this.purpose,
            this.sequenceNumber,
            this.snapshotVersion,
            this.lastLimboFreeSnapshotVersion,
            this.resumeToken,
            e
          );
        }
        withLastLimboFreeSnapshotVersion(e) {
          return new Tc(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ac {
        constructor(e) {
          this.fe = e;
        }
      }
      function xc(e, t) {
        let n;
        if (t.document) n = sc(e.fe, t.document, !!t.hasCommittedMutations);
        else if (t.noDocument) {
          const e = Ni.fromSegments(t.noDocument.path),
            r = Nc(t.noDocument.readTime);
          (n = xs.newNoDocument(e, r)), t.hasCommittedMutations && n.setHasCommittedMutations();
        } else {
          if (!t.unknownDocument) return oi();
          {
            const e = Ni.fromSegments(t.unknownDocument.path),
              r = Nc(t.unknownDocument.version);
            n = xs.newUnknownDocument(e, r);
          }
        }
        return (
          t.readTime &&
            n.setReadTime(
              (function (e) {
                const t = new Ti(e[0], e[1]);
                return Ai.fromTimestamp(t);
              })(t.readTime)
            ),
          n
        );
      }
      function Cc(e, t) {
        const n = t.key,
          r = {
            prefixPath: n.getCollectionPath().popLast().toArray(),
            collectionGroup: n.collectionGroup,
            documentId: n.path.lastSegment(),
            readTime: kc(t.readTime),
            hasCommittedMutations: t.hasCommittedMutations
          };
        if (t.isFoundDocument())
          r.document = (function (e, t) {
            return {
              name: Zu(e, t.key),
              fields: t.data.value.mapValue.fields,
              updateTime: Hu(e, t.version.toTimestamp()),
              createTime: Hu(e, t.createTime.toTimestamp())
            };
          })(e.fe, t);
        else if (t.isNoDocument()) r.noDocument = { path: n.path.toArray(), readTime: Oc(t.version) };
        else {
          if (!t.isUnknownDocument()) return oi();
          r.unknownDocument = { path: n.path.toArray(), version: Oc(t.version) };
        }
        return r;
      }
      function kc(e) {
        const t = e.toTimestamp();
        return [t.seconds, t.nanoseconds];
      }
      function Oc(e) {
        const t = e.toTimestamp();
        return { seconds: t.seconds, nanoseconds: t.nanoseconds };
      }
      function Nc(e) {
        const t = new Ti(e.seconds, e.nanoseconds);
        return Ai.fromTimestamp(t);
      }
      function Rc(e, t) {
        const n = (t.baseMutations || []).map(t => lc(e.fe, t));
        for (let o = 0; o < t.mutations.length - 1; ++o) {
          const e = t.mutations[o];
          if (o + 1 < t.mutations.length && void 0 !== t.mutations[o + 1].transform) {
            const n = t.mutations[o + 1];
            (e.updateTransforms = n.transform.fieldTransforms), t.mutations.splice(o + 1, 1), ++o;
          }
        }
        const r = t.mutations.map(t => lc(e.fe, t)),
          i = Ti.fromMillis(t.localWriteTimeMs);
        return new vu(t.batchId, i, n, r);
      }
      function Pc(e) {
        const t = Nc(e.readTime),
          n = void 0 !== e.lastLimboFreeSnapshotVersion ? Nc(e.lastLimboFreeSnapshotVersion) : Ai.min();
        let r;
        var i;
        return (
          void 0 !== e.query.documents
            ? (si(1 === (i = e.query).documents.length), (r = pa(ua(nc(i.documents[0])))))
            : (r = (function (e) {
                return pa(pc(e));
              })(e.query)),
          new Tc(r, e.targetId, 'TargetPurposeListen', e.lastListenSequenceNumber, t, n, Ko.fromBase64String(e.resumeToken))
        );
      }
      function Dc(e, t) {
        const n = Oc(t.snapshotVersion),
          r = Oc(t.lastLimboFreeSnapshotVersion);
        let i;
        i = na(t.target) ? fc(e.fe, t.target) : dc(e.fe, t.target);
        const o = t.resumeToken.toBase64();
        return {
          targetId: t.targetId,
          canonicalId: ea(t.target),
          readTime: n,
          resumeToken: o,
          lastListenSequenceNumber: t.sequenceNumber,
          lastLimboFreeSnapshotVersion: r,
          query: i
        };
      }
      function Lc(e) {
        const t = pc({ parent: e.parent, structuredQuery: e.structuredQuery });
        return 'LAST' === e.limitType ? ma(t, t.limit, 'L') : t;
      }
      function jc(e, t) {
        return new wu(t.largestBatchId, lc(e.fe, t.overlayMutation));
      }
      function Mc(e, t) {
        const n = t.path.lastSegment();
        return [e, so(t.path.popLast()), n];
      }
      function Fc(e, t, n, r) {
        return {
          indexId: e,
          uid: t.uid || '',
          sequenceNumber: n,
          readTime: Oc(r.readTime),
          documentKey: so(r.documentKey.path),
          largestBatchId: r.largestBatchId
        };
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Uc {
        getBundleMetadata(e, t) {
          return Vc(e)
            .get(t)
            .next(e => {
              if (e) return { id: (t = e).bundleId, createTime: Nc(t.createTime), version: t.version };
              var t;
            });
        }
        saveBundleMetadata(e, t) {
          return Vc(e).put({ bundleId: (n = t).id, createTime: Oc(Yu(n.createTime)), version: n.version });
          var n;
        }
        getNamedQuery(e, t) {
          return Bc(e)
            .get(t)
            .next(e => {
              if (e) return { name: (t = e).name, query: Lc(t.bundledQuery), readTime: Nc(t.readTime) };
              var t;
            });
        }
        saveNamedQuery(e, t) {
          return Bc(e).put(
            (function (e) {
              return { name: e.name, readTime: Oc(Yu(e.readTime)), bundledQuery: e.bundledQuery };
            })(t)
          );
        }
      }
      function Vc(e) {
        return Lo(e, 'bundles');
      }
      function Bc(e) {
        return Lo(e, 'namedQueries');
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class $c {
        constructor(e, t) {
          (this.serializer = e), (this.userId = t);
        }
        static de(e, t) {
          const n = t.uid || '';
          return new $c(e, n);
        }
        getOverlay(e, t) {
          return qc(e)
            .get(Mc(this.userId, t))
            .next(e => (e ? jc(this.serializer, e) : null));
        }
        getOverlays(e, t) {
          const n = Oa();
          return zi
            .forEach(t, t =>
              this.getOverlay(e, t).next(e => {
                null !== e && n.set(t, e);
              })
            )
            .next(() => n);
        }
        saveOverlays(e, t, n) {
          const r = [];
          return (
            n.forEach((n, i) => {
              const o = new wu(t, i);
              r.push(this.we(e, o));
            }),
            zi.waitFor(r)
          );
        }
        removeOverlaysForBatchId(e, t, n) {
          const r = new Set();
          t.forEach(e => r.add(so(e.getCollectionPath())));
          const i = [];
          return (
            r.forEach(t => {
              const r = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, n + 1], !1, !0);
              i.push(qc(e).J('collectionPathOverlayIndex', r));
            }),
            zi.waitFor(i)
          );
        }
        getOverlaysForCollection(e, t, n) {
          const r = Oa(),
            i = so(t),
            o = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], !0);
          return qc(e)
            .j('collectionPathOverlayIndex', o)
            .next(e => {
              for (const t of e) {
                const e = jc(this.serializer, t);
                r.set(e.getKey(), e);
              }
              return r;
            });
        }
        getOverlaysForCollectionGroup(e, t, n, r) {
          const i = Oa();
          let o;
          const s = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, Number.POSITIVE_INFINITY], !0);
          return qc(e)
            .X({ index: 'collectionGroupOverlayIndex', range: s }, (e, t, n) => {
              const s = jc(this.serializer, t);
              i.size() < r || s.largestBatchId === o ? (i.set(s.getKey(), s), (o = s.largestBatchId)) : n.done();
            })
            .next(() => i);
        }
        we(e, t) {
          return qc(e).put(
            (function (e, t, n) {
              const [r, i, o] = Mc(t, n.mutation.key);
              return {
                userId: t,
                collectionPath: i,
                documentId: o,
                collectionGroup: n.mutation.key.getCollectionGroup(),
                largestBatchId: n.largestBatchId,
                overlayMutation: cc(e.fe, n.mutation)
              };
            })(this.serializer, this.userId, t)
          );
        }
      }
      function qc(e) {
        return Lo(e, 'documentOverlays');
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class zc {
        constructor() {}
        _e(e, t) {
          this.me(e, t), t.ge();
        }
        me(e, t) {
          if ('nullValue' in e) this.ye(t, 5);
          else if ('booleanValue' in e) this.ye(t, 10), t.pe(e.booleanValue ? 1 : 0);
          else if ('integerValue' in e) this.ye(t, 15), t.pe(Xo(e.integerValue));
          else if ('doubleValue' in e) {
            const n = Xo(e.doubleValue);
            isNaN(n) ? this.ye(t, 13) : (this.ye(t, 15), io(n) ? t.pe(0) : t.pe(n));
          } else if ('timestampValue' in e) {
            const n = e.timestampValue;
            this.ye(t, 20), 'string' == typeof n ? t.Ie(n) : (t.Ie(`${n.seconds || ''}`), t.pe(n.nanos || 0));
          } else if ('stringValue' in e) this.Te(e.stringValue, t), this.Ee(t);
          else if ('bytesValue' in e) this.ye(t, 30), t.Ae(Jo(e.bytesValue)), this.Ee(t);
          else if ('referenceValue' in e) this.ve(e.referenceValue, t);
          else if ('geoPointValue' in e) {
            const n = e.geoPointValue;
            this.ye(t, 45), t.pe(n.latitude || 0), t.pe(n.longitude || 0);
          } else
            'mapValue' in e
              ? bs(e)
                ? this.ye(t, Number.MAX_SAFE_INTEGER)
                : (this.Re(e.mapValue, t), this.Ee(t))
              : 'arrayValue' in e
                ? (this.Pe(e.arrayValue, t), this.Ee(t))
                : oi();
        }
        Te(e, t) {
          this.ye(t, 25), this.be(e, t);
        }
        be(e, t) {
          t.Ie(e);
        }
        Re(e, t) {
          const n = e.fields || {};
          this.ye(t, 55);
          for (const r of Object.keys(n)) this.Te(r, t), this.me(n[r], t);
        }
        Pe(e, t) {
          const n = e.values || [];
          this.ye(t, 50);
          for (const r of n) this.me(r, t);
        }
        ve(e, t) {
          this.ye(t, 37),
            Ni.fromName(e).path.forEach(e => {
              this.ye(t, 60), this.be(e, t);
            });
        }
        ye(e, t) {
          e.pe(t);
        }
        Ee(e) {
          e.pe(2);
        }
      }
      function Gc(e) {
        if (0 === e) return 8;
        let t = 0;
        return e >> 4 == 0 && ((t += 4), (e <<= 4)), e >> 6 == 0 && ((t += 2), (e <<= 2)), e >> 7 == 0 && (t += 1), t;
      }
      function Wc(e) {
        const t =
          64 -
          (function (e) {
            let t = 0;
            for (let n = 0; n < 8; ++n) {
              const r = Gc(255 & e[n]);
              if (((t += r), 8 !== r)) break;
            }
            return t;
          })(e);
        return Math.ceil(t / 8);
      }
      zc.Ve = new zc();
      class Hc {
        constructor() {
          (this.buffer = new Uint8Array(1024)), (this.position = 0);
        }
        Se(e) {
          const t = e[Symbol.iterator]();
          let n = t.next();
          for (; !n.done; ) this.De(n.value), (n = t.next());
          this.Ce();
        }
        xe(e) {
          const t = e[Symbol.iterator]();
          let n = t.next();
          for (; !n.done; ) this.Ne(n.value), (n = t.next());
          this.ke();
        }
        Me(e) {
          for (const t of e) {
            const e = t.charCodeAt(0);
            if (e < 128) this.De(e);
            else if (e < 2048) this.De(960 | (e >>> 6)), this.De(128 | (63 & e));
            else if (t < '\ud800' || '\udbff' < t) this.De(480 | (e >>> 12)), this.De(128 | (63 & (e >>> 6))), this.De(128 | (63 & e));
            else {
              const e = t.codePointAt(0);
              this.De(240 | (e >>> 18)), this.De(128 | (63 & (e >>> 12))), this.De(128 | (63 & (e >>> 6))), this.De(128 | (63 & e));
            }
          }
          this.Ce();
        }
        $e(e) {
          for (const t of e) {
            const e = t.charCodeAt(0);
            if (e < 128) this.Ne(e);
            else if (e < 2048) this.Ne(960 | (e >>> 6)), this.Ne(128 | (63 & e));
            else if (t < '\ud800' || '\udbff' < t) this.Ne(480 | (e >>> 12)), this.Ne(128 | (63 & (e >>> 6))), this.Ne(128 | (63 & e));
            else {
              const e = t.codePointAt(0);
              this.Ne(240 | (e >>> 18)), this.Ne(128 | (63 & (e >>> 12))), this.Ne(128 | (63 & (e >>> 6))), this.Ne(128 | (63 & e));
            }
          }
          this.ke();
        }
        Oe(e) {
          const t = this.Fe(e),
            n = Wc(t);
          this.Be(1 + n), (this.buffer[this.position++] = 255 & n);
          for (let r = t.length - n; r < t.length; ++r) this.buffer[this.position++] = 255 & t[r];
        }
        Le(e) {
          const t = this.Fe(e),
            n = Wc(t);
          this.Be(1 + n), (this.buffer[this.position++] = ~(255 & n));
          for (let r = t.length - n; r < t.length; ++r) this.buffer[this.position++] = ~(255 & t[r]);
        }
        qe() {
          this.Ue(255), this.Ue(255);
        }
        Ke() {
          this.Ge(255), this.Ge(255);
        }
        reset() {
          this.position = 0;
        }
        seed(e) {
          this.Be(e.length), this.buffer.set(e, this.position), (this.position += e.length);
        }
        Qe() {
          return this.buffer.slice(0, this.position);
        }
        Fe(e) {
          const t = (function (e) {
              const t = new DataView(new ArrayBuffer(8));
              return t.setFloat64(0, e, !1), new Uint8Array(t.buffer);
            })(e),
            n = 0 != (128 & t[0]);
          t[0] ^= n ? 255 : 128;
          for (let r = 1; r < t.length; ++r) t[r] ^= n ? 255 : 0;
          return t;
        }
        De(e) {
          const t = 255 & e;
          0 === t ? (this.Ue(0), this.Ue(255)) : 255 === t ? (this.Ue(255), this.Ue(0)) : this.Ue(t);
        }
        Ne(e) {
          const t = 255 & e;
          0 === t ? (this.Ge(0), this.Ge(255)) : 255 === t ? (this.Ge(255), this.Ge(0)) : this.Ge(e);
        }
        Ce() {
          this.Ue(0), this.Ue(1);
        }
        ke() {
          this.Ge(0), this.Ge(1);
        }
        Ue(e) {
          this.Be(1), (this.buffer[this.position++] = e);
        }
        Ge(e) {
          this.Be(1), (this.buffer[this.position++] = ~e);
        }
        Be(e) {
          const t = e + this.position;
          if (t <= this.buffer.length) return;
          let n = 2 * this.buffer.length;
          n < t && (n = t);
          const r = new Uint8Array(n);
          r.set(this.buffer), (this.buffer = r);
        }
      }
      class Kc {
        constructor(e) {
          this.je = e;
        }
        Ae(e) {
          this.je.Se(e);
        }
        Ie(e) {
          this.je.Me(e);
        }
        pe(e) {
          this.je.Oe(e);
        }
        ge() {
          this.je.qe();
        }
      }
      class Qc {
        constructor(e) {
          this.je = e;
        }
        Ae(e) {
          this.je.xe(e);
        }
        Ie(e) {
          this.je.$e(e);
        }
        pe(e) {
          this.je.Le(e);
        }
        ge() {
          this.je.Ke();
        }
      }
      class Yc {
        constructor() {
          (this.je = new Hc()), (this.ze = new Kc(this.je)), (this.We = new Qc(this.je));
        }
        seed(e) {
          this.je.seed(e);
        }
        He(e) {
          return 0 === e ? this.ze : this.We;
        }
        Qe() {
          return this.je.Qe();
        }
        reset() {
          this.je.reset();
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Xc {
        constructor(e, t, n, r) {
          (this.indexId = e), (this.documentKey = t), (this.arrayValue = n), (this.directionalValue = r);
        }
        Je() {
          const e = this.directionalValue.length,
            t = 0 === e || 255 === this.directionalValue[e - 1] ? e + 1 : e,
            n = new Uint8Array(t);
          return (
            n.set(this.directionalValue, 0),
            t !== e ? n.set([0], this.directionalValue.length) : ++n[n.length - 1],
            new Xc(this.indexId, this.documentKey, this.arrayValue, n)
          );
        }
      }
      function Jc(e, t) {
        let n = e.indexId - t.indexId;
        return 0 !== n
          ? n
          : ((n = Zc(e.arrayValue, t.arrayValue)),
            0 !== n ? n : ((n = Zc(e.directionalValue, t.directionalValue)), 0 !== n ? n : Ni.comparator(e.documentKey, t.documentKey)));
      }
      function Zc(e, t) {
        for (let n = 0; n < e.length && n < t.length; ++n) {
          const r = e[n] - t[n];
          if (0 !== r) return r;
        }
        return e.length - t.length;
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class el {
        constructor(e) {
          (this.collectionId = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment()), (this.Ye = e.orderBy), (this.Xe = []);
          for (const t of e.filters) {
            const e = t;
            e.isInequality() ? (this.Ze = e) : this.Xe.push(e);
          }
        }
        tn(e) {
          si(e.collectionGroup === this.collectionId);
          const t = Pi(e);
          if (void 0 !== t && !this.en(t)) return !1;
          const n = Di(e);
          let r = new Set(),
            i = 0,
            o = 0;
          for (; i < n.length && this.en(n[i]); ++i) r = r.add(n[i].fieldPath.canonicalString());
          if (i === n.length) return !0;
          if (void 0 !== this.Ze) {
            if (!r.has(this.Ze.field.canonicalString())) {
              const e = n[i];
              if (!this.nn(this.Ze, e) || !this.sn(this.Ye[o++], e)) return !1;
            }
            ++i;
          }
          for (; i < n.length; ++i) {
            const e = n[i];
            if (o >= this.Ye.length || !this.sn(this.Ye[o++], e)) return !1;
          }
          return !0;
        }
        en(e) {
          for (const t of this.Xe) if (this.nn(t, e)) return !0;
          return !1;
        }
        nn(e, t) {
          if (void 0 === e || !e.field.isEqual(t.fieldPath)) return !1;
          const n = 'array-contains' === e.op || 'array-contains-any' === e.op;
          return (2 === t.kind) === n;
        }
