remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
        sn(e, t) {
          return !!e.field.isEqual(t.fieldPath) && ((0 === t.kind && 'asc' === e.dir) || (1 === t.kind && 'desc' === e.dir));
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function tl(e) {
        var t, n;
        if ((si(e instanceof Ds || e instanceof Ls), e instanceof Ds)) {
          if (e instanceof Qs) {
            const r =
              (null === (n = null === (t = e.value.arrayValue) || void 0 === t ? void 0 : t.values) || void 0 === n
                ? void 0
                : n.map(t => Ds.create(e.field, '==', t))) || [];
            return Ls.create(r, 'or');
          }
          return e;
        }
        const r = e.filters.map(e => tl(e));
        return Ls.create(r, e.op);
      }
      function nl(e) {
        if (0 === e.getFilters().length) return [];
        const t = sl(tl(e));
        return si(ol(t)), rl(t) || il(t) ? [t] : t.getFilters();
      }
      function rl(e) {
        return e instanceof Ds;
      }
      function il(e) {
        return e instanceof Ls && Fs(e);
      }
      function ol(e) {
        return (
          rl(e) ||
          il(e) ||
          (function (e) {
            if (e instanceof Ls && Ms(e)) {
              for (const t of e.getFilters()) if (!rl(t) && !il(t)) return !1;
              return !0;
            }
            return !1;
          })(e)
        );
      }
      function sl(e) {
        if ((si(e instanceof Ds || e instanceof Ls), e instanceof Ds)) return e;
        if (1 === e.filters.length) return sl(e.filters[0]);
        const t = e.filters.map(e => sl(e));
        let n = Ls.create(t, e.op);
        return (n = cl(n)), ol(n) ? n : (si(n instanceof Ls), si(js(n)), si(n.filters.length > 1), n.filters.reduce((e, t) => al(e, t)));
      }
      function al(e, t) {
        let n;
        return (
          si(e instanceof Ds || e instanceof Ls),
          si(t instanceof Ds || t instanceof Ls),
          (n =
            e instanceof Ds
              ? t instanceof Ds
                ? (function (e, t) {
                    return Ls.create([e, t], 'and');
                  })(e, t)
                : ul(e, t)
              : t instanceof Ds
                ? ul(t, e)
                : (function (e, t) {
                    if ((si(e.filters.length > 0 && t.filters.length > 0), js(e) && js(t))) return $s(e, t.getFilters());
                    const n = Ms(e) ? e : t,
                      r = Ms(e) ? t : e,
                      i = n.filters.map(e => al(e, r));
                    return Ls.create(i, 'or');
                  })(e, t)),
          cl(n)
        );
      }
      function ul(e, t) {
        if (js(t)) return $s(t, e.getFilters());
        {
          const n = t.filters.map(t => al(e, t));
          return Ls.create(n, 'or');
        }
      }
      function cl(e) {
        if ((si(e instanceof Ds || e instanceof Ls), e instanceof Ds)) return e;
        const t = e.getFilters();
        if (1 === t.length) return cl(t[0]);
        if (Us(e)) return e;
        const n = t.map(e => cl(e)),
          r = [];
        return (
          n.forEach(t => {
            t instanceof Ds ? r.push(t) : t instanceof Ls && (t.op === e.op ? r.push(...t.filters) : r.push(t));
          }),
          1 === r.length ? r[0] : Ls.create(r, e.op)
        );
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class ll {
        constructor() {
          this.rn = new hl();
        }
        addToCollectionParentIndex(e, t) {
          return this.rn.add(t), zi.resolve();
        }
        getCollectionParents(e, t) {
          return zi.resolve(this.rn.getEntries(t));
        }
        addFieldIndex(e, t) {
          return zi.resolve();
        }
        deleteFieldIndex(e, t) {
          return zi.resolve();
        }
        getDocumentsMatchingTarget(e, t) {
          return zi.resolve(null);
        }
        getIndexType(e, t) {
          return zi.resolve(0);
        }
        getFieldIndexes(e, t) {
          return zi.resolve([]);
        }
        getNextCollectionGroupToUpdate(e) {
          return zi.resolve(null);
        }
        getMinOffset(e, t) {
          return zi.resolve(Ui.min());
        }
        getMinOffsetFromCollectionGroup(e, t) {
          return zi.resolve(Ui.min());
        }
        updateCollectionGroup(e, t, n) {
          return zi.resolve();
        }
        updateIndexEntries(e, t) {
          return zi.resolve();
        }
      }
      class hl {
        constructor() {
          this.index = {};
        }
        add(e) {
          const t = e.lastSegment(),
            n = e.popLast(),
            r = this.index[t] || new $o(Ci.comparator),
            i = !r.has(n);
          return (this.index[t] = r.add(n)), i;
        }
        has(e) {
          const t = e.lastSegment(),
            n = e.popLast(),
            r = this.index[t];
          return r && r.has(n);
        }
        getEntries(e) {
          return (this.index[e] || new $o(Ci.comparator)).toArray();
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const fl = new Uint8Array(0);
      class dl {
        constructor(e, t) {
          (this.user = e),
            (this.databaseId = t),
            (this.on = new hl()),
            (this.un = new Sa(
              e => ea(e),
              (e, t) => ta(e, t)
            )),
            (this.uid = e.uid || '');
        }
        addToCollectionParentIndex(e, t) {
          if (!this.on.has(t)) {
            const n = t.lastSegment(),
              r = t.popLast();
            e.addOnCommittedListener(() => {
              this.on.add(t);
            });
            const i = { collectionId: n, parent: so(r) };
            return pl(e).put(i);
          }
          return zi.resolve();
        }
        getCollectionParents(e, t) {
          const n = [],
            r = IDBKeyRange.bound([t, ''], [Si(t), ''], !1, !0);
          return pl(e)
            .j(r)
            .next(e => {
              for (const r of e) {
                if (r.collectionId !== t) break;
                n.push(co(r.parent));
              }
              return n;
            });
        }
        addFieldIndex(e, t) {
          const n = ml(e),
            r = (function (e) {
              return { indexId: e.indexId, collectionGroup: e.collectionGroup, fields: e.fields.map(e => [e.fieldPath.canonicalString(), e.kind]) };
            })(t);
          delete r.indexId;
          const i = n.add(r);
          if (t.indexState) {
            const n = vl(e);
            return i.next(e => {
              n.put(Fc(e, this.user, t.indexState.sequenceNumber, t.indexState.offset));
            });
          }
          return i.next();
        }
        deleteFieldIndex(e, t) {
          const n = ml(e),
            r = vl(e),
            i = gl(e);
          return n
            .delete(t.indexId)
            .next(() => r.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)))
            .next(() => i.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)));
        }
        getDocumentsMatchingTarget(e, t) {
          const n = gl(e);
          let r = !0;
          const i = new Map();
          return zi
            .forEach(this.cn(t), t =>
              this.an(e, t).next(e => {
                r && (r = !!e), i.set(t, e);
              })
            )
            .next(() => {
              if (r) {
                let e = La();
                const r = [];
                return zi
                  .forEach(i, (i, o) => {
                    var s;
                    ti(
                      'IndexedDbIndexManager',
                      `Using index ${((s = i), `id=${s.indexId}|cg=${s.collectionGroup}|f=${s.fields.map(e => `${e.fieldPath}:${e.kind}`).join(',')}`)} to execute ${ea(t)}`
                    );
                    const a = (function (e, t) {
                        const n = Pi(t);
                        if (void 0 === n) return null;
                        for (const r of ra(e, n.fieldPath))
                          switch (r.op) {
                            case 'array-contains-any':
                              return r.value.arrayValue.values || [];
                            case 'array-contains':
                              return [r.value];
                          }
                        return null;
                      })(o, i),
                      u = (function (e, t) {
                        const n = new Map();
                        for (const r of Di(t))
                          for (const t of ra(e, r.fieldPath))
                            switch (t.op) {
                              case '==':
                              case 'in':
                                n.set(r.fieldPath.canonicalString(), t.value);
                                break;
                              case 'not-in':
                              case '!=':
                                return n.set(r.fieldPath.canonicalString(), t.value), Array.from(n.values());
                            }
                        return null;
                      })(o, i),
                      c = (function (e, t) {
                        const n = [];
                        let r = !0;
                        for (const i of Di(t)) {
                          const t = 0 === i.kind ? ia(e, i.fieldPath, e.startAt) : oa(e, i.fieldPath, e.startAt);
                          n.push(t.value), r && (r = t.inclusive);
                        }
                        return new Cs(n, r);
                      })(o, i),
                      l = (function (e, t) {
                        const n = [];
                        let r = !0;
                        for (const i of Di(t)) {
                          const t = 0 === i.kind ? oa(e, i.fieldPath, e.endAt) : ia(e, i.fieldPath, e.endAt);
                          n.push(t.value), r && (r = t.inclusive);
                        }
                        return new Cs(n, r);
                      })(o, i),
                      h = this.hn(i, o, c),
                      f = this.hn(i, o, l),
                      d = this.ln(i, o, u),
                      p = this.fn(i.indexId, a, h, c.inclusive, f, l.inclusive, d);
                    return zi.forEach(p, i =>
                      n.H(i, t.limit).next(t => {
                        t.forEach(t => {
                          const n = Ni.fromSegments(t.documentKey);
                          e.has(n) || ((e = e.add(n)), r.push(n));
                        });
                      })
                    );
                  })
                  .next(() => r);
              }
              return zi.resolve(null);
            });
        }
        cn(e) {
          let t = this.un.get(e);
          return (
            t ||
            ((t =
              0 === e.filters.length
                ? [e]
                : nl(Ls.create(e.filters, 'and')).map(t => Zs(e.path, e.collectionGroup, e.orderBy, t.getFilters(), e.limit, e.startAt, e.endAt))),
            this.un.set(e, t),
            t)
          );
        }
        fn(e, t, n, r, i, o, s) {
          const a = (null != t ? t.length : 1) * Math.max(n.length, i.length),
            u = a / (null != t ? t.length : 1),
            c = [];
          for (let l = 0; l < a; ++l) {
            const a = t ? this.dn(t[l / u]) : fl,
              h = this.wn(e, a, n[l % u], r),
              f = this._n(e, a, i[l % u], o),
              d = s.map(t => this.wn(e, a, t, !0));
            c.push(...this.createRange(h, f, d));
          }
          return c;
        }
        wn(e, t, n, r) {
          const i = new Xc(e, Ni.empty(), t, n);
          return r ? i : i.Je();
        }
        _n(e, t, n, r) {
          const i = new Xc(e, Ni.empty(), t, n);
          return r ? i.Je() : i;
        }
        an(e, t) {
          const n = new el(t),
            r = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment();
          return this.getFieldIndexes(e, r).next(e => {
            let t = null;
            for (const r of e) n.tn(r) && (!t || r.fields.length > t.fields.length) && (t = r);
            return t;
          });
        }
        getIndexType(e, t) {
          let n = 2;
          const r = this.cn(t);
          return zi
            .forEach(r, t =>
              this.an(e, t).next(e => {
                e
                  ? 0 !== n &&
                    e.fields.length <
                      (function (e) {
                        let t = new $o(Oi.comparator),
                          n = !1;
                        for (const r of e.filters)
                          for (const e of r.getFlattenedFilters())
                            e.field.isKeyField() || ('array-contains' === e.op || 'array-contains-any' === e.op ? (n = !0) : (t = t.add(e.field)));
                        for (const r of e.orderBy) r.field.isKeyField() || (t = t.add(r.field));
                        return t.size + (n ? 1 : 0);
                      })(t) &&
                    (n = 1)
                  : (n = 0);
              })
            )
            .next(() =>
              (function (e) {
                return null !== e.limit;
              })(t) &&
              r.length > 1 &&
              2 === n
                ? 1
                : n
            );
        }
        mn(e, t) {
          const n = new Yc();
          for (const r of Di(e)) {
            const e = t.data.field(r.fieldPath);
            if (null == e) return null;
            const i = n.He(r.kind);
            zc.Ve._e(e, i);
          }
          return n.Qe();
        }
        dn(e) {
          const t = new Yc();
          return zc.Ve._e(e, t.He(0)), t.Qe();
        }
        gn(e, t) {
          const n = new Yc();
          return (
            zc.Ve._e(
              ds(this.databaseId, t),
              n.He(
                (function (e) {
                  const t = Di(e);
                  return 0 === t.length ? 0 : t[t.length - 1].kind;
                })(e)
              )
            ),
            n.Qe()
          );
        }
        ln(e, t, n) {
          if (null === n) return [];
          let r = [];
          r.push(new Yc());
          let i = 0;
          for (const o of Di(e)) {
            const e = n[i++];
            for (const n of r)
              if (this.yn(t, o.fieldPath) && gs(e)) r = this.pn(r, o, e);
              else {
                const t = n.He(o.kind);
                zc.Ve._e(e, t);
              }
          }
          return this.In(r);
        }
        hn(e, t, n) {
          return this.ln(e, t, n.position);
        }
        In(e) {
          const t = [];
          for (let n = 0; n < e.length; ++n) t[n] = e[n].Qe();
          return t;
        }
        pn(e, t, n) {
          const r = [...e],
            i = [];
          for (const o of n.arrayValue.values || [])
            for (const e of r) {
              const n = new Yc();
              n.seed(e.Qe()), zc.Ve._e(o, n.He(t.kind)), i.push(n);
            }
          return i;
        }
        yn(e, t) {
          return !!e.filters.find(e => e instanceof Ds && e.field.isEqual(t) && ('in' === e.op || 'not-in' === e.op));
        }
        getFieldIndexes(e, t) {
          const n = ml(e),
            r = vl(e);
          return (t ? n.j('collectionGroupIndex', IDBKeyRange.bound(t, t)) : n.j()).next(e => {
            const t = [];
            return zi
              .forEach(e, e =>
                r.get([e.indexId, this.uid]).next(n => {
                  t.push(
                    (function (e, t) {
                      const n = t ? new ji(t.sequenceNumber, new Ui(Nc(t.readTime), new Ni(co(t.documentKey)), t.largestBatchId)) : ji.empty(),
                        r = e.fields.map(([e, t]) => new Li(Oi.fromServerFormat(e), t));
                      return new Ri(e.indexId, e.collectionGroup, r, n);
                    })(e, n)
                  );
                })
              )
              .next(() => t);
          });
        }
        getNextCollectionGroupToUpdate(e) {
          return this.getFieldIndexes(e).next(e =>
            0 === e.length
              ? null
              : (e.sort((e, t) => {
                  const n = e.indexState.sequenceNumber - t.indexState.sequenceNumber;
                  return 0 !== n ? n : Ii(e.collectionGroup, t.collectionGroup);
                }),
                e[0].collectionGroup)
          );
        }
        updateCollectionGroup(e, t, n) {
          const r = ml(e),
            i = vl(e);
          return this.Tn(e).next(e =>
            r.j('collectionGroupIndex', IDBKeyRange.bound(t, t)).next(t => zi.forEach(t, t => i.put(Fc(t.indexId, this.user, e, n))))
          );
        }
        updateIndexEntries(e, t) {
          const n = new Map();
          return zi.forEach(t, (t, r) => {
            const i = n.get(t.collectionGroup);
            return (i ? zi.resolve(i) : this.getFieldIndexes(e, t.collectionGroup)).next(
              i => (
                n.set(t.collectionGroup, i),
                zi.forEach(i, n =>
                  this.En(e, t, n).next(t => {
                    const i = this.An(r, n);
                    return t.isEqual(i) ? zi.resolve() : this.vn(e, r, n, t, i);
                  })
                )
              )
            );
          });
        }
        Rn(e, t, n, r) {
          return gl(e).put({
            indexId: r.indexId,
            uid: this.uid,
            arrayValue: r.arrayValue,
            directionalValue: r.directionalValue,
            orderedDocumentKey: this.gn(n, t.key),
            documentKey: t.key.path.toArray()
          });
        }
        Pn(e, t, n, r) {
          return gl(e).delete([r.indexId, this.uid, r.arrayValue, r.directionalValue, this.gn(n, t.key), t.key.path.toArray()]);
        }
        En(e, t, n) {
          const r = gl(e);
          let i = new $o(Jc);
          return r
            .X({ index: 'documentKeyIndex', range: IDBKeyRange.only([n.indexId, this.uid, this.gn(n, t)]) }, (e, r) => {
              i = i.add(new Xc(n.indexId, t, r.arrayValue, r.directionalValue));
            })
            .next(() => i);
        }
        An(e, t) {
          let n = new $o(Jc);
          const r = this.mn(t, e);
          if (null == r) return n;
          const i = Pi(t);
          if (null != i) {
            const o = e.data.field(i.fieldPath);
            if (gs(o)) for (const i of o.arrayValue.values || []) n = n.add(new Xc(t.indexId, e.key, this.dn(i), r));
          } else n = n.add(new Xc(t.indexId, e.key, fl, r));
          return n;
        }
        vn(e, t, n, r, i) {
          ti('IndexedDbIndexManager', "Updating index entries for document '%s'", t.key);
          const o = [];
          return (
            (function (e, t, n, r, i) {
              const o = e.getIterator(),
                s = t.getIterator();
              let a = zo(o),
                u = zo(s);
              for (; a || u; ) {
                let e = !1,
                  t = !1;
                if (a && u) {
                  const r = n(a, u);
                  r < 0 ? (t = !0) : r > 0 && (e = !0);
                } else null != a ? (t = !0) : (e = !0);
                e ? (r(u), (u = zo(s))) : t ? (i(a), (a = zo(o))) : ((a = zo(o)), (u = zo(s)));
              }
            })(
              r,
              i,
              Jc,
              r => {
                o.push(this.Rn(e, t, n, r));
              },
              r => {
                o.push(this.Pn(e, t, n, r));
              }
            ),
            zi.waitFor(o)
          );
        }
        Tn(e) {
          let t = 1;
          return vl(e)
            .X({ index: 'sequenceNumberIndex', reverse: !0, range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER]) }, (e, n, r) => {
              r.done(), (t = n.sequenceNumber + 1);
            })
            .next(() => t);
        }
        createRange(e, t, n) {
          n = n.sort((e, t) => Jc(e, t)).filter((e, t, n) => !t || 0 !== Jc(e, n[t - 1]));
          const r = [];
          r.push(e);
          for (const o of n) {
            const n = Jc(o, e),
              i = Jc(o, t);
            if (0 === n) r[0] = e.Je();
            else if (n > 0 && i < 0) r.push(o), r.push(o.Je());
            else if (i > 0) break;
          }
          r.push(t);
          const i = [];
          for (let o = 0; o < r.length; o += 2) {
            if (this.bn(r[o], r[o + 1])) return [];
            const e = [r[o].indexId, this.uid, r[o].arrayValue, r[o].directionalValue, fl, []],
              t = [r[o + 1].indexId, this.uid, r[o + 1].arrayValue, r[o + 1].directionalValue, fl, []];
            i.push(IDBKeyRange.bound(e, t));
          }
          return i;
        }
        bn(e, t) {
          return Jc(e, t) > 0;
        }
        getMinOffsetFromCollectionGroup(e, t) {
          return this.getFieldIndexes(e, t).next(yl);
        }
        getMinOffset(e, t) {
          return zi.mapArray(this.cn(t), t => this.an(e, t).next(e => e || oi())).next(yl);
        }
      }
      function pl(e) {
        return Lo(e, 'collectionParents');
      }
      function gl(e) {
        return Lo(e, 'indexEntries');
      }
      function ml(e) {
        return Lo(e, 'indexConfiguration');
      }
      function vl(e) {
        return Lo(e, 'indexState');
      }
      function yl(e) {
        si(0 !== e.length);
        let t = e[0].indexState.offset,
          n = t.largestBatchId;
        for (let r = 1; r < e.length; r++) {
          const i = e[r].indexState.offset;
          Vi(i, t) < 0 && (t = i), n < i.largestBatchId && (n = i.largestBatchId);
        }
        return new Ui(t.readTime, t.documentKey, n);
      }
      /**
       * @license
       * Copyright 2018 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const wl = { didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0 };
      class bl {
        constructor(e, t, n) {
          (this.cacheSizeCollectionThreshold = e), (this.percentileToCollect = t), (this.maximumSequenceNumbersToCollect = n);
        }
        static withCacheSize(e) {
          return new bl(e, bl.DEFAULT_COLLECTION_PERCENTILE, bl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function _l(e, t, n) {
        const r = e.store('mutations'),
          i = e.store('documentMutations'),
          o = [],
          s = IDBKeyRange.only(n.batchId);
        let a = 0;
        const u = r.X({ range: s }, (e, t, n) => (a++, n.delete()));
        o.push(
          u.next(() => {
            si(1 === a);
          })
        );
        const c = [];
        for (const l of n.mutations) {
          const e = fo(t, l.key.path, n.batchId);
          o.push(i.delete(e)), c.push(l.key);
        }
        return zi.waitFor(o).next(() => c);
      }
      function Il(e) {
        if (!e) return 0;
        let t;
        if (e.document) t = e.document;
        else if (e.unknownDocument) t = e.unknownDocument;
        else {
          if (!e.noDocument) throw oi();
          t = e.noDocument;
        }
        return JSON.stringify(t).length;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ (bl.DEFAULT_COLLECTION_PERCENTILE = 10),
        (bl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3),
        (bl.DEFAULT = new bl(41943040, bl.DEFAULT_COLLECTION_PERCENTILE, bl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)),
        (bl.DISABLED = new bl(-1, 0, 0));
      class El {
        constructor(e, t, n, r) {
          (this.userId = e), (this.serializer = t), (this.indexManager = n), (this.referenceDelegate = r), (this.Vn = {});
        }
        static de(e, t, n, r) {
          si('' !== e.uid);
          const i = e.isAuthenticated() ? e.uid : '';
          return new El(i, t, n, r);
        }
        checkEmpty(e) {
          let t = !0;
          const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
          return Tl(e)
            .X({ index: 'userMutationsIndex', range: n }, (e, n, r) => {
              (t = !1), r.done();
            })
            .next(() => t);
        }
        addMutationBatch(e, t, n, r) {
          const i = Al(e),
            o = Tl(e);
          return o.add({}).next(s => {
            si('number' == typeof s);
            const a = new vu(s, t, n, r),
              u = (function (e, t, n) {
                const r = n.baseMutations.map(t => cc(e.fe, t)),
                  i = n.mutations.map(t => cc(e.fe, t));
                return { userId: t, batchId: n.batchId, localWriteTimeMs: n.localWriteTime.toMillis(), baseMutations: r, mutations: i };
              })(this.serializer, this.userId, a),
              c = [];
            let l = new $o((e, t) => Ii(e.canonicalString(), t.canonicalString()));
            for (const e of r) {
              const t = fo(this.userId, e.key.path, s);
              (l = l.add(e.key.path.popLast())), c.push(o.put(u)), c.push(i.put(t, po));
            }
            return (
              l.forEach(t => {
                c.push(this.indexManager.addToCollectionParentIndex(e, t));
              }),
              e.addOnCommittedListener(() => {
                this.Vn[s] = a.keys();
              }),
              zi.waitFor(c).next(() => a)
            );
          });
        }
        lookupMutationBatch(e, t) {
          return Tl(e)
            .get(t)
            .next(e => (e ? (si(e.userId === this.userId), Rc(this.serializer, e)) : null));
        }
        Sn(e, t) {
          return this.Vn[t]
            ? zi.resolve(this.Vn[t])
            : this.lookupMutationBatch(e, t).next(e => {
                if (e) {
                  const n = e.keys();
                  return (this.Vn[t] = n), n;
                }
                return null;
              });
        }
        getNextMutationBatchAfterBatchId(e, t) {
          const n = t + 1,
            r = IDBKeyRange.lowerBound([this.userId, n]);
          let i = null;
          return Tl(e)
            .X({ index: 'userMutationsIndex', range: r }, (e, t, r) => {
              t.userId === this.userId && (si(t.batchId >= n), (i = Rc(this.serializer, t))), r.done();
            })
            .next(() => i);
        }
        getHighestUnacknowledgedBatchId(e) {
          const t = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
          let n = -1;
          return Tl(e)
            .X({ index: 'userMutationsIndex', range: t, reverse: !0 }, (e, t, r) => {
              (n = t.batchId), r.done();
            })
            .next(() => n);
        }
        getAllMutationBatches(e) {
          const t = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
          return Tl(e)
            .j('userMutationsIndex', t)
            .next(e => e.map(e => Rc(this.serializer, e)));
        }
        getAllMutationBatchesAffectingDocumentKey(e, t) {
          const n = ho(this.userId, t.path),
            r = IDBKeyRange.lowerBound(n),
            i = [];
          return Al(e)
            .X({ range: r }, (n, r, o) => {
              const [s, a, u] = n,
                c = co(a);
              if (s === this.userId && t.path.isEqual(c))
                return Tl(e)
                  .get(u)
                  .next(e => {
                    if (!e) throw oi();
                    si(e.userId === this.userId), i.push(Rc(this.serializer, e));
                  });
              o.done();
            })
            .next(() => i);
        }
        getAllMutationBatchesAffectingDocumentKeys(e, t) {
          let n = new $o(Ii);
          const r = [];
          return (
            t.forEach(t => {
              const i = ho(this.userId, t.path),
                o = IDBKeyRange.lowerBound(i),
                s = Al(e).X({ range: o }, (e, r, i) => {
                  const [o, s, a] = e,
                    u = co(s);
                  o === this.userId && t.path.isEqual(u) ? (n = n.add(a)) : i.done();
                });
              r.push(s);
            }),
            zi.waitFor(r).next(() => this.Dn(e, n))
          );
        }
        getAllMutationBatchesAffectingQuery(e, t) {
          const n = t.path,
            r = n.length + 1,
            i = ho(this.userId, n),
            o = IDBKeyRange.lowerBound(i);
          let s = new $o(Ii);
          return Al(e)
            .X({ range: o }, (e, t, i) => {
              const [o, a, u] = e,
                c = co(a);
              o === this.userId && n.isPrefixOf(c) ? c.length === r && (s = s.add(u)) : i.done();
            })
            .next(() => this.Dn(e, s));
        }
        Dn(e, t) {
          const n = [],
            r = [];
          return (
            t.forEach(t => {
              r.push(
                Tl(e)
                  .get(t)
                  .next(e => {
                    if (null === e) throw oi();
                    si(e.userId === this.userId), n.push(Rc(this.serializer, e));
                  })
              );
            }),
            zi.waitFor(r).next(() => n)
          );
        }
        removeMutationBatch(e, t) {
          return _l(e.ht, this.userId, t).next(
            n => (
              e.addOnCommittedListener(() => {
                this.Cn(t.batchId);
              }),
              zi.forEach(n, t => this.referenceDelegate.markPotentiallyOrphaned(e, t))
            )
          );
        }
        Cn(e) {
          delete this.Vn[e];
        }
        performConsistencyCheck(e) {
          return this.checkEmpty(e).next(t => {
            if (!t) return zi.resolve();
            const n = IDBKeyRange.lowerBound([this.userId]),
              r = [];
            return Al(e)
              .X({ range: n }, (e, t, n) => {
                if (e[0] === this.userId) {
                  const t = co(e[1]);
                  r.push(t);
                } else n.done();
              })
              .next(() => {
                si(0 === r.length);
              });
          });
        }
        containsKey(e, t) {
          return Sl(e, this.userId, t);
        }
        xn(e) {
          return xl(e)
            .get(this.userId)
            .next(e => e || { userId: this.userId, lastAcknowledgedBatchId: -1, lastStreamToken: '' });
        }
      }
      function Sl(e, t, n) {
        const r = ho(t, n.path),
          i = r[1],
          o = IDBKeyRange.lowerBound(r);
        let s = !1;
        return Al(e)
          .X({ range: o, Y: !0 }, (e, n, r) => {
            const [o, a, u] = e;
            o === t && a === i && (s = !0), r.done();
          })
          .next(() => s);
      }
      function Tl(e) {
        return Lo(e, 'mutations');
      }
      function Al(e) {
        return Lo(e, 'documentMutations');
      }
      function xl(e) {
        return Lo(e, 'mutationQueues');
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Cl {
        constructor(e) {
          this.Nn = e;
        }
        next() {
          return (this.Nn += 2), this.Nn;
        }
        static kn() {
          return new Cl(0);
        }
        static Mn() {
          return new Cl(-1);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class kl {
        constructor(e, t) {
          (this.referenceDelegate = e), (this.serializer = t);
        }
        allocateTargetId(e) {
          return this.$n(e).next(t => {
            const n = new Cl(t.highestTargetId);
            return (t.highestTargetId = n.next()), this.On(e, t).next(() => t.highestTargetId);
          });
        }
        getLastRemoteSnapshotVersion(e) {
          return this.$n(e).next(e => Ai.fromTimestamp(new Ti(e.lastRemoteSnapshotVersion.seconds, e.lastRemoteSnapshotVersion.nanoseconds)));
        }
        getHighestSequenceNumber(e) {
          return this.$n(e).next(e => e.highestListenSequenceNumber);
        }
        setTargetsMetadata(e, t, n) {
          return this.$n(e).next(
            r => (
              (r.highestListenSequenceNumber = t),
              n && (r.lastRemoteSnapshotVersion = n.toTimestamp()),
              t > r.highestListenSequenceNumber && (r.highestListenSequenceNumber = t),
              this.On(e, r)
            )
          );
        }
        addTargetData(e, t) {
          return this.Fn(e, t).next(() => this.$n(e).next(n => ((n.targetCount += 1), this.Bn(t, n), this.On(e, n))));
        }
        updateTargetData(e, t) {
          return this.Fn(e, t);
        }
        removeTargetData(e, t) {
          return this.removeMatchingKeysForTargetId(e, t.targetId)
            .next(() => Ol(e).delete(t.targetId))
            .next(() => this.$n(e))
            .next(t => (si(t.targetCount > 0), (t.targetCount -= 1), this.On(e, t)));
        }
        removeTargets(e, t, n) {
          let r = 0;
          const i = [];
          return Ol(e)
            .X((o, s) => {
              const a = Pc(s);
              a.sequenceNumber <= t && null === n.get(a.targetId) && (r++, i.push(this.removeTargetData(e, a)));
            })
            .next(() => zi.waitFor(i))
            .next(() => r);
        }
        forEachTarget(e, t) {
          return Ol(e).X((e, n) => {
            const r = Pc(n);
            t(r);
          });
        }
        $n(e) {
          return Nl(e)
            .get('targetGlobalKey')
            .next(e => (si(null !== e), e));
        }
        On(e, t) {
          return Nl(e).put('targetGlobalKey', t);
        }
        Fn(e, t) {
          return Ol(e).put(Dc(this.serializer, t));
        }
        Bn(e, t) {
          let n = !1;
          return (
            e.targetId > t.highestTargetId && ((t.highestTargetId = e.targetId), (n = !0)),
            e.sequenceNumber > t.highestListenSequenceNumber && ((t.highestListenSequenceNumber = e.sequenceNumber), (n = !0)),
            n
          );
        }
        getTargetCount(e) {
          return this.$n(e).next(e => e.targetCount);
        }
        getTargetData(e, t) {
          const n = ea(t),
            r = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
          let i = null;
          return Ol(e)
            .X({ range: r, index: 'queryTargetsIndex' }, (e, n, r) => {
              const o = Pc(n);
              ta(t, o.target) && ((i = o), r.done());
            })
            .next(() => i);
        }
        addMatchingKeys(e, t, n) {
          const r = [],
            i = Rl(e);
          return (
            t.forEach(t => {
              const o = so(t.path);
              r.push(i.put({ targetId: n, path: o })), r.push(this.referenceDelegate.addReference(e, n, t));
            }),
            zi.waitFor(r)
          );
        }
        removeMatchingKeys(e, t, n) {
          const r = Rl(e);
          return zi.forEach(t, t => {
            const i = so(t.path);
            return zi.waitFor([r.delete([n, i]), this.referenceDelegate.removeReference(e, n, t)]);
          });
        }
        removeMatchingKeysForTargetId(e, t) {
          const n = Rl(e),
            r = IDBKeyRange.bound([t], [t + 1], !1, !0);
          return n.delete(r);
        }
        getMatchingKeysForTargetId(e, t) {
          const n = IDBKeyRange.bound([t], [t + 1], !1, !0),
            r = Rl(e);
          let i = La();
          return r
            .X({ range: n, Y: !0 }, (e, t, n) => {
              const r = co(e[1]),
                o = new Ni(r);
              i = i.add(o);
            })
            .next(() => i);
        }
        containsKey(e, t) {
          const n = so(t.path),
            r = IDBKeyRange.bound([n], [Si(n)], !1, !0);
          let i = 0;
          return Rl(e)
            .X({ index: 'documentTargetsIndex', Y: !0, range: r }, ([e, t], n, r) => {
              0 !== e && (i++, r.done());
            })
            .next(() => i > 0);
        }
        le(e, t) {
          return Ol(e)
            .get(t)
            .next(e => (e ? Pc(e) : null));
        }
      }
      function Ol(e) {
        return Lo(e, 'targets');
      }
      function Nl(e) {
        return Lo(e, 'targetGlobal');
      }
      function Rl(e) {
        return Lo(e, 'targetDocuments');
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Pl([e, t], [n, r]) {
        const i = Ii(e, n);
        return 0 === i ? Ii(t, r) : i;
      }
      class Dl {
        constructor(e) {
          (this.Ln = e), (this.buffer = new $o(Pl)), (this.qn = 0);
        }
        Un() {
          return ++this.qn;
        }
        Kn(e) {
          const t = [e, this.Un()];
          if (this.buffer.size < this.Ln) this.buffer = this.buffer.add(t);
          else {
            const e = this.buffer.last();
            Pl(t, e) < 0 && (this.buffer = this.buffer.delete(e).add(t));
          }
        }
        get maxValue() {
          return this.buffer.last()[0];
        }
      }
      class Ll {
        constructor(e, t, n) {
          (this.garbageCollector = e), (this.asyncQueue = t), (this.localStore = n), (this.Gn = null);
        }
        start() {
          -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Qn(6e4);
        }
        stop() {
          this.Gn && (this.Gn.cancel(), (this.Gn = null));
        }
        get started() {
          return null !== this.Gn;
        }
        Qn(e) {
          ti('LruGarbageCollector', `Garbage collection scheduled in ${e}ms`),
            (this.Gn = this.asyncQueue.enqueueAfterDelay('lru_garbage_collection', e, async () => {
              this.Gn = null;
              try {
                await this.localStore.collectGarbage(this.garbageCollector);
              } catch (e) {
                Qi(e) ? ti('LruGarbageCollector', 'Ignoring IndexedDB error during garbage collection: ', e) : await qi(e);
              }
              await this.Qn(3e5);
            }));
        }
      }
      class jl {
        constructor(e, t) {
          (this.jn = e), (this.params = t);
        }
        calculateTargetCount(e, t) {
          return this.jn.zn(e).next(e => Math.floor((t / 100) * e));
        }
        nthSequenceNumber(e, t) {
          if (0 === t) return zi.resolve(no.ct);
          const n = new Dl(t);
          return this.jn
            .forEachTarget(e, e => n.Kn(e.sequenceNumber))
            .next(() => this.jn.Wn(e, e => n.Kn(e)))
            .next(() => n.maxValue);
        }
        removeTargets(e, t, n) {
          return this.jn.removeTargets(e, t, n);
        }
        removeOrphanedDocuments(e, t) {
          return this.jn.removeOrphanedDocuments(e, t);
        }
        collect(e, t) {
          return -1 === this.params.cacheSizeCollectionThreshold
            ? (ti('LruGarbageCollector', 'Garbage collection skipped; disabled'), zi.resolve(wl))
            : this.getCacheSize(e).next(n =>
                n < this.params.cacheSizeCollectionThreshold
                  ? (ti(
                      'LruGarbageCollector',
                      `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`
                    ),
                    wl)
                  : this.Hn(e, t)
              );
        }
        getCacheSize(e) {
          return this.jn.getCacheSize(e);
        }
        Hn(e, t) {
          let n, r, i, o, s, u, c;
          const l = Date.now();
          return this.calculateTargetCount(e, this.params.percentileToCollect)
            .next(
              t => (
                t > this.params.maximumSequenceNumbersToCollect
                  ? (ti(
                      'LruGarbageCollector',
                      `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${t}`
                    ),
                    (r = this.params.maximumSequenceNumbersToCollect))
                  : (r = t),
                (o = Date.now()),
                this.nthSequenceNumber(e, r)
              )
            )
            .next(r => ((n = r), (s = Date.now()), this.removeTargets(e, n, t)))
            .next(t => ((i = t), (u = Date.now()), this.removeOrphanedDocuments(e, n)))
            .next(
              e => (
                (c = Date.now()),
                Zr() <= a['in'].DEBUG &&
                  ti(
                    'LruGarbageCollector',
                    `LRU Garbage Collection\n\tCounted targets in ${o - l}ms\n\tDetermined least recently used ${r} in ` +
                      (s - o) +
                      'ms\n' +
                      `\tRemoved ${i} targets in ` +
                      (u - s) +
                      'ms\n' +
                      `\tRemoved ${e} documents in ` +
                      (c - u) +
                      'ms\n' +
                      `Total Duration: ${c - l}ms`
                  ),
                zi.resolve({ didRun: !0, sequenceNumbersCollected: r, targetsRemoved: i, documentsRemoved: e })
              )
            );
        }
      }
      function Ml(e, t) {
        return new jl(e, t);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Fl {
        constructor(e, t) {
          (this.db = e), (this.garbageCollector = Ml(this, t));
        }
        zn(e) {
          const t = this.Jn(e);
          return this.db
            .getTargetCache()
            .getTargetCount(e)
            .next(e => t.next(t => e + t));
        }
        Jn(e) {
          let t = 0;
          return this.Wn(e, e => {
            t++;
          }).next(() => t);
        }
        forEachTarget(e, t) {
          return this.db.getTargetCache().forEachTarget(e, t);
        }
        Wn(e, t) {
          return this.Yn(e, (e, n) => t(n));
        }
        addReference(e, t, n) {
          return Ul(e, n);
        }
        removeReference(e, t, n) {
          return Ul(e, n);
        }
        removeTargets(e, t, n) {
          return this.db.getTargetCache().removeTargets(e, t, n);
        }
        markPotentiallyOrphaned(e, t) {
          return Ul(e, t);
        }
        Xn(e, t) {
          return (function (e, t) {
            let n = !1;
            return xl(e)
              .Z(r => Sl(e, r, t).next(e => (e && (n = !0), zi.resolve(!e))))
              .next(() => n);
          })(e, t);
        }
        removeOrphanedDocuments(e, t) {
          const n = this.db.getRemoteDocumentCache().newChangeBuffer(),
            r = [];
          let i = 0;
          return this.Yn(e, (o, s) => {
            if (s <= t) {
              const t = this.Xn(e, o).next(t => {
                if (!t) return i++, n.getEntry(e, o).next(() => (n.removeEntry(o, Ai.min()), Rl(e).delete([0, so(o.path)])));
              });
              r.push(t);
            }
          })
            .next(() => zi.waitFor(r))
            .next(() => n.apply(e))
            .next(() => i);
        }
        removeTarget(e, t) {
          const n = t.withSequenceNumber(e.currentSequenceNumber);
          return this.db.getTargetCache().updateTargetData(e, n);
        }
        updateLimboDocument(e, t) {
          return Ul(e, t);
        }
        Yn(e, t) {
          const n = Rl(e);
          let r,
            i = no.ct;
          return n
            .X({ index: 'documentTargetsIndex' }, ([e, n], { path: o, sequenceNumber: s }) => {
              0 === e ? (i !== no.ct && t(new Ni(co(r)), i), (i = s), (r = o)) : (i = no.ct);
            })
            .next(() => {
              i !== no.ct && t(new Ni(co(r)), i);
            });
        }
        getCacheSize(e) {
          return this.db.getRemoteDocumentCache().getSize(e);
        }
      }
      function Ul(e, t) {
        return Rl(e).put(
          (function (e, t) {
            return { targetId: 0, path: so(e.path), sequenceNumber: t };
          })(t, e.currentSequenceNumber)
        );
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Vl {
        constructor() {
          (this.changes = new Sa(
            e => e.toString(),
            (e, t) => e.isEqual(t)
          )),
            (this.changesApplied = !1);
        }
        addEntry(e) {
          this.assertNotApplied(), this.changes.set(e.key, e);
        }
        removeEntry(e, t) {
          this.assertNotApplied(), this.changes.set(e, xs.newInvalidDocument(e).setReadTime(t));
        }
        getEntry(e, t) {
          this.assertNotApplied();
          const n = this.changes.get(t);
          return void 0 !== n ? zi.resolve(n) : this.getFromCache(e, t);
        }
        getEntries(e, t) {
          return this.getAllFromCache(e, t);
        }
        apply(e) {
          return this.assertNotApplied(), (this.changesApplied = !0), this.applyChanges(e);
        }
        assertNotApplied() {}
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Bl {
        constructor(e) {
          this.serializer = e;
        }
        setIndexManager(e) {
          this.indexManager = e;
        }
        addEntry(e, t, n) {
          return Gl(e).put(n);
        }
        removeEntry(e, t, n) {
          return Gl(e).delete(
            (function (e, t) {
              const n = e.path.toArray();
              return [n.slice(0, n.length - 2), n[n.length - 2], kc(t), n[n.length - 1]];
            })(t, n)
          );
        }
        updateMetadata(e, t) {
          return this.getMetadata(e).next(n => ((n.byteSize += t), this.Zn(e, n)));
        }
        getEntry(e, t) {
          let n = xs.newInvalidDocument(t);
          return Gl(e)
            .X({ index: 'documentKeyIndex', range: IDBKeyRange.only(Wl(t)) }, (e, r) => {
              n = this.ts(t, r);
            })
            .next(() => n);
        }
        es(e, t) {
          let n = { size: 0, document: xs.newInvalidDocument(t) };
          return Gl(e)
            .X({ index: 'documentKeyIndex', range: IDBKeyRange.only(Wl(t)) }, (e, r) => {
              n = { document: this.ts(t, r), size: Il(r) };
            })
            .next(() => n);
        }
        getEntries(e, t) {
          let n = Aa();
          return this.ns(e, t, (e, t) => {
            const r = this.ts(e, t);
            n = n.insert(e, r);
          }).next(() => n);
        }
        ss(e, t) {
          let n = Aa(),
            r = new Uo(Ni.comparator);
          return this.ns(e, t, (e, t) => {
            const i = this.ts(e, t);
            (n = n.insert(e, i)), (r = r.insert(e, Il(t)));
          }).next(() => ({ documents: n, rs: r }));
        }
        ns(e, t, n) {
          if (t.isEmpty()) return zi.resolve();
          let r = new $o(Kl);
          t.forEach(e => (r = r.add(e)));
          const i = IDBKeyRange.bound(Wl(r.first()), Wl(r.last())),
            o = r.getIterator();
          let s = o.getNext();
          return Gl(e)
            .X({ index: 'documentKeyIndex', range: i }, (e, t, r) => {
              const i = Ni.fromSegments([...t.prefixPath, t.collectionGroup, t.documentId]);
              for (; s && Kl(s, i) < 0; ) n(s, null), (s = o.getNext());
              s && s.isEqual(i) && (n(s, t), (s = o.hasNext() ? o.getNext() : null)), s ? r.G(Wl(s)) : r.done();
            })
            .next(() => {
              for (; s; ) n(s, null), (s = o.hasNext() ? o.getNext() : null);
            });
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          const i = t.path,
            o = [i.popLast().toArray(), i.lastSegment(), kc(n.readTime), n.documentKey.path.isEmpty() ? '' : n.documentKey.path.lastSegment()],
            s = [i.popLast().toArray(), i.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ''];
          return Gl(e)
            .j(IDBKeyRange.bound(o, s, !0))
            .next(e => {
              let n = Aa();
              for (const i of e) {
                const e = this.ts(Ni.fromSegments(i.prefixPath.concat(i.collectionGroup, i.documentId)), i);
                e.isFoundDocument() && (ba(t, e) || r.has(e.key)) && (n = n.insert(e.key, e));
              }
              return n;
            });
        }
        getAllFromCollectionGroup(e, t, n, r) {
          let i = Aa();
          const o = Hl(t, n),
            s = Hl(t, Ui.max());
          return Gl(e)
            .X({ index: 'collectionGroupIndex', range: IDBKeyRange.bound(o, s, !0) }, (e, t, n) => {
              const o = this.ts(Ni.fromSegments(t.prefixPath.concat(t.collectionGroup, t.documentId)), t);
              (i = i.insert(o.key, o)), i.size === r && n.done();
            })
            .next(() => i);
        }
        newChangeBuffer(e) {
          return new ql(this, !!e && e.trackRemovals);
        }
        getSize(e) {
          return this.getMetadata(e).next(e => e.byteSize);
        }
        getMetadata(e) {
          return zl(e)
            .get('remoteDocumentGlobalKey')
            .next(e => (si(!!e), e));
        }
        Zn(e, t) {
          return zl(e).put('remoteDocumentGlobalKey', t);
        }
        ts(e, t) {
          if (t) {
            const e = xc(this.serializer, t);
            if (!e.isNoDocument() || !e.version.isEqual(Ai.min())) return e;
          }
          return xs.newInvalidDocument(e);
        }
      }
      function $l(e) {
        return new Bl(e);
      }
      class ql extends Vl {
        constructor(e, t) {
          super(),
            (this.os = e),
            (this.trackRemovals = t),
            (this.us = new Sa(
              e => e.toString(),
              (e, t) => e.isEqual(t)
            ));
        }
        applyChanges(e) {
          const t = [];
          let n = 0,
            r = new $o((e, t) => Ii(e.canonicalString(), t.canonicalString()));
          return (
            this.changes.forEach((i, o) => {
              const s = this.us.get(i);
              if ((t.push(this.os.removeEntry(e, i, s.readTime)), o.isValidDocument())) {
                const a = Cc(this.os.serializer, o);
                r = r.add(i.path.popLast());
                const u = Il(a);
                (n += u - s.size), t.push(this.os.addEntry(e, i, a));
              } else if (((n -= s.size), this.trackRemovals)) {
                const n = Cc(this.os.serializer, o.convertToNoDocument(Ai.min()));
                t.push(this.os.addEntry(e, i, n));
              }
            }),
            r.forEach(n => {
              t.push(this.os.indexManager.addToCollectionParentIndex(e, n));
            }),
            t.push(this.os.updateMetadata(e, n)),
            zi.waitFor(t)
          );
        }
        getFromCache(e, t) {
          return this.os.es(e, t).next(e => (this.us.set(t, { size: e.size, readTime: e.document.readTime }), e.document));
        }
        getAllFromCache(e, t) {
          return this.os.ss(e, t).next(
            ({ documents: e, rs: t }) => (
              t.forEach((t, n) => {
                this.us.set(t, { size: n, readTime: e.get(t).readTime });
              }),
              e
            )
          );
        }
      }
      function zl(e) {
        return Lo(e, 'remoteDocumentGlobal');
      }
      function Gl(e) {
        return Lo(e, 'remoteDocumentsV14');
      }
      function Wl(e) {
        const t = e.path.toArray();
        return [t.slice(0, t.length - 2), t[t.length - 2], t[t.length - 1]];
      }
      function Hl(e, t) {
        const n = t.documentKey.path.toArray();
        return [e, kc(t.readTime), n.slice(0, n.length - 2), n.length > 0 ? n[n.length - 1] : ''];
      }
      function Kl(e, t) {
        const n = e.path.toArray(),
          r = t.path.toArray();
        let i = 0;
        for (let o = 0; o < n.length - 2 && o < r.length - 2; ++o) if (((i = Ii(n[o], r[o])), i)) return i;
        return (i = Ii(n.length, r.length)), i || ((i = Ii(n[n.length - 2], r[r.length - 2])), i || Ii(n[n.length - 1], r[r.length - 1]));
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * @license
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class Ql {
        constructor(e, t) {
          (this.overlayedDocument = e), (this.mutatedFields = t);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Yl {
        constructor(e, t, n, r) {
          (this.remoteDocumentCache = e), (this.mutationQueue = t), (this.documentOverlayCache = n), (this.indexManager = r);
        }
        getDocument(e, t) {
          let n = null;
          return this.documentOverlayCache
            .getOverlay(e, t)
            .next(r => ((n = r), this.remoteDocumentCache.getEntry(e, t)))
            .next(e => (null !== n && au(n.mutation, e, Go.empty(), Ti.now()), e));
        }
        getDocuments(e, t) {
          return this.remoteDocumentCache.getEntries(e, t).next(t => this.getLocalViewOfDocuments(e, t, La()).next(() => t));
        }
        getLocalViewOfDocuments(e, t, n = La()) {
          const r = Oa();
          return this.populateOverlays(e, r, t).next(() =>
            this.computeViews(e, t, r, n).next(e => {
              let t = Ca();
              return (
                e.forEach((e, n) => {
                  t = t.insert(e, n.overlayedDocument);
                }),
                t
              );
            })
          );
        }
        getOverlayedDocuments(e, t) {
          const n = Oa();
          return this.populateOverlays(e, n, t).next(() => this.computeViews(e, t, n, La()));
        }
        populateOverlays(e, t, n) {
          const r = [];
          return (
            n.forEach(e => {
              t.has(e) || r.push(e);
            }),
            this.documentOverlayCache.getOverlays(e, r).next(e => {
              e.forEach((e, n) => {
                t.set(e, n);
              });
            })
          );
        }
        computeViews(e, t, n, r) {
          let i = Aa();
          const o = Ra(),
            s = Ra();
          return (
            t.forEach((e, t) => {
              const s = n.get(t.key);
              r.has(t.key) && (void 0 === s || s.mutation instanceof hu)
                ? (i = i.insert(t.key, t))
                : void 0 !== s
                  ? (o.set(t.key, s.mutation.getFieldMask()), au(s.mutation, t, s.mutation.getFieldMask(), Ti.now()))
                  : o.set(t.key, Go.empty());
            }),
            this.recalculateAndSaveOverlays(e, i).next(
              e => (
                e.forEach((e, t) => o.set(e, t)),
                t.forEach((e, t) => {
                  var n;
                  return s.set(e, new Ql(t, null !== (n = o.get(e)) && void 0 !== n ? n : null));
                }),
                s
              )
            )
          );
        }
        recalculateAndSaveOverlays(e, t) {
          const n = Ra();
          let r = new Uo((e, t) => e - t),
            i = La();
          return this.mutationQueue
            .getAllMutationBatchesAffectingDocumentKeys(e, t)
            .next(e => {
              for (const i of e)
                i.keys().forEach(e => {
                  const o = t.get(e);
                  if (null === o) return;
                  let s = n.get(e) || Go.empty();
                  (s = i.applyToLocalView(o, s)), n.set(e, s);
                  const a = (r.get(i.batchId) || La()).add(e);
                  r = r.insert(i.batchId, a);
                });
            })
            .next(() => {
              const o = [],
                s = r.getReverseIterator();
              for (; s.hasNext(); ) {
                const r = s.getNext(),
                  a = r.key,
                  u = r.value,
                  c = Na();
                u.forEach(e => {
                  if (!i.has(e)) {
                    const r = ou(t.get(e), n.get(e));
                    null !== r && c.set(e, r), (i = i.add(e));
                  }
                }),
                  o.push(this.documentOverlayCache.saveOverlays(e, a, c));
              }
              return zi.waitFor(o);
            })
            .next(() => n);
        }
        recalculateAndSaveOverlaysForDocumentKeys(e, t) {
          return this.remoteDocumentCache.getEntries(e, t).next(t => this.recalculateAndSaveOverlays(e, t));
        }
        getDocumentsMatchingQuery(e, t, n) {
          return (function (e) {
            return Ni.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length;
          })(t)
            ? this.getDocumentsMatchingDocumentQuery(e, t.path)
            : fa(t)
              ? this.getDocumentsMatchingCollectionGroupQuery(e, t, n)
              : this.getDocumentsMatchingCollectionQuery(e, t, n);
        }
        getNextDocuments(e, t, n, r) {
          return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, n, r).next(i => {
            const o = r - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, n.largestBatchId, r - i.size) : zi.resolve(Oa());
            let s = -1,
              a = i;
            return o.next(t =>
              zi
                .forEach(
                  t,
                  (t, n) => (
                    s < n.largestBatchId && (s = n.largestBatchId),
                    i.get(t)
                      ? zi.resolve()
                      : this.remoteDocumentCache.getEntry(e, t).next(e => {
                          a = a.insert(t, e);
                        })
                  )
                )
                .next(() => this.populateOverlays(e, t, i))
                .next(() => this.computeViews(e, a, t, La()))
                .next(e => ({ batchId: s, changes: ka(e) }))
            );
          });
        }
        getDocumentsMatchingDocumentQuery(e, t) {
          return this.getDocument(e, new Ni(t)).next(e => {
            let t = Ca();
            return e.isFoundDocument() && (t = t.insert(e.key, e)), t;
          });
        }
        getDocumentsMatchingCollectionGroupQuery(e, t, n) {
          const r = t.collectionGroup;
          let i = Ca();
          return this.indexManager.getCollectionParents(e, r).next(o =>
            zi
              .forEach(o, o => {
                const s = (function (e, t) {
                  return new sa(t, null, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt);
                })(t, o.child(r));
                return this.getDocumentsMatchingCollectionQuery(e, s, n).next(e => {
                  e.forEach((e, t) => {
                    i = i.insert(e, t);
                  });
                });
              })
              .next(() => i)
          );
        }
        getDocumentsMatchingCollectionQuery(e, t, n) {
          let r;
          return this.documentOverlayCache
            .getOverlaysForCollection(e, t.path, n.largestBatchId)
            .next(i => ((r = i), this.remoteDocumentCache.getDocumentsMatchingQuery(e, t, n, r)))
            .next(e => {
              r.forEach((t, n) => {
                const r = n.getKey();
                null === e.get(r) && (e = e.insert(r, xs.newInvalidDocument(r)));
              });
              let n = Ca();
              return (
                e.forEach((e, i) => {
                  const o = r.get(e);
                  void 0 !== o && au(o.mutation, i, Go.empty(), Ti.now()), ba(t, i) && (n = n.insert(e, i));
                }),
                n
              );
            });
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Xl {
        constructor(e) {
          (this.serializer = e), (this.cs = new Map()), (this.hs = new Map());
        }
        getBundleMetadata(e, t) {
          return zi.resolve(this.cs.get(t));
        }
        saveBundleMetadata(e, t) {
          var n;
          return this.cs.set(t.id, { id: (n = t).id, version: n.version, createTime: Yu(n.createTime) }), zi.resolve();
        }
        getNamedQuery(e, t) {
          return zi.resolve(this.hs.get(t));
        }
        saveNamedQuery(e, t) {
          return (
            this.hs.set(
              t.name,
              (function (e) {
                return { name: e.name, query: Lc(e.bundledQuery), readTime: Yu(e.readTime) };
              })(t)
            ),
            zi.resolve()
          );
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Jl {
        constructor() {
          (this.overlays = new Uo(Ni.comparator)), (this.ls = new Map());
        }
        getOverlay(e, t) {
          return zi.resolve(this.overlays.get(t));
        }
        getOverlays(e, t) {
          const n = Oa();
          return zi
            .forEach(t, t =>
              this.getOverlay(e, t).next(e => {
                null !== e && n.set(t, e);
              })
            )
            .next(() => n);
        }
        saveOverlays(e, t, n) {
          return (
            n.forEach((n, r) => {
              this.we(e, t, r);
            }),
            zi.resolve()
          );
        }
        removeOverlaysForBatchId(e, t, n) {
          const r = this.ls.get(n);
          return void 0 !== r && (r.forEach(e => (this.overlays = this.overlays.remove(e))), this.ls.delete(n)), zi.resolve();
        }
        getOverlaysForCollection(e, t, n) {
          const r = Oa(),
            i = t.length + 1,
            o = new Ni(t.child('')),
            s = this.overlays.getIteratorFrom(o);
          for (; s.hasNext(); ) {
            const e = s.getNext().value,
              o = e.getKey();
            if (!t.isPrefixOf(o.path)) break;
            o.path.length === i && e.largestBatchId > n && r.set(e.getKey(), e);
          }
          return zi.resolve(r);
        }
        getOverlaysForCollectionGroup(e, t, n, r) {
          let i = new Uo((e, t) => e - t);
          const o = this.overlays.getIterator();
          for (; o.hasNext(); ) {
