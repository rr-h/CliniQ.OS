remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
        copy(e, t, n, r, i) {
          return new Bo(
            null != e ? e : this.key,
            null != t ? t : this.value,
            null != n ? n : this.color,
            null != r ? r : this.left,
            null != i ? i : this.right
          );
        }
        isEmpty() {
          return !1;
        }
        inorderTraversal(e) {
          return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
        }
        reverseTraversal(e) {
          return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
        }
        min() {
          return this.left.isEmpty() ? this : this.left.min();
        }
        minKey() {
          return this.min().key;
        }
        maxKey() {
          return this.right.isEmpty() ? this.key : this.right.maxKey();
        }
        insert(e, t, n) {
          let r = this;
          const i = n(e, r.key);
          return (
            (r =
              i < 0
                ? r.copy(null, null, null, r.left.insert(e, t, n), null)
                : 0 === i
                  ? r.copy(null, t, null, null, null)
                  : r.copy(null, null, null, null, r.right.insert(e, t, n))),
            r.fixUp()
          );
        }
        removeMin() {
          if (this.left.isEmpty()) return Bo.EMPTY;
          let e = this;
          return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), (e = e.copy(null, null, null, e.left.removeMin(), null)), e.fixUp();
        }
        remove(e, t) {
          let n,
            r = this;
          if (t(e, r.key) < 0)
            r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()),
              (r = r.copy(null, null, null, r.left.remove(e, t), null));
          else {
            if (
              (r.left.isRed() && (r = r.rotateRight()),
              r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()),
              0 === t(e, r.key))
            ) {
              if (r.right.isEmpty()) return Bo.EMPTY;
              (n = r.right.min()), (r = r.copy(n.key, n.value, null, null, r.right.removeMin()));
            }
            r = r.copy(null, null, null, null, r.right.remove(e, t));
          }
          return r.fixUp();
        }
        isRed() {
          return this.color;
        }
        fixUp() {
          let e = this;
          return (
            e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()),
            e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()),
            e.left.isRed() && e.right.isRed() && (e = e.colorFlip()),
            e
          );
        }
        moveRedLeft() {
          let e = this.colorFlip();
          return e.right.left.isRed() && ((e = e.copy(null, null, null, null, e.right.rotateRight())), (e = e.rotateLeft()), (e = e.colorFlip())), e;
        }
        moveRedRight() {
          let e = this.colorFlip();
          return e.left.left.isRed() && ((e = e.rotateRight()), (e = e.colorFlip())), e;
        }
        rotateLeft() {
          const e = this.copy(null, null, Bo.RED, null, this.right.left);
          return this.right.copy(null, null, this.color, e, null);
        }
        rotateRight() {
          const e = this.copy(null, null, Bo.RED, this.left.right, null);
          return this.left.copy(null, null, this.color, null, e);
        }
        colorFlip() {
          const e = this.left.copy(null, null, !this.left.color, null, null),
            t = this.right.copy(null, null, !this.right.color, null, null);
          return this.copy(null, null, !this.color, e, t);
        }
        checkMaxDepth() {
          const e = this.check();
          return Math.pow(2, e) <= this.size + 1;
        }
        check() {
          if (this.isRed() && this.left.isRed()) throw oi();
          if (this.right.isRed()) throw oi();
          const e = this.left.check();
          if (e !== this.right.check()) throw oi();
          return e + (this.isRed() ? 0 : 1);
        }
      }
      (Bo.EMPTY = null),
        (Bo.RED = !0),
        (Bo.BLACK = !1),
        (Bo.EMPTY = new (class {
          constructor() {
            this.size = 0;
          }
          get key() {
            throw oi();
          }
          get value() {
            throw oi();
          }
          get color() {
            throw oi();
          }
          get left() {
            throw oi();
          }
          get right() {
            throw oi();
          }
          copy(e, t, n, r, i) {
            return this;
          }
          insert(e, t, n) {
            return new Bo(e, t);
          }
          remove(e, t) {
            return this;
          }
          isEmpty() {
            return !0;
          }
          inorderTraversal(e) {
            return !1;
          }
          reverseTraversal(e) {
            return !1;
          }
          minKey() {
            return null;
          }
          maxKey() {
            return null;
          }
          isRed() {
            return !1;
          }
          checkMaxDepth() {
            return !0;
          }
          check() {
            return 0;
          }
        })());
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class $o {
        constructor(e) {
          (this.comparator = e), (this.data = new Uo(this.comparator));
        }
        has(e) {
          return null !== this.data.get(e);
        }
        first() {
          return this.data.minKey();
        }
        last() {
          return this.data.maxKey();
        }
        get size() {
          return this.data.size;
        }
        indexOf(e) {
          return this.data.indexOf(e);
        }
        forEach(e) {
          this.data.inorderTraversal((t, n) => (e(t), !1));
        }
        forEachInRange(e, t) {
          const n = this.data.getIteratorFrom(e[0]);
          for (; n.hasNext(); ) {
            const r = n.getNext();
            if (this.comparator(r.key, e[1]) >= 0) return;
            t(r.key);
          }
        }
        forEachWhile(e, t) {
          let n;
          for (n = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); n.hasNext(); ) if (!e(n.getNext().key)) return;
        }
        firstAfterOrEqual(e) {
          const t = this.data.getIteratorFrom(e);
          return t.hasNext() ? t.getNext().key : null;
        }
        getIterator() {
          return new qo(this.data.getIterator());
        }
        getIteratorFrom(e) {
          return new qo(this.data.getIteratorFrom(e));
        }
        add(e) {
          return this.copy(this.data.remove(e).insert(e, !0));
        }
        delete(e) {
          return this.has(e) ? this.copy(this.data.remove(e)) : this;
        }
        isEmpty() {
          return this.data.isEmpty();
        }
        unionWith(e) {
          let t = this;
          return (
            t.size < e.size && ((t = e), (e = this)),
            e.forEach(e => {
              t = t.add(e);
            }),
            t
          );
        }
        isEqual(e) {
          if (!(e instanceof $o)) return !1;
          if (this.size !== e.size) return !1;
          const t = this.data.getIterator(),
            n = e.data.getIterator();
          for (; t.hasNext(); ) {
            const e = t.getNext().key,
              r = n.getNext().key;
            if (0 !== this.comparator(e, r)) return !1;
          }
          return !0;
        }
        toArray() {
          const e = [];
          return (
            this.forEach(t => {
              e.push(t);
            }),
            e
          );
        }
        toString() {
          const e = [];
          return this.forEach(t => e.push(t)), 'SortedSet(' + e.toString() + ')';
        }
        copy(e) {
          const t = new $o(this.comparator);
          return (t.data = e), t;
        }
      }
      class qo {
        constructor(e) {
          this.iter = e;
        }
        getNext() {
          return this.iter.getNext().key;
        }
        hasNext() {
          return this.iter.hasNext();
        }
      }
      function zo(e) {
        return e.hasNext() ? e.getNext() : void 0;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Go {
        constructor(e) {
          (this.fields = e), e.sort(Oi.comparator);
        }
        static empty() {
          return new Go([]);
        }
        unionWith(e) {
          let t = new $o(Oi.comparator);
          for (const n of this.fields) t = t.add(n);
          for (const n of e) t = t.add(n);
          return new Go(t.toArray());
        }
        covers(e) {
          for (const t of this.fields) if (t.isPrefixOf(e)) return !0;
          return !1;
        }
        isEqual(e) {
          return Ei(this.fields, e.fields, (e, t) => e.isEqual(t));
        }
      }
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Wo extends Error {
        constructor() {
          super(...arguments), (this.name = 'Base64DecodeError');
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Ho() {
        return 'undefined' != typeof atob;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ko {
        constructor(e) {
          this.binaryString = e;
        }
        static fromBase64String(e) {
          const t = (function (e) {
            try {
              return atob(e);
            } catch (e) {
              throw 'undefined' != typeof DOMException && e instanceof DOMException ? new Wo('Invalid base64 string: ' + e) : e;
            }
          })(e);
          return new Ko(t);
        }
        static fromUint8Array(e) {
          const t = (function (e) {
            let t = '';
            for (let n = 0; n < e.length; ++n) t += String.fromCharCode(e[n]);
            return t;
          })(e);
          return new Ko(t);
        }
        [Symbol.iterator]() {
          let e = 0;
          return {
            next: () => (e < this.binaryString.length ? { value: this.binaryString.charCodeAt(e++), done: !1 } : { value: void 0, done: !0 })
          };
        }
        toBase64() {
          return (e = this.binaryString), btoa(e);
          var e;
        }
        toUint8Array() {
          return (function (e) {
            const t = new Uint8Array(e.length);
            for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
            return t;
          })(
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ this.binaryString
          );
        }
        approximateByteSize() {
          return 2 * this.binaryString.length;
        }
        compareTo(e) {
          return Ii(this.binaryString, e.binaryString);
        }
        isEqual(e) {
          return this.binaryString === e.binaryString;
        }
      }
      Ko.EMPTY_BYTE_STRING = new Ko('');
      const Qo = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
      function Yo(e) {
        if ((si(!!e), 'string' == typeof e)) {
          let t = 0;
          const n = Qo.exec(e);
          if ((si(!!n), n[1])) {
            let e = n[1];
            (e = (e + '000000000').substr(0, 9)), (t = Number(e));
          }
          const r = new Date(e);
          return { seconds: Math.floor(r.getTime() / 1e3), nanos: t };
        }
        return { seconds: Xo(e.seconds), nanos: Xo(e.nanos) };
      }
      function Xo(e) {
        return 'number' == typeof e ? e : 'string' == typeof e ? Number(e) : 0;
      }
      function Jo(e) {
        return 'string' == typeof e ? Ko.fromBase64String(e) : Ko.fromUint8Array(e);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Zo(e) {
        var t, n;
        return (
          'server_timestamp' ===
          (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {}).__type__) || void 0 === n
            ? void 0
            : n.stringValue)
        );
      }
      function es(e) {
        const t = e.mapValue.fields.__previous_value__;
        return Zo(t) ? es(t) : t;
      }
      function ts(e) {
        const t = Yo(e.mapValue.fields.__local_write_time__.timestampValue);
        return new Ti(t.seconds, t.nanos);
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ns {
        constructor(e, t, n, r, i, o, s, a, u) {
          (this.databaseId = e),
            (this.appId = t),
            (this.persistenceKey = n),
            (this.host = r),
            (this.ssl = i),
            (this.forceLongPolling = o),
            (this.autoDetectLongPolling = s),
            (this.longPollingOptions = a),
            (this.useFetchStreams = u);
        }
      }
      class rs {
        constructor(e, t) {
          (this.projectId = e), (this.database = t || '(default)');
        }
        static empty() {
          return new rs('', '');
        }
        get isDefaultDatabase() {
          return '(default)' === this.database;
        }
        isEqual(e) {
          return e instanceof rs && e.projectId === this.projectId && e.database === this.database;
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const is = { mapValue: { fields: { __type__: { stringValue: '__max__' } } } },
        os = { nullValue: 'NULL_VALUE' };
      function ss(e) {
        return 'nullValue' in e
          ? 0
          : 'booleanValue' in e
            ? 1
            : 'integerValue' in e || 'doubleValue' in e
              ? 2
              : 'timestampValue' in e
                ? 3
                : 'stringValue' in e
                  ? 5
                  : 'bytesValue' in e
                    ? 6
                    : 'referenceValue' in e
                      ? 7
                      : 'geoPointValue' in e
                        ? 8
                        : 'arrayValue' in e
                          ? 9
                          : 'mapValue' in e
                            ? Zo(e)
                              ? 4
                              : bs(e)
                                ? 9007199254740991
                                : 10
                            : oi();
      }
      function as(e, t) {
        if (e === t) return !0;
        const n = ss(e);
        if (n !== ss(t)) return !1;
        switch (n) {
          case 0:
          case 9007199254740991:
            return !0;
          case 1:
            return e.booleanValue === t.booleanValue;
          case 4:
            return ts(e).isEqual(ts(t));
          case 3:
            return (function (e, t) {
              if ('string' == typeof e.timestampValue && 'string' == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length)
                return e.timestampValue === t.timestampValue;
              const n = Yo(e.timestampValue),
                r = Yo(t.timestampValue);
              return n.seconds === r.seconds && n.nanos === r.nanos;
            })(e, t);
          case 5:
            return e.stringValue === t.stringValue;
          case 6:
            return (function (e, t) {
              return Jo(e.bytesValue).isEqual(Jo(t.bytesValue));
            })(e, t);
          case 7:
            return e.referenceValue === t.referenceValue;
          case 8:
            return (function (e, t) {
              return Xo(e.geoPointValue.latitude) === Xo(t.geoPointValue.latitude) && Xo(e.geoPointValue.longitude) === Xo(t.geoPointValue.longitude);
            })(e, t);
          case 2:
            return (function (e, t) {
              if ('integerValue' in e && 'integerValue' in t) return Xo(e.integerValue) === Xo(t.integerValue);
              if ('doubleValue' in e && 'doubleValue' in t) {
                const n = Xo(e.doubleValue),
                  r = Xo(t.doubleValue);
                return n === r ? io(n) === io(r) : isNaN(n) && isNaN(r);
              }
              return !1;
            })(e, t);
          case 9:
            return Ei(e.arrayValue.values || [], t.arrayValue.values || [], as);
          case 10:
            return (function (e, t) {
              const n = e.mapValue.fields || {},
                r = t.mapValue.fields || {};
              if (jo(n) !== jo(r)) return !1;
              for (const i in n) if (n.hasOwnProperty(i) && (void 0 === r[i] || !as(n[i], r[i]))) return !1;
              return !0;
            })(e, t);
          default:
            return oi();
        }
      }
      function us(e, t) {
        return void 0 !== (e.values || []).find(e => as(e, t));
      }
      function cs(e, t) {
        if (e === t) return 0;
        const n = ss(e),
          r = ss(t);
        if (n !== r) return Ii(n, r);
        switch (n) {
          case 0:
          case 9007199254740991:
            return 0;
          case 1:
            return Ii(e.booleanValue, t.booleanValue);
          case 2:
            return (function (e, t) {
              const n = Xo(e.integerValue || e.doubleValue),
                r = Xo(t.integerValue || t.doubleValue);
              return n < r ? -1 : n > r ? 1 : n === r ? 0 : isNaN(n) ? (isNaN(r) ? 0 : -1) : 1;
            })(e, t);
          case 3:
            return ls(e.timestampValue, t.timestampValue);
          case 4:
            return ls(ts(e), ts(t));
          case 5:
            return Ii(e.stringValue, t.stringValue);
          case 6:
            return (function (e, t) {
              const n = Jo(e),
                r = Jo(t);
              return n.compareTo(r);
            })(e.bytesValue, t.bytesValue);
          case 7:
            return (function (e, t) {
              const n = e.split('/'),
                r = t.split('/');
              for (let i = 0; i < n.length && i < r.length; i++) {
                const e = Ii(n[i], r[i]);
                if (0 !== e) return e;
              }
              return Ii(n.length, r.length);
            })(e.referenceValue, t.referenceValue);
          case 8:
            return (function (e, t) {
              const n = Ii(Xo(e.latitude), Xo(t.latitude));
              return 0 !== n ? n : Ii(Xo(e.longitude), Xo(t.longitude));
            })(e.geoPointValue, t.geoPointValue);
          case 9:
            return (function (e, t) {
              const n = e.values || [],
                r = t.values || [];
              for (let i = 0; i < n.length && i < r.length; ++i) {
                const e = cs(n[i], r[i]);
                if (e) return e;
              }
              return Ii(n.length, r.length);
            })(e.arrayValue, t.arrayValue);
          case 10:
            return (function (e, t) {
              if (e === is.mapValue && t === is.mapValue) return 0;
              if (e === is.mapValue) return 1;
              if (t === is.mapValue) return -1;
              const n = e.fields || {},
                r = Object.keys(n),
                i = t.fields || {},
                o = Object.keys(i);
              r.sort(), o.sort();
              for (let s = 0; s < r.length && s < o.length; ++s) {
                const e = Ii(r[s], o[s]);
                if (0 !== e) return e;
                const t = cs(n[r[s]], i[o[s]]);
                if (0 !== t) return t;
              }
              return Ii(r.length, o.length);
            })(e.mapValue, t.mapValue);
          default:
            throw oi();
        }
      }
      function ls(e, t) {
        if ('string' == typeof e && 'string' == typeof t && e.length === t.length) return Ii(e, t);
        const n = Yo(e),
          r = Yo(t),
          i = Ii(n.seconds, r.seconds);
        return 0 !== i ? i : Ii(n.nanos, r.nanos);
      }
      function hs(e) {
        return fs(e);
      }
      function fs(e) {
        return 'nullValue' in e
          ? 'null'
          : 'booleanValue' in e
            ? '' + e.booleanValue
            : 'integerValue' in e
              ? '' + e.integerValue
              : 'doubleValue' in e
                ? '' + e.doubleValue
                : 'timestampValue' in e
                  ? (function (e) {
                      const t = Yo(e);
                      return `time(${t.seconds},${t.nanos})`;
                    })(e.timestampValue)
                  : 'stringValue' in e
                    ? e.stringValue
                    : 'bytesValue' in e
                      ? Jo(e.bytesValue).toBase64()
                      : 'referenceValue' in e
                        ? ((n = e.referenceValue), Ni.fromName(n).toString())
                        : 'geoPointValue' in e
                          ? `geo(${(t = e.geoPointValue).latitude},${t.longitude})`
                          : 'arrayValue' in e
                            ? (function (e) {
                                let t = '[',
                                  n = !0;
                                for (const r of e.values || []) n ? (n = !1) : (t += ','), (t += fs(r));
                                return t + ']';
                              })(e.arrayValue)
                            : 'mapValue' in e
                              ? (function (e) {
                                  const t = Object.keys(e.fields || {}).sort();
                                  let n = '{',
                                    r = !0;
                                  for (const i of t) r ? (r = !1) : (n += ','), (n += `${i}:${fs(e.fields[i])}`);
                                  return n + '}';
                                })(e.mapValue)
                              : oi();
        var t, n;
      }
      function ds(e, t) {
        return { referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}` };
      }
      function ps(e) {
        return !!e && 'integerValue' in e;
      }
      function gs(e) {
        return !!e && 'arrayValue' in e;
      }
      function ms(e) {
        return !!e && 'nullValue' in e;
      }
      function vs(e) {
        return !!e && 'doubleValue' in e && isNaN(Number(e.doubleValue));
      }
      function ys(e) {
        return !!e && 'mapValue' in e;
      }
      function ws(e) {
        if (e.geoPointValue) return { geoPointValue: Object.assign({}, e.geoPointValue) };
        if (e.timestampValue && 'object' == typeof e.timestampValue) return { timestampValue: Object.assign({}, e.timestampValue) };
        if (e.mapValue) {
          const t = { mapValue: { fields: {} } };
          return Mo(e.mapValue.fields, (e, n) => (t.mapValue.fields[e] = ws(n))), t;
        }
        if (e.arrayValue) {
          const t = { arrayValue: { values: [] } };
          for (let n = 0; n < (e.arrayValue.values || []).length; ++n) t.arrayValue.values[n] = ws(e.arrayValue.values[n]);
          return t;
        }
        return Object.assign({}, e);
      }
      function bs(e) {
        return '__max__' === (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue;
      }
      function _s(e) {
        return 'nullValue' in e
          ? os
          : 'booleanValue' in e
            ? { booleanValue: !1 }
            : 'integerValue' in e || 'doubleValue' in e
              ? { doubleValue: NaN }
              : 'timestampValue' in e
                ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } }
                : 'stringValue' in e
                  ? { stringValue: '' }
                  : 'bytesValue' in e
                    ? { bytesValue: '' }
                    : 'referenceValue' in e
                      ? ds(rs.empty(), Ni.empty())
                      : 'geoPointValue' in e
                        ? { geoPointValue: { latitude: -90, longitude: -180 } }
                        : 'arrayValue' in e
                          ? { arrayValue: {} }
                          : 'mapValue' in e
                            ? { mapValue: {} }
                            : oi();
      }
      function Is(e) {
        return 'nullValue' in e
          ? { booleanValue: !1 }
          : 'booleanValue' in e
            ? { doubleValue: NaN }
            : 'integerValue' in e || 'doubleValue' in e
              ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } }
              : 'timestampValue' in e
                ? { stringValue: '' }
                : 'stringValue' in e
                  ? { bytesValue: '' }
                  : 'bytesValue' in e
                    ? ds(rs.empty(), Ni.empty())
                    : 'referenceValue' in e
                      ? { geoPointValue: { latitude: -90, longitude: -180 } }
                      : 'geoPointValue' in e
                        ? { arrayValue: {} }
                        : 'arrayValue' in e
                          ? { mapValue: {} }
                          : 'mapValue' in e
                            ? is
                            : oi();
      }
      function Es(e, t) {
        const n = cs(e.value, t.value);
        return 0 !== n ? n : e.inclusive && !t.inclusive ? -1 : !e.inclusive && t.inclusive ? 1 : 0;
      }
      function Ss(e, t) {
        const n = cs(e.value, t.value);
        return 0 !== n ? n : e.inclusive && !t.inclusive ? 1 : !e.inclusive && t.inclusive ? -1 : 0;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ts {
        constructor(e) {
          this.value = e;
        }
        static empty() {
          return new Ts({ mapValue: {} });
        }
        field(e) {
          if (e.isEmpty()) return this.value;
          {
            let t = this.value;
            for (let n = 0; n < e.length - 1; ++n) if (((t = (t.mapValue.fields || {})[e.get(n)]), !ys(t))) return null;
            return (t = (t.mapValue.fields || {})[e.lastSegment()]), t || null;
          }
        }
        set(e, t) {
          this.getFieldsMap(e.popLast())[e.lastSegment()] = ws(t);
        }
        setAll(e) {
          let t = Oi.emptyPath(),
            n = {},
            r = [];
          e.forEach((e, i) => {
            if (!t.isImmediateParentOf(i)) {
              const e = this.getFieldsMap(t);
              this.applyChanges(e, n, r), (n = {}), (r = []), (t = i.popLast());
            }
            e ? (n[i.lastSegment()] = ws(e)) : r.push(i.lastSegment());
          });
          const i = this.getFieldsMap(t);
          this.applyChanges(i, n, r);
        }
        delete(e) {
          const t = this.field(e.popLast());
          ys(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
        }
        isEqual(e) {
          return as(this.value, e.value);
        }
        getFieldsMap(e) {
          let t = this.value;
          t.mapValue.fields || (t.mapValue = { fields: {} });
          for (let n = 0; n < e.length; ++n) {
            let r = t.mapValue.fields[e.get(n)];
            (ys(r) && r.mapValue.fields) || ((r = { mapValue: { fields: {} } }), (t.mapValue.fields[e.get(n)] = r)), (t = r);
          }
          return t.mapValue.fields;
        }
        applyChanges(e, t, n) {
          Mo(t, (t, n) => (e[t] = n));
          for (const r of n) delete e[r];
        }
        clone() {
          return new Ts(ws(this.value));
        }
      }
      function As(e) {
        const t = [];
        return (
          Mo(e.fields, (e, n) => {
            const r = new Oi([e]);
            if (ys(n)) {
              const e = As(n.mapValue).fields;
              if (0 === e.length) t.push(r);
              else for (const n of e) t.push(r.child(n));
            } else t.push(r);
          }),
          new Go(t)
        );
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class xs {
        constructor(e, t, n, r, i, o, s) {
          (this.key = e),
            (this.documentType = t),
            (this.version = n),
            (this.readTime = r),
            (this.createTime = i),
            (this.data = o),
            (this.documentState = s);
        }
        static newInvalidDocument(e) {
          return new xs(e, 0, Ai.min(), Ai.min(), Ai.min(), Ts.empty(), 0);
        }
        static newFoundDocument(e, t, n, r) {
          return new xs(e, 1, t, Ai.min(), n, r, 0);
        }
        static newNoDocument(e, t) {
          return new xs(e, 2, t, Ai.min(), Ai.min(), Ts.empty(), 0);
        }
        static newUnknownDocument(e, t) {
          return new xs(e, 3, t, Ai.min(), Ai.min(), Ts.empty(), 2);
        }
        convertToFoundDocument(e, t) {
          return (
            !this.createTime.isEqual(Ai.min()) || (2 !== this.documentType && 0 !== this.documentType) || (this.createTime = e),
            (this.version = e),
            (this.documentType = 1),
            (this.data = t),
            (this.documentState = 0),
            this
          );
        }
        convertToNoDocument(e) {
          return (this.version = e), (this.documentType = 2), (this.data = Ts.empty()), (this.documentState = 0), this;
        }
        convertToUnknownDocument(e) {
          return (this.version = e), (this.documentType = 3), (this.data = Ts.empty()), (this.documentState = 2), this;
        }
        setHasCommittedMutations() {
          return (this.documentState = 2), this;
        }
        setHasLocalMutations() {
          return (this.documentState = 1), (this.version = Ai.min()), this;
        }
        setReadTime(e) {
          return (this.readTime = e), this;
        }
        get hasLocalMutations() {
          return 1 === this.documentState;
        }
        get hasCommittedMutations() {
          return 2 === this.documentState;
        }
        get hasPendingWrites() {
          return this.hasLocalMutations || this.hasCommittedMutations;
        }
        isValidDocument() {
          return 0 !== this.documentType;
        }
        isFoundDocument() {
          return 1 === this.documentType;
        }
        isNoDocument() {
          return 2 === this.documentType;
        }
        isUnknownDocument() {
          return 3 === this.documentType;
        }
        isEqual(e) {
          return (
            e instanceof xs &&
            this.key.isEqual(e.key) &&
            this.version.isEqual(e.version) &&
            this.documentType === e.documentType &&
            this.documentState === e.documentState &&
            this.data.isEqual(e.data)
          );
        }
        mutableCopy() {
          return new xs(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
        }
        toString() {
          return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Cs {
        constructor(e, t) {
          (this.position = e), (this.inclusive = t);
        }
      }
      function ks(e, t, n) {
        let r = 0;
        for (let i = 0; i < e.position.length; i++) {
          const o = t[i],
            s = e.position[i];
          if (
            ((r = o.field.isKeyField() ? Ni.comparator(Ni.fromName(s.referenceValue), n.key) : cs(s, n.data.field(o.field))),
            'desc' === o.dir && (r *= -1),
            0 !== r)
          )
            break;
        }
        return r;
      }
      function Os(e, t) {
        if (null === e) return null === t;
        if (null === t) return !1;
        if (e.inclusive !== t.inclusive || e.position.length !== t.position.length) return !1;
        for (let n = 0; n < e.position.length; n++) if (!as(e.position[n], t.position[n])) return !1;
        return !0;
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ns {
        constructor(e, t = 'asc') {
          (this.field = e), (this.dir = t);
        }
      }
      function Rs(e, t) {
        return e.dir === t.dir && e.field.isEqual(t.field);
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ps {}
      class Ds extends Ps {
        constructor(e, t, n) {
          super(), (this.field = e), (this.op = t), (this.value = n);
        }
        static create(e, t, n) {
          return e.isKeyField()
            ? 'in' === t || 'not-in' === t
              ? this.createKeyFieldInFilter(e, t, n)
              : new zs(e, t, n)
            : 'array-contains' === t
              ? new Ks(e, n)
              : 'in' === t
                ? new Qs(e, n)
                : 'not-in' === t
                  ? new Ys(e, n)
                  : 'array-contains-any' === t
                    ? new Xs(e, n)
                    : new Ds(e, t, n);
        }
        static createKeyFieldInFilter(e, t, n) {
          return 'in' === t ? new Gs(e, n) : new Ws(e, n);
        }
        matches(e) {
          const t = e.data.field(this.field);
          return '!=' === this.op
            ? null !== t && this.matchesComparison(cs(t, this.value))
            : null !== t && ss(this.value) === ss(t) && this.matchesComparison(cs(t, this.value));
        }
        matchesComparison(e) {
          switch (this.op) {
            case '<':
              return e < 0;
            case '<=':
              return e <= 0;
            case '==':
              return 0 === e;
            case '!=':
              return 0 !== e;
            case '>':
              return e > 0;
            case '>=':
              return e >= 0;
            default:
              return oi();
          }
        }
        isInequality() {
          return ['<', '<=', '>', '>=', '!=', 'not-in'].indexOf(this.op) >= 0;
        }
        getFlattenedFilters() {
          return [this];
        }
        getFilters() {
          return [this];
        }
        getFirstInequalityField() {
          return this.isInequality() ? this.field : null;
        }
      }
      class Ls extends Ps {
        constructor(e, t) {
          super(), (this.filters = e), (this.op = t), (this.lt = null);
        }
        static create(e, t) {
          return new Ls(e, t);
        }
        matches(e) {
          return js(this) ? void 0 === this.filters.find(t => !t.matches(e)) : void 0 !== this.filters.find(t => t.matches(e));
        }
        getFlattenedFilters() {
          return null !== this.lt || (this.lt = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.lt;
        }
        getFilters() {
          return Object.assign([], this.filters);
        }
        getFirstInequalityField() {
          const e = this.ft(e => e.isInequality());
          return null !== e ? e.field : null;
        }
        ft(e) {
          for (const t of this.getFlattenedFilters()) if (e(t)) return t;
          return null;
        }
      }
      function js(e) {
        return 'and' === e.op;
      }
      function Ms(e) {
        return 'or' === e.op;
      }
      function Fs(e) {
        return Us(e) && js(e);
      }
      function Us(e) {
        for (const t of e.filters) if (t instanceof Ls) return !1;
        return !0;
      }
      function Vs(e) {
        if (e instanceof Ds) return e.field.canonicalString() + e.op.toString() + hs(e.value);
        if (Fs(e)) return e.filters.map(e => Vs(e)).join(',');
        {
          const t = e.filters.map(e => Vs(e)).join(',');
          return `${e.op}(${t})`;
        }
      }
      function Bs(e, t) {
        return e instanceof Ds
          ? (function (e, t) {
              return t instanceof Ds && e.op === t.op && e.field.isEqual(t.field) && as(e.value, t.value);
            })(e, t)
          : e instanceof Ls
            ? (function (e, t) {
                return (
                  t instanceof Ls &&
                  e.op === t.op &&
                  e.filters.length === t.filters.length &&
                  e.filters.reduce((e, n, r) => e && Bs(n, t.filters[r]), !0)
                );
              })(e, t)
            : void oi();
      }
      function $s(e, t) {
        const n = e.filters.concat(t);
        return Ls.create(n, e.op);
      }
      function qs(e) {
        return e instanceof Ds
          ? (function (e) {
              return `${e.field.canonicalString()} ${e.op} ${hs(e.value)}`;
            })(e)
          : e instanceof Ls
            ? (function (e) {
                return e.op.toString() + ' {' + e.getFilters().map(qs).join(' ,') + '}';
              })(e)
            : 'Filter';
      }
      class zs extends Ds {
        constructor(e, t, n) {
          super(e, t, n), (this.key = Ni.fromName(n.referenceValue));
        }
        matches(e) {
          const t = Ni.comparator(e.key, this.key);
          return this.matchesComparison(t);
        }
      }
      class Gs extends Ds {
        constructor(e, t) {
          super(e, 'in', t), (this.keys = Hs('in', t));
        }
        matches(e) {
          return this.keys.some(t => t.isEqual(e.key));
        }
      }
      class Ws extends Ds {
        constructor(e, t) {
          super(e, 'not-in', t), (this.keys = Hs('not-in', t));
        }
        matches(e) {
          return !this.keys.some(t => t.isEqual(e.key));
        }
      }
      function Hs(e, t) {
        var n;
        return ((null === (n = t.arrayValue) || void 0 === n ? void 0 : n.values) || []).map(e => Ni.fromName(e.referenceValue));
      }
      class Ks extends Ds {
        constructor(e, t) {
          super(e, 'array-contains', t);
        }
        matches(e) {
          const t = e.data.field(this.field);
          return gs(t) && us(t.arrayValue, this.value);
        }
      }
      class Qs extends Ds {
        constructor(e, t) {
          super(e, 'in', t);
        }
        matches(e) {
          const t = e.data.field(this.field);
          return null !== t && us(this.value.arrayValue, t);
        }
      }
      class Ys extends Ds {
        constructor(e, t) {
          super(e, 'not-in', t);
        }
        matches(e) {
          if (us(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) return !1;
          const t = e.data.field(this.field);
          return null !== t && !us(this.value.arrayValue, t);
        }
      }
      class Xs extends Ds {
        constructor(e, t) {
          super(e, 'array-contains-any', t);
        }
        matches(e) {
          const t = e.data.field(this.field);
          return !(!gs(t) || !t.arrayValue.values) && t.arrayValue.values.some(e => us(this.value.arrayValue, e));
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Js {
        constructor(e, t = null, n = [], r = [], i = null, o = null, s = null) {
          (this.path = e),
            (this.collectionGroup = t),
            (this.orderBy = n),
            (this.filters = r),
            (this.limit = i),
            (this.startAt = o),
            (this.endAt = s),
            (this.dt = null);
        }
      }
      function Zs(e, t = null, n = [], r = [], i = null, o = null, s = null) {
        return new Js(e, t, n, r, i, o, s);
      }
      function ea(e) {
        const t = ui(e);
        if (null === t.dt) {
          let e = t.path.canonicalString();
          null !== t.collectionGroup && (e += '|cg:' + t.collectionGroup),
            (e += '|f:'),
            (e += t.filters.map(e => Vs(e)).join(',')),
            (e += '|ob:'),
            (e += t.orderBy
              .map(e =>
                (function (e) {
                  return e.field.canonicalString() + e.dir;
                })(e)
              )
              .join(',')),
            ro(t.limit) || ((e += '|l:'), (e += t.limit)),
            t.startAt && ((e += '|lb:'), (e += t.startAt.inclusive ? 'b:' : 'a:'), (e += t.startAt.position.map(e => hs(e)).join(','))),
            t.endAt && ((e += '|ub:'), (e += t.endAt.inclusive ? 'a:' : 'b:'), (e += t.endAt.position.map(e => hs(e)).join(','))),
            (t.dt = e);
        }
        return t.dt;
      }
      function ta(e, t) {
        if (e.limit !== t.limit) return !1;
        if (e.orderBy.length !== t.orderBy.length) return !1;
        for (let n = 0; n < e.orderBy.length; n++) if (!Rs(e.orderBy[n], t.orderBy[n])) return !1;
        if (e.filters.length !== t.filters.length) return !1;
        for (let n = 0; n < e.filters.length; n++) if (!Bs(e.filters[n], t.filters[n])) return !1;
        return e.collectionGroup === t.collectionGroup && !!e.path.isEqual(t.path) && !!Os(e.startAt, t.startAt) && Os(e.endAt, t.endAt);
      }
      function na(e) {
        return Ni.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length;
      }
      function ra(e, t) {
        return e.filters.filter(e => e instanceof Ds && e.field.isEqual(t));
      }
      function ia(e, t, n) {
        let r = os,
          i = !0;
        for (const o of ra(e, t)) {
          let e = os,
            t = !0;
          switch (o.op) {
            case '<':
            case '<=':
              e = _s(o.value);
              break;
            case '==':
            case 'in':
            case '>=':
              e = o.value;
              break;
            case '>':
              (e = o.value), (t = !1);
              break;
            case '!=':
            case 'not-in':
              e = os;
          }
          Es({ value: r, inclusive: i }, { value: e, inclusive: t }) < 0 && ((r = e), (i = t));
        }
        if (null !== n)
          for (let o = 0; o < e.orderBy.length; ++o)
            if (e.orderBy[o].field.isEqual(t)) {
              const e = n.position[o];
              Es({ value: r, inclusive: i }, { value: e, inclusive: n.inclusive }) < 0 && ((r = e), (i = n.inclusive));
              break;
            }
        return { value: r, inclusive: i };
      }
      function oa(e, t, n) {
        let r = is,
          i = !0;
        for (const o of ra(e, t)) {
          let e = is,
            t = !0;
          switch (o.op) {
            case '>=':
            case '>':
              (e = Is(o.value)), (t = !1);
              break;
            case '==':
            case 'in':
            case '<=':
              e = o.value;
              break;
            case '<':
              (e = o.value), (t = !1);
              break;
            case '!=':
            case 'not-in':
              e = is;
          }
          Ss({ value: r, inclusive: i }, { value: e, inclusive: t }) > 0 && ((r = e), (i = t));
        }
        if (null !== n)
          for (let o = 0; o < e.orderBy.length; ++o)
            if (e.orderBy[o].field.isEqual(t)) {
              const e = n.position[o];
              Ss({ value: r, inclusive: i }, { value: e, inclusive: n.inclusive }) > 0 && ((r = e), (i = n.inclusive));
              break;
            }
        return { value: r, inclusive: i };
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class sa {
        constructor(e, t = null, n = [], r = [], i = null, o = 'F', s = null, a = null) {
          (this.path = e),
            (this.collectionGroup = t),
            (this.explicitOrderBy = n),
            (this.filters = r),
            (this.limit = i),
            (this.limitType = o),
            (this.startAt = s),
            (this.endAt = a),
            (this.wt = null),
            (this._t = null),
            this.startAt,
            this.endAt;
        }
      }
      function aa(e, t, n, r, i, o, s, a) {
        return new sa(e, t, n, r, i, o, s, a);
      }
      function ua(e) {
        return new sa(e);
      }
      function ca(e) {
        return (
          0 === e.filters.length &&
          null === e.limit &&
          null == e.startAt &&
          null == e.endAt &&
          (0 === e.explicitOrderBy.length || (1 === e.explicitOrderBy.length && e.explicitOrderBy[0].field.isKeyField()))
        );
      }
      function la(e) {
        return e.explicitOrderBy.length > 0 ? e.explicitOrderBy[0].field : null;
      }
      function ha(e) {
        for (const t of e.filters) {
          const e = t.getFirstInequalityField();
          if (null !== e) return e;
        }
        return null;
      }
      function fa(e) {
        return null !== e.collectionGroup;
      }
      function da(e) {
        const t = ui(e);
        if (null === t.wt) {
          t.wt = [];
          const e = ha(t),
            n = la(t);
          if (null !== e && null === n) e.isKeyField() || t.wt.push(new Ns(e)), t.wt.push(new Ns(Oi.keyField(), 'asc'));
          else {
            let e = !1;
            for (const n of t.explicitOrderBy) t.wt.push(n), n.field.isKeyField() && (e = !0);
            if (!e) {
              const e = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : 'asc';
              t.wt.push(new Ns(Oi.keyField(), e));
            }
          }
        }
        return t.wt;
      }
      function pa(e) {
        const t = ui(e);
        if (!t._t)
          if ('F' === t.limitType) t._t = Zs(t.path, t.collectionGroup, da(t), t.filters, t.limit, t.startAt, t.endAt);
          else {
            const e = [];
            for (const i of da(t)) {
              const t = 'desc' === i.dir ? 'asc' : 'desc';
              e.push(new Ns(i.field, t));
            }
            const n = t.endAt ? new Cs(t.endAt.position, t.endAt.inclusive) : null,
              r = t.startAt ? new Cs(t.startAt.position, t.startAt.inclusive) : null;
            t._t = Zs(t.path, t.collectionGroup, e, t.filters, t.limit, n, r);
          }
        return t._t;
      }
      function ga(e, t) {
        t.getFirstInequalityField(), ha(e);
        const n = e.filters.concat([t]);
        return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), n, e.limit, e.limitType, e.startAt, e.endAt);
      }
      function ma(e, t, n) {
        return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), t, n, e.startAt, e.endAt);
      }
      function va(e, t) {
        return ta(pa(e), pa(t)) && e.limitType === t.limitType;
      }
      function ya(e) {
        return `${ea(pa(e))}|lt:${e.limitType}`;
      }
      function wa(e) {
        return `Query(target=${(function (e) {
          let t = e.path.canonicalString();
          return (
            null !== e.collectionGroup && (t += ' collectionGroup=' + e.collectionGroup),
            e.filters.length > 0 && (t += `, filters: [${e.filters.map(e => qs(e)).join(', ')}]`),
            ro(e.limit) || (t += ', limit: ' + e.limit),
            e.orderBy.length > 0 &&
              (t += `, orderBy: [${e.orderBy
                .map(e =>
                  (function (e) {
                    return `${e.field.canonicalString()} (${e.dir})`;
                  })(e)
                )
                .join(', ')}]`),
            e.startAt && ((t += ', startAt: '), (t += e.startAt.inclusive ? 'b:' : 'a:'), (t += e.startAt.position.map(e => hs(e)).join(','))),
            e.endAt && ((t += ', endAt: '), (t += e.endAt.inclusive ? 'a:' : 'b:'), (t += e.endAt.position.map(e => hs(e)).join(','))),
            `Target(${t})`
          );
        })(pa(e))}; limitType=${e.limitType})`;
      }
      function ba(e, t) {
        return (
          t.isFoundDocument() &&
          (function (e, t) {
            const n = t.key.path;
            return null !== e.collectionGroup
              ? t.key.hasCollectionId(e.collectionGroup) && e.path.isPrefixOf(n)
              : Ni.isDocumentKey(e.path)
                ? e.path.isEqual(n)
                : e.path.isImmediateParentOf(n);
          })(e, t) &&
          (function (e, t) {
            for (const n of da(e)) if (!n.field.isKeyField() && null === t.data.field(n.field)) return !1;
            return !0;
          })(e, t) &&
          (function (e, t) {
            for (const n of e.filters) if (!n.matches(t)) return !1;
            return !0;
          })(e, t) &&
          (function (e, t) {
            return (
              !(
                e.startAt &&
                !(function (e, t, n) {
                  const r = ks(e, t, n);
                  return e.inclusive ? r <= 0 : r < 0;
                })(e.startAt, da(e), t)
              ) &&
              !(
                e.endAt &&
                !(function (e, t, n) {
                  const r = ks(e, t, n);
                  return e.inclusive ? r >= 0 : r > 0;
                })(e.endAt, da(e), t)
              )
            );
          })(e, t)
        );
      }
      function _a(e) {
        return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2));
      }
      function Ia(e) {
        return (t, n) => {
          let r = !1;
          for (const i of da(e)) {
            const e = Ea(i, t, n);
            if (0 !== e) return e;
            r = r || i.field.isKeyField();
          }
          return 0;
        };
      }
      function Ea(e, t, n) {
        const r = e.field.isKeyField()
          ? Ni.comparator(t.key, n.key)
          : (function (e, t, n) {
              const r = t.data.field(e),
                i = n.data.field(e);
              return null !== r && null !== i ? cs(r, i) : oi();
            })(e.field, t, n);
        switch (e.dir) {
          case 'asc':
            return r;
          case 'desc':
            return -1 * r;
          default:
            return oi();
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Sa {
        constructor(e, t) {
          (this.mapKeyFn = e), (this.equalsFn = t), (this.inner = {}), (this.innerSize = 0);
        }
        get(e) {
          const t = this.mapKeyFn(e),
            n = this.inner[t];
          if (void 0 !== n) for (const [r, i] of n) if (this.equalsFn(r, e)) return i;
        }
        has(e) {
          return void 0 !== this.get(e);
        }
        set(e, t) {
          const n = this.mapKeyFn(e),
            r = this.inner[n];
          if (void 0 === r) return (this.inner[n] = [[e, t]]), void this.innerSize++;
          for (let i = 0; i < r.length; i++) if (this.equalsFn(r[i][0], e)) return void (r[i] = [e, t]);
          r.push([e, t]), this.innerSize++;
        }
        delete(e) {
          const t = this.mapKeyFn(e),
            n = this.inner[t];
          if (void 0 === n) return !1;
          for (let r = 0; r < n.length; r++)
            if (this.equalsFn(n[r][0], e)) return 1 === n.length ? delete this.inner[t] : n.splice(r, 1), this.innerSize--, !0;
          return !1;
        }
        forEach(e) {
          Mo(this.inner, (t, n) => {
            for (const [r, i] of n) e(r, i);
          });
        }
        isEmpty() {
          return Fo(this.inner);
        }
        size() {
          return this.innerSize;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Ta = new Uo(Ni.comparator);
      function Aa() {
        return Ta;
      }
      const xa = new Uo(Ni.comparator);
      function Ca(...e) {
        let t = xa;
        for (const n of e) t = t.insert(n.key, n);
        return t;
      }
      function ka(e) {
        let t = xa;
        return e.forEach((e, n) => (t = t.insert(e, n.overlayedDocument))), t;
      }
      function Oa() {
        return Ra();
      }
      function Na() {
        return Ra();
      }
      function Ra() {
        return new Sa(
          e => e.toString(),
          (e, t) => e.isEqual(t)
        );
      }
      const Pa = new Uo(Ni.comparator),
        Da = new $o(Ni.comparator);
      function La(...e) {
        let t = Da;
        for (const n of e) t = t.add(n);
        return t;
      }
      const ja = new $o(Ii);
      function Ma() {
        return ja;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Fa(e, t) {
        if (e.useProto3Json) {
          if (isNaN(t)) return { doubleValue: 'NaN' };
          if (t === 1 / 0) return { doubleValue: 'Infinity' };
          if (t === -1 / 0) return { doubleValue: '-Infinity' };
        }
        return { doubleValue: io(t) ? '-0' : t };
      }
      function Ua(e) {
        return { integerValue: '' + e };
      }
      function Va(e, t) {
        return oo(t) ? Ua(t) : Fa(e, t);
      }
      /**
       * @license
       * Copyright 2018 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ba {
        constructor() {
          this._ = void 0;
        }
      }
      function $a(e, t, n) {
        return e instanceof Ga
          ? (function (e, t) {
              const n = {
                fields: {
                  __type__: { stringValue: 'server_timestamp' },
                  __local_write_time__: { timestampValue: { seconds: e.seconds, nanos: e.nanoseconds } }
                }
              };
              return t && Zo(t) && (t = es(t)), t && (n.fields.__previous_value__ = t), { mapValue: n };
            })(n, t)
          : e instanceof Wa
            ? Ha(e, t)
            : e instanceof Ka
              ? Qa(e, t)
              : (function (e, t) {
                  const n = za(e, t),
                    r = Xa(n) + Xa(e.gt);
                  return ps(n) && ps(e.gt) ? Ua(r) : Fa(e.serializer, r);
                })(e, t);
      }
      function qa(e, t, n) {
        return e instanceof Wa ? Ha(e, t) : e instanceof Ka ? Qa(e, t) : n;
      }
      function za(e, t) {
        return e instanceof Ya
          ? ps((n = t)) ||
            (function (e) {
              return !!e && 'doubleValue' in e;
            })(n)
            ? t
            : { integerValue: 0 }
          : null;
        var n;
      }
      class Ga extends Ba {}
      class Wa extends Ba {
        constructor(e) {
          super(), (this.elements = e);
        }
      }
      function Ha(e, t) {
        const n = Ja(t);
        for (const r of e.elements) n.some(e => as(e, r)) || n.push(r);
        return { arrayValue: { values: n } };
      }
      class Ka extends Ba {
        constructor(e) {
          super(), (this.elements = e);
        }
      }
      function Qa(e, t) {
        let n = Ja(t);
        for (const r of e.elements) n = n.filter(e => !as(e, r));
        return { arrayValue: { values: n } };
      }
      class Ya extends Ba {
        constructor(e, t) {
          super(), (this.serializer = e), (this.gt = t);
        }
      }
      function Xa(e) {
        return Xo(e.integerValue || e.doubleValue);
      }
      function Ja(e) {
        return gs(e) && e.arrayValue.values ? e.arrayValue.values.slice() : [];
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Za {
        constructor(e, t) {
          (this.field = e), (this.transform = t);
        }
      }
      function eu(e, t) {
        return (
          e.field.isEqual(t.field) &&
          (function (e, t) {
            return (e instanceof Wa && t instanceof Wa) || (e instanceof Ka && t instanceof Ka)
              ? Ei(e.elements, t.elements, as)
              : e instanceof Ya && t instanceof Ya
                ? as(e.gt, t.gt)
                : e instanceof Ga && t instanceof Ga;
          })(e.transform, t.transform)
        );
      }
      class tu {
        constructor(e, t) {
          (this.version = e), (this.transformResults = t);
        }
      }
      class nu {
        constructor(e, t) {
          (this.updateTime = e), (this.exists = t);
        }
        static none() {
          return new nu();
        }
        static exists(e) {
          return new nu(void 0, e);
        }
        static updateTime(e) {
          return new nu(e);
        }
        get isNone() {
          return void 0 === this.updateTime && void 0 === this.exists;
        }
        isEqual(e) {
          return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime);
        }
      }
      function ru(e, t) {
        return void 0 !== e.updateTime
          ? t.isFoundDocument() && t.version.isEqual(e.updateTime)
          : void 0 === e.exists || e.exists === t.isFoundDocument();
      }
      class iu {}
      function ou(e, t) {
        if (!e.hasLocalMutations || (t && 0 === t.fields.length)) return null;
        if (null === t) return e.isNoDocument() ? new gu(e.key, nu.none()) : new lu(e.key, e.data, nu.none());
        {
          const n = e.data,
            r = Ts.empty();
          let i = new $o(Oi.comparator);
          for (let e of t.fields)
            if (!i.has(e)) {
              let t = n.field(e);
              null === t && e.length > 1 && ((e = e.popLast()), (t = n.field(e))), null === t ? r.delete(e) : r.set(e, t), (i = i.add(e));
            }
          return new hu(e.key, r, new Go(i.toArray()), nu.none());
        }
      }
      function su(e, t, n) {
        e instanceof lu
          ? (function (e, t, n) {
              const r = e.value.clone(),
                i = du(e.fieldTransforms, t, n.transformResults);
              r.setAll(i), t.convertToFoundDocument(n.version, r).setHasCommittedMutations();
            })(e, t, n)
          : e instanceof hu
            ? (function (e, t, n) {
                if (!ru(e.precondition, t)) return void t.convertToUnknownDocument(n.version);
                const r = du(e.fieldTransforms, t, n.transformResults),
                  i = t.data;
                i.setAll(fu(e)), i.setAll(r), t.convertToFoundDocument(n.version, i).setHasCommittedMutations();
              })(e, t, n)
            : (function (e, t, n) {
                t.convertToNoDocument(n.version).setHasCommittedMutations();
              })(0, t, n);
      }
      function au(e, t, n, r) {
        return e instanceof lu
          ? (function (e, t, n, r) {
              if (!ru(e.precondition, t)) return n;
              const i = e.value.clone(),
                o = pu(e.fieldTransforms, r, t);
              return i.setAll(o), t.convertToFoundDocument(t.version, i).setHasLocalMutations(), null;
            })(e, t, n, r)
          : e instanceof hu
            ? (function (e, t, n, r) {
                if (!ru(e.precondition, t)) return n;
                const i = pu(e.fieldTransforms, r, t),
                  o = t.data;
                return (
                  o.setAll(fu(e)),
                  o.setAll(i),
                  t.convertToFoundDocument(t.version, o).setHasLocalMutations(),
                  null === n ? null : n.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map(e => e.field))
                );
              })(e, t, n, r)
            : (function (e, t, n) {
                return ru(e.precondition, t) ? (t.convertToNoDocument(t.version).setHasLocalMutations(), null) : n;
              })(e, t, n);
      }
      function uu(e, t) {
        let n = null;
