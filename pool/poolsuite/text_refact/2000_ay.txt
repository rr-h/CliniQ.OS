remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
          return (
            i.forEach(e => {
              r.has(e) || o.push(e);
            }),
            r.forEach(e => {
              i.has(e) || s.push(e);
            }),
            this.syncEngine.Wr(o, s).then(() => {
              this.gr = n;
            })
          );
        }
        Vr(e) {
          this.gr.get(e.clientId) && this.onlineStateHandler(e.onlineState);
        }
        Sr(e) {
          let t = Ma();
          return (
            e.forEach((e, n) => {
              t = t.unionWith(n.activeTargetIds);
            }),
            t
          );
        }
      }
      class $h {
        constructor() {
          (this.Hr = new Vh()), (this.Jr = {}), (this.onlineStateHandler = null), (this.sequenceNumberHandler = null);
        }
        addPendingMutation(e) {}
        updateMutationState(e, t, n) {}
        addLocalQueryTarget(e) {
          return this.Hr.lr(e), this.Jr[e] || 'not-current';
        }
        updateQueryState(e, t, n) {
          this.Jr[e] = t;
        }
        removeLocalQueryTarget(e) {
          this.Hr.dr(e);
        }
        isLocalQueryTarget(e) {
          return this.Hr.activeTargetIds.has(e);
        }
        clearQueryState(e) {
          delete this.Jr[e];
        }
        getAllActiveQueryTargets() {
          return this.Hr.activeTargetIds;
        }
        isActiveQueryTarget(e) {
          return this.Hr.activeTargetIds.has(e);
        }
        start() {
          return (this.Hr = new Vh()), Promise.resolve();
        }
        handleUserChange(e, t, n) {}
        setOnlineState(e) {}
        shutdown() {}
        writeSequenceNumber(e) {}
        notifyBundleLoaded(e) {}
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class qh {
        Yr(e) {}
        shutdown() {}
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class zh {
        constructor() {
          (this.Xr = () => this.Zr()), (this.eo = () => this.no()), (this.so = []), this.io();
        }
        Yr(e) {
          this.so.push(e);
        }
        shutdown() {
          window.removeEventListener('online', this.Xr), window.removeEventListener('offline', this.eo);
        }
        io() {
          window.addEventListener('online', this.Xr), window.addEventListener('offline', this.eo);
        }
        Zr() {
          ti('ConnectivityMonitor', 'Network connectivity changed: AVAILABLE');
          for (const e of this.so) e(0);
        }
        no() {
          ti('ConnectivityMonitor', 'Network connectivity changed: UNAVAILABLE');
          for (const e of this.so) e(1);
        }
        static D() {
          return 'undefined' != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
        }
      }
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ let Gh = null;
      function Wh() {
        return null === Gh ? (Gh = 268435456 + Math.round(2147483648 * Math.random())) : Gh++, '0x' + Gh.toString(16);
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      const Hh = { BatchGetDocuments: 'batchGet', Commit: 'commit', RunQuery: 'runQuery', RunAggregationQuery: 'runAggregationQuery' };
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Kh {
        constructor(e) {
          (this.ro = e.ro), (this.oo = e.oo);
        }
        uo(e) {
          this.co = e;
        }
        ao(e) {
          this.ho = e;
        }
        onMessage(e) {
          this.lo = e;
        }
        close() {
          this.oo();
        }
        send(e) {
          this.ro(e);
        }
        fo() {
          this.co();
        }
        wo(e) {
          this.ho(e);
        }
        _o(e) {
          this.lo(e);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Qh = 'WebChannelConnection';
      class Yh extends class {
        constructor(e) {
          (this.databaseInfo = e), (this.databaseId = e.databaseId);
          const t = e.ssl ? 'https' : 'http';
          (this.mo = t + '://' + e.host),
            (this.yo = 'projects/' + this.databaseId.projectId + '/databases/' + this.databaseId.database + '/documents');
        }
        get po() {
          return !1;
        }
        Io(e, t, n, r, i) {
          const o = Wh(),
            s = this.To(e, t);
          ti('RestConnection', `Sending RPC '${e}' ${o}:`, s, n);
          const a = {};
          return (
            this.Eo(a, r, i),
            this.Ao(e, s, a, n).then(
              t => (ti('RestConnection', `Received RPC '${e}' ${o}: `, t), t),
              t => {
                throw (ri('RestConnection', `RPC '${e}' ${o} failed with error: `, t, 'url: ', s, 'request:', n), t);
              }
            )
          );
        }
        vo(e, t, n, r, i, o) {
          return this.Io(e, t, n, r, i);
        }
        Eo(e, t, n) {
          (e['X-Goog-Api-Client'] = 'gl-js/ fire/' + Xr),
            (e['Content-Type'] = 'text/plain'),
            this.databaseInfo.appId && (e['X-Firebase-GMPID'] = this.databaseInfo.appId),
            t && t.headers.forEach((t, n) => (e[n] = t)),
            n && n.headers.forEach((t, n) => (e[n] = t));
        }
        To(e, t) {
          const n = Hh[e];
          return `${this.mo}/v1/${t}:${n}`;
        }
      } {
        constructor(e) {
          super(e),
            (this.forceLongPolling = e.forceLongPolling),
            (this.autoDetectLongPolling = e.autoDetectLongPolling),
            (this.useFetchStreams = e.useFetchStreams),
            (this.longPollingOptions = e.longPollingOptions);
        }
        Ao(e, t, n, r) {
          const i = Wh();
          return new Promise((o, s) => {
            const a = new Wr();
            a.setWithCredentials(!0),
              a.listenOnce(Br.COMPLETE, () => {
                try {
                  switch (a.getLastErrorCode()) {
                    case Vr.NO_ERROR:
                      const t = a.getResponseJson();
                      ti(Qh, `XHR for RPC '${e}' ${i} received:`, JSON.stringify(t)), o(t);
                      break;
                    case Vr.TIMEOUT:
                      ti(Qh, `RPC '${e}' ${i} timed out`), s(new li(ci.DEADLINE_EXCEEDED, 'Request time out'));
                      break;
                    case Vr.HTTP_ERROR:
                      const n = a.getStatus();
                      if ((ti(Qh, `RPC '${e}' ${i} failed with status:`, n, 'response text:', a.getResponseText()), n > 0)) {
                        let e = a.getResponseJson();
                        Array.isArray(e) && (e = e[0]);
                        const t = null == e ? void 0 : e.error;
                        if (t && t.status && t.message) {
                          const e = (function (e) {
                            const t = e.toLowerCase().replace(/_/g, '-');
                            return Object.values(ci).indexOf(t) >= 0 ? t : ci.UNKNOWN;
                          })(t.status);
                          s(new li(e, t.message));
                        } else s(new li(ci.UNKNOWN, 'Server responded with status ' + a.getStatus()));
                      } else s(new li(ci.UNAVAILABLE, 'Connection failed.'));
                      break;
                    default:
                      oi();
                  }
                } finally {
                  ti(Qh, `RPC '${e}' ${i} completed.`);
                }
              });
            const u = JSON.stringify(r);
            ti(Qh, `RPC '${e}' ${i} sending request:`, r), a.send(t, 'POST', u, n, 15);
          });
        }
        Ro(e, t, n) {
          const r = Wh(),
            i = [this.mo, '/', 'google.firestore.v1.Firestore', '/', e, '/channel'],
            o = Fr(),
            s = Ur(),
            a = {
              httpSessionIdParam: 'gsessionid',
              initMessageHeaders: {},
              messageUrlParams: { database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}` },
              sendRawJson: !0,
              supportsCrossDomainXhr: !0,
              internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 },
              forceLongPolling: this.forceLongPolling,
              detectBufferingProxy: this.autoDetectLongPolling
            },
            u = this.longPollingOptions.timeoutSeconds;
          void 0 !== u && (a.longPollingTimeout = Math.round(1e3 * u)),
            this.useFetchStreams && (a.xmlHttpFactory = new zr({})),
            this.Eo(a.initMessageHeaders, t, n),
            (a.encodeInitMessageHeaders = !0);
          const c = i.join('');
          ti(Qh, `Creating RPC '${e}' stream ${r}: ${c}`, a);
          const l = o.createWebChannel(c, a);
          let h = !1,
            f = !1;
          const d = new Kh({
              ro: t => {
                f
                  ? ti(Qh, `Not sending because RPC '${e}' stream ${r} is closed:`, t)
                  : (h || (ti(Qh, `Opening RPC '${e}' stream ${r} transport.`), l.open(), (h = !0)),
                    ti(Qh, `RPC '${e}' stream ${r} sending:`, t),
                    l.send(t));
              },
              oo: () => l.close()
            }),
            p = (e, t, n) => {
              e.listen(t, e => {
                try {
                  n(e);
                } catch (e) {
                  setTimeout(() => {
                    throw e;
                  }, 0);
                }
              });
            };
          return (
            p(l, Gr.EventType.OPEN, () => {
              f || ti(Qh, `RPC '${e}' stream ${r} transport opened.`);
            }),
            p(l, Gr.EventType.CLOSE, () => {
              f || ((f = !0), ti(Qh, `RPC '${e}' stream ${r} transport closed`), d.wo());
            }),
            p(l, Gr.EventType.ERROR, t => {
              f ||
                ((f = !0),
                ri(Qh, `RPC '${e}' stream ${r} transport errored:`, t),
                d.wo(new li(ci.UNAVAILABLE, 'The operation could not be completed')));
            }),
            p(l, Gr.EventType.MESSAGE, t => {
              var n;
              if (!f) {
                const i = t.data[0];
                si(!!i);
                const o = i,
                  s = o.error || (null === (n = o[0]) || void 0 === n ? void 0 : n.error);
                if (s) {
                  ti(Qh, `RPC '${e}' stream ${r} received error:`, s);
                  const t = s.status;
                  let n = (function (e) {
                      const t = _u[e];
                      if (void 0 !== t) return Su(t);
                    })(t),
                    i = s.message;
                  void 0 === n && ((n = ci.INTERNAL), (i = 'Unknown error status: ' + t + ' with message ' + s.message)),
                    (f = !0),
                    d.wo(new li(n, i)),
                    l.close();
                } else ti(Qh, `RPC '${e}' stream ${r} received:`, i), d._o(i);
              }
            }),
            p(s, $r.STAT_EVENT, t => {
              t.stat === qr.PROXY
                ? ti(Qh, `RPC '${e}' stream ${r} detected buffering proxy`)
                : t.stat === qr.NOPROXY && ti(Qh, `RPC '${e}' stream ${r} detected no buffering proxy`);
            }),
            setTimeout(() => {
              d.fo();
            }, 0),
            d
          );
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Xh() {
        return 'undefined' != typeof window ? window : null;
      }
      function Jh() {
        return 'undefined' != typeof document ? document : null;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Zh(e) {
        return new Gu(e, !0);
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ef {
        constructor(e, t, n = 1e3, r = 1.5, i = 6e4) {
          (this.ii = e),
            (this.timerId = t),
            (this.Po = n),
            (this.bo = r),
            (this.Vo = i),
            (this.So = 0),
            (this.Do = null),
            (this.Co = Date.now()),
            this.reset();
        }
        reset() {
          this.So = 0;
        }
        xo() {
          this.So = this.Vo;
        }
        No(e) {
          this.cancel();
          const t = Math.floor(this.So + this.ko()),
            n = Math.max(0, Date.now() - this.Co),
            r = Math.max(0, t - n);
          r > 0 &&
            ti('ExponentialBackoff', `Backing off for ${r} ms (base delay: ${this.So} ms, delay with jitter: ${t} ms, last attempt: ${n} ms ago)`),
            (this.Do = this.ii.enqueueAfterDelay(this.timerId, r, () => ((this.Co = Date.now()), e()))),
            (this.So *= this.bo),
            this.So < this.Po && (this.So = this.Po),
            this.So > this.Vo && (this.So = this.Vo);
        }
        Mo() {
          null !== this.Do && (this.Do.skipDelay(), (this.Do = null));
        }
        cancel() {
          null !== this.Do && (this.Do.cancel(), (this.Do = null));
        }
        ko() {
          return (Math.random() - 0.5) * this.So;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class tf {
        constructor(e, t, n, r, i, o, s, a) {
          (this.ii = e),
            (this.$o = n),
            (this.Oo = r),
            (this.connection = i),
            (this.authCredentialsProvider = o),
            (this.appCheckCredentialsProvider = s),
            (this.listener = a),
            (this.state = 0),
            (this.Fo = 0),
            (this.Bo = null),
            (this.Lo = null),
            (this.stream = null),
            (this.qo = new ef(e, t));
        }
        Uo() {
          return 1 === this.state || 5 === this.state || this.Ko();
        }
        Ko() {
          return 2 === this.state || 3 === this.state;
        }
        start() {
          4 !== this.state ? this.auth() : this.Go();
        }
        async stop() {
          this.Uo() && (await this.close(0));
        }
        Qo() {
          (this.state = 0), this.qo.reset();
        }
        jo() {
          this.Ko() && null === this.Bo && (this.Bo = this.ii.enqueueAfterDelay(this.$o, 6e4, () => this.zo()));
        }
        Wo(e) {
          this.Ho(), this.stream.send(e);
        }
        async zo() {
          if (this.Ko()) return this.close(0);
        }
        Ho() {
          this.Bo && (this.Bo.cancel(), (this.Bo = null));
        }
        Jo() {
          this.Lo && (this.Lo.cancel(), (this.Lo = null));
        }
        async close(e, t) {
          this.Ho(),
            this.Jo(),
            this.qo.cancel(),
            this.Fo++,
            4 !== e
              ? this.qo.reset()
              : t && t.code === ci.RESOURCE_EXHAUSTED
                ? (ni(t.toString()), ni('Using maximum backoff delay to prevent overloading the backend.'), this.qo.xo())
                : t &&
                  t.code === ci.UNAUTHENTICATED &&
                  3 !== this.state &&
                  (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()),
            null !== this.stream && (this.Yo(), this.stream.close(), (this.stream = null)),
            (this.state = e),
            await this.listener.ao(t);
        }
        Yo() {}
        auth() {
          this.state = 1;
          const e = this.Xo(this.Fo),
            t = this.Fo;
          Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(
            ([e, n]) => {
              this.Fo === t && this.Zo(e, n);
            },
            t => {
              e(() => {
                const e = new li(ci.UNKNOWN, 'Fetching auth token failed: ' + t.message);
                return this.tu(e);
              });
            }
          );
        }
        Zo(e, t) {
          const n = this.Xo(this.Fo);
          (this.stream = this.eu(e, t)),
            this.stream.uo(() => {
              n(
                () => (
                  (this.state = 2),
                  (this.Lo = this.ii.enqueueAfterDelay(this.Oo, 1e4, () => (this.Ko() && (this.state = 3), Promise.resolve()))),
                  this.listener.uo()
                )
              );
            }),
            this.stream.ao(e => {
              n(() => this.tu(e));
            }),
            this.stream.onMessage(e => {
              n(() => this.onMessage(e));
            });
        }
        Go() {
          (this.state = 5),
            this.qo.No(async () => {
              (this.state = 0), this.start();
            });
        }
        tu(e) {
          return ti('PersistentStream', `close with error: ${e}`), (this.stream = null), this.close(4, e);
        }
        Xo(e) {
          return t => {
            this.ii.enqueueAndForget(() =>
              this.Fo === e ? t() : (ti('PersistentStream', 'stream callback skipped by getCloseGuardedDispatcher.'), Promise.resolve())
            );
          };
        }
      }
      class nf extends tf {
        constructor(e, t, n, r, i, o) {
          super(e, 'listen_stream_connection_backoff', 'listen_stream_idle', 'health_check_timeout', t, n, r, o), (this.serializer = i);
        }
        eu(e, t) {
          return this.connection.Ro('Listen', e, t);
        }
        onMessage(e) {
          this.qo.reset();
          const t = uc(this.serializer, e),
            n = (function (e) {
              if (!('targetChange' in e)) return Ai.min();
              const t = e.targetChange;
              return t.targetIds && t.targetIds.length ? Ai.min() : t.readTime ? Yu(t.readTime) : Ai.min();
            })(e);
          return this.listener.nu(t, n);
        }
        su(e) {
          const t = {};
          (t.database = rc(this.serializer)),
            (t.addTarget = (function (e, t) {
              let n;
              const r = t.target;
              if (((n = na(r) ? { documents: fc(e, r) } : { query: dc(e, r) }), (n.targetId = t.targetId), t.resumeToken.approximateByteSize() > 0)) {
                n.resumeToken = Ku(e, t.resumeToken);
                const r = Wu(e, t.expectedCount);
                null !== r && (n.expectedCount = r);
              } else if (t.snapshotVersion.compareTo(Ai.min()) > 0) {
                n.readTime = Hu(e, t.snapshotVersion.toTimestamp());
                const r = Wu(e, t.expectedCount);
                null !== r && (n.expectedCount = r);
              }
              return n;
            })(this.serializer, e));
          const n = gc(this.serializer, e);
          n && (t.labels = n), this.Wo(t);
        }
        iu(e) {
          const t = {};
          (t.database = rc(this.serializer)), (t.removeTarget = e), this.Wo(t);
        }
      }
      class rf extends tf {
        constructor(e, t, n, r, i, o) {
          super(e, 'write_stream_connection_backoff', 'write_stream_idle', 'health_check_timeout', t, n, r, o), (this.serializer = i), (this.ru = !1);
        }
        get ou() {
          return this.ru;
        }
        start() {
          (this.ru = !1), (this.lastStreamToken = void 0), super.start();
        }
        Yo() {
          this.ru && this.uu([]);
        }
        eu(e, t) {
          return this.connection.Ro('Write', e, t);
        }
        onMessage(e) {
          if ((si(!!e.streamToken), (this.lastStreamToken = e.streamToken), this.ru)) {
            this.qo.reset();
            const t = hc(e.writeResults, e.commitTime),
              n = Yu(e.commitTime);
            return this.listener.cu(n, t);
          }
          return si(!e.writeResults || 0 === e.writeResults.length), (this.ru = !0), this.listener.au();
        }
        hu() {
          const e = {};
          (e.database = rc(this.serializer)), this.Wo(e);
        }
        uu(e) {
          const t = { streamToken: this.lastStreamToken, writes: e.map(e => cc(this.serializer, e)) };
          this.Wo(t);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class of extends class {} {
        constructor(e, t, n, r) {
          super(), (this.authCredentials = e), (this.appCheckCredentials = t), (this.connection = n), (this.serializer = r), (this.lu = !1);
        }
        fu() {
          if (this.lu) throw new li(ci.FAILED_PRECONDITION, 'The client has already been terminated.');
        }
        Io(e, t, n) {
          return (
            this.fu(),
            Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
              .then(([r, i]) => this.connection.Io(e, t, n, r, i))
              .catch(e => {
                throw 'FirebaseError' === e.name
                  ? (e.code === ci.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e)
                  : new li(ci.UNKNOWN, e.toString());
              })
          );
        }
        vo(e, t, n, r) {
          return (
            this.fu(),
            Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
              .then(([i, o]) => this.connection.vo(e, t, n, i, o, r))
              .catch(e => {
                throw 'FirebaseError' === e.name
                  ? (e.code === ci.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e)
                  : new li(ci.UNKNOWN, e.toString());
              })
          );
        }
        terminate() {
          this.lu = !0;
        }
      }
      class sf {
        constructor(e, t) {
          (this.asyncQueue = e), (this.onlineStateHandler = t), (this.state = 'Unknown'), (this.wu = 0), (this._u = null), (this.mu = !0);
        }
        gu() {
          0 === this.wu &&
            (this.yu('Unknown'),
            (this._u = this.asyncQueue.enqueueAfterDelay(
              'online_state_timeout',
              1e4,
              () => ((this._u = null), this.pu("Backend didn't respond within 10 seconds."), this.yu('Offline'), Promise.resolve())
            )));
        }
        Iu(e) {
          'Online' === this.state
            ? this.yu('Unknown')
            : (this.wu++, this.wu >= 1 && (this.Tu(), this.pu(`Connection failed 1 times. Most recent error: ${e.toString()}`), this.yu('Offline')));
        }
        set(e) {
          this.Tu(), (this.wu = 0), 'Online' === e && (this.mu = !1), this.yu(e);
        }
        yu(e) {
          e !== this.state && ((this.state = e), this.onlineStateHandler(e));
        }
        pu(e) {
          const t = `Could not reach Cloud Firestore backend. ${e}\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
          this.mu ? (ni(t), (this.mu = !1)) : ti('OnlineStateTracker', t);
        }
        Tu() {
          null !== this._u && (this._u.cancel(), (this._u = null));
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class af {
        constructor(e, t, n, r, i) {
          (this.localStore = e),
            (this.datastore = t),
            (this.asyncQueue = n),
            (this.remoteSyncer = {}),
            (this.Eu = []),
            (this.Au = new Map()),
            (this.vu = new Set()),
            (this.Ru = []),
            (this.Pu = i),
            this.Pu.Yr(e => {
              n.enqueueAndForget(async () => {
                mf(this) &&
                  (ti('RemoteStore', 'Restarting streams for network reachability change.'),
                  await (async function (e) {
                    const t = ui(e);
                    t.vu.add(4), await cf(t), t.bu.set('Unknown'), t.vu.delete(4), await uf(t);
                  })(this));
              });
            }),
            (this.bu = new sf(n, r));
        }
      }
      async function uf(e) {
        if (mf(e)) for (const t of e.Ru) await t(!0);
      }
      async function cf(e) {
        for (const t of e.Ru) await t(!1);
      }
      function lf(e, t) {
        const n = ui(e);
        n.Au.has(t.targetId) || (n.Au.set(t.targetId, t), gf(n) ? pf(n) : Df(n).Ko() && ff(n, t));
      }
      function hf(e, t) {
        const n = ui(e),
          r = Df(n);
        n.Au.delete(t), r.Ko() && df(n, t), 0 === n.Au.size && (r.Ko() ? r.jo() : mf(n) && n.bu.set('Unknown'));
      }
      function ff(e, t) {
        if ((e.Vu.qt(t.targetId), t.resumeToken.approximateByteSize() > 0 || t.snapshotVersion.compareTo(Ai.min()) > 0)) {
          const n = e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;
          t = t.withExpectedCount(n);
        }
        Df(e).su(t);
      }
      function df(e, t) {
        e.Vu.qt(t), Df(e).iu(t);
      }
      function pf(e) {
        (e.Vu = new Uu({
          getRemoteKeysForTarget: t => e.remoteSyncer.getRemoteKeysForTarget(t),
          le: t => e.Au.get(t) || null,
          ue: () => e.datastore.serializer.databaseId
        })),
          Df(e).start(),
          e.bu.gu();
      }
      function gf(e) {
        return mf(e) && !Df(e).Uo() && e.Au.size > 0;
      }
      function mf(e) {
        return 0 === ui(e).vu.size;
      }
      function vf(e) {
        e.Vu = void 0;
      }
      async function yf(e) {
        e.Au.forEach((t, n) => {
          ff(e, t);
        });
      }
      async function wf(e, t) {
        vf(e), gf(e) ? (e.bu.Iu(t), pf(e)) : e.bu.set('Unknown');
      }
      async function bf(e, t, n) {
        if ((e.bu.set('Online'), t instanceof Mu && 2 === t.state && t.cause))
          try {
            await (async function (e, t) {
              const n = t.cause;
              for (const r of t.targetIds) e.Au.has(r) && (await e.remoteSyncer.rejectListen(r, n), e.Au.delete(r), e.Vu.removeTarget(r));
            })(e, t);
          } catch (n) {
            ti('RemoteStore', 'Failed to remove targets %s: %s ', t.targetIds.join(','), n), await _f(e, n);
          }
        else if ((t instanceof Lu ? e.Vu.Ht(t) : t instanceof ju ? e.Vu.ne(t) : e.Vu.Xt(t), !n.isEqual(Ai.min())))
          try {
            const t = await _h(e.localStore);
            n.compareTo(t) >= 0 &&
              (await (function (e, t) {
                const n = e.Vu.ce(t);
                return (
                  n.targetChanges.forEach((n, r) => {
                    if (n.resumeToken.approximateByteSize() > 0) {
                      const i = e.Au.get(r);
                      i && e.Au.set(r, i.withResumeToken(n.resumeToken, t));
                    }
                  }),
                  n.targetMismatches.forEach((t, n) => {
                    const r = e.Au.get(t);
                    if (!r) return;
                    e.Au.set(t, r.withResumeToken(Ko.EMPTY_BYTE_STRING, r.snapshotVersion)), df(e, t);
                    const i = new Tc(r.target, t, n, r.sequenceNumber);
                    ff(e, i);
                  }),
                  e.remoteSyncer.applyRemoteEvent(n)
                );
              })(e, n));
          } catch (t) {
            ti('RemoteStore', 'Failed to raise snapshot:', t), await _f(e, t);
          }
      }
      async function _f(e, t, n) {
        if (!Qi(t)) throw t;
        e.vu.add(1),
          await cf(e),
          e.bu.set('Offline'),
          n || (n = () => _h(e.localStore)),
          e.asyncQueue.enqueueRetryable(async () => {
            ti('RemoteStore', 'Retrying IndexedDB access'), await n(), e.vu.delete(1), await uf(e);
          });
      }
      function If(e, t) {
        return t().catch(n => _f(e, n, t));
      }
      async function Ef(e) {
        const t = ui(e),
          n = Lf(t);
        let r = t.Eu.length > 0 ? t.Eu[t.Eu.length - 1].batchId : -1;
        for (; Sf(t); )
          try {
            const e = await Sh(t.localStore, r);
            if (null === e) {
              0 === t.Eu.length && n.jo();
              break;
            }
            (r = e.batchId), Tf(t, e);
          } catch (e) {
            await _f(t, e);
          }
        Af(t) && xf(t);
      }
      function Sf(e) {
        return mf(e) && e.Eu.length < 10;
      }
      function Tf(e, t) {
        e.Eu.push(t);
        const n = Lf(e);
        n.Ko() && n.ou && n.uu(t.mutations);
      }
      function Af(e) {
        return mf(e) && !Lf(e).Uo() && e.Eu.length > 0;
      }
      function xf(e) {
        Lf(e).start();
      }
      async function Cf(e) {
        Lf(e).hu();
      }
      async function kf(e) {
        const t = Lf(e);
        for (const n of e.Eu) t.uu(n.mutations);
      }
      async function Of(e, t, n) {
        const r = e.Eu.shift(),
          i = yu.from(r, t, n);
        await If(e, () => e.remoteSyncer.applySuccessfulWrite(i)), await Ef(e);
      }
      async function Nf(e, t) {
        t &&
          Lf(e).ou &&
          (await (async function (e, t) {
            if (((n = t.code), Eu(n) && n !== ci.ABORTED)) {
              const n = e.Eu.shift();
              Lf(e).Qo(), await If(e, () => e.remoteSyncer.rejectFailedWrite(n.batchId, t)), await Ef(e);
            }
            var n;
          })(e, t)),
          Af(e) && xf(e);
      }
      async function Rf(e, t) {
        const n = ui(e);
        n.asyncQueue.verifyOperationInProgress(), ti('RemoteStore', 'RemoteStore received new credentials');
        const r = mf(n);
        n.vu.add(3), await cf(n), r && n.bu.set('Unknown'), await n.remoteSyncer.handleCredentialChange(t), n.vu.delete(3), await uf(n);
      }
      async function Pf(e, t) {
        const n = ui(e);
        t ? (n.vu.delete(2), await uf(n)) : t || (n.vu.add(2), await cf(n), n.bu.set('Unknown'));
      }
      function Df(e) {
        return (
          e.Su ||
            ((e.Su = (function (e, t, n) {
              const r = ui(e);
              return r.fu(), new nf(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n);
              /**
               * @license
               * Copyright 2018 Google LLC
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *   http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */
            })(e.datastore, e.asyncQueue, { uo: yf.bind(null, e), ao: wf.bind(null, e), nu: bf.bind(null, e) })),
            e.Ru.push(async t => {
              t ? (e.Su.Qo(), gf(e) ? pf(e) : e.bu.set('Unknown')) : (await e.Su.stop(), vf(e));
            })),
          e.Su
        );
      }
      function Lf(e) {
        return (
          e.Du ||
            ((e.Du = (function (e, t, n) {
              const r = ui(e);
              return r.fu(), new rf(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n);
            })(e.datastore, e.asyncQueue, { uo: Cf.bind(null, e), ao: Nf.bind(null, e), au: kf.bind(null, e), cu: Of.bind(null, e) })),
            e.Ru.push(async t => {
              t
                ? (e.Du.Qo(), await Ef(e))
                : (await e.Du.stop(),
                  e.Eu.length > 0 && (ti('RemoteStore', `Stopping write stream with ${e.Eu.length} pending writes`), (e.Eu = [])));
            })),
          e.Du
        );
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class jf {
        constructor(e, t, n, r, i) {
          (this.asyncQueue = e),
            (this.timerId = t),
            (this.targetTimeMs = n),
            (this.op = r),
            (this.removalCallback = i),
            (this.deferred = new hi()),
            (this.then = this.deferred.promise.then.bind(this.deferred.promise)),
            this.deferred.promise.catch(e => {});
        }
        static createAndSchedule(e, t, n, r, i) {
          const o = Date.now() + n,
            s = new jf(e, t, o, r, i);
          return s.start(n), s;
        }
        start(e) {
          this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e);
        }
        skipDelay() {
          return this.handleDelayElapsed();
        }
        cancel(e) {
          null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new li(ci.CANCELLED, 'Operation cancelled' + (e ? ': ' + e : ''))));
        }
        handleDelayElapsed() {
          this.asyncQueue.enqueueAndForget(() =>
            null !== this.timerHandle ? (this.clearTimeout(), this.op().then(e => this.deferred.resolve(e))) : Promise.resolve()
          );
        }
        clearTimeout() {
          null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), (this.timerHandle = null));
        }
      }
      function Mf(e, t) {
        if ((ni('AsyncQueue', `${t}: ${e}`), Qi(e))) return new li(ci.UNAVAILABLE, `${t}: ${e}`);
        throw e;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ff {
        constructor(e) {
          (this.comparator = e ? (t, n) => e(t, n) || Ni.comparator(t.key, n.key) : (e, t) => Ni.comparator(e.key, t.key)),
            (this.keyedMap = Ca()),
            (this.sortedSet = new Uo(this.comparator));
        }
        static emptySet(e) {
          return new Ff(e.comparator);
        }
        has(e) {
          return null != this.keyedMap.get(e);
        }
        get(e) {
          return this.keyedMap.get(e);
        }
        first() {
          return this.sortedSet.minKey();
        }
        last() {
          return this.sortedSet.maxKey();
        }
        isEmpty() {
          return this.sortedSet.isEmpty();
        }
        indexOf(e) {
          const t = this.keyedMap.get(e);
          return t ? this.sortedSet.indexOf(t) : -1;
        }
        get size() {
          return this.sortedSet.size;
        }
        forEach(e) {
          this.sortedSet.inorderTraversal((t, n) => (e(t), !1));
        }
        add(e) {
          const t = this.delete(e.key);
          return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null));
        }
        delete(e) {
          const t = this.get(e);
          return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this;
        }
        isEqual(e) {
          if (!(e instanceof Ff)) return !1;
          if (this.size !== e.size) return !1;
          const t = this.sortedSet.getIterator(),
            n = e.sortedSet.getIterator();
          for (; t.hasNext(); ) {
            const e = t.getNext().key,
              r = n.getNext().key;
            if (!e.isEqual(r)) return !1;
          }
          return !0;
        }
        toString() {
          const e = [];
          return (
            this.forEach(t => {
              e.push(t.toString());
            }),
            0 === e.length ? 'DocumentSet ()' : 'DocumentSet (\n  ' + e.join('  \n') + '\n)'
          );
        }
        copy(e, t) {
          const n = new Ff();
          return (n.comparator = this.comparator), (n.keyedMap = e), (n.sortedSet = t), n;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Uf {
        constructor() {
          this.Cu = new Uo(Ni.comparator);
        }
        track(e) {
          const t = e.doc.key,
            n = this.Cu.get(t);
          n
            ? 0 !== e.type && 3 === n.type
              ? (this.Cu = this.Cu.insert(t, e))
              : 3 === e.type && 1 !== n.type
                ? (this.Cu = this.Cu.insert(t, { type: n.type, doc: e.doc }))
                : 2 === e.type && 2 === n.type
                  ? (this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }))
                  : 2 === e.type && 0 === n.type
                    ? (this.Cu = this.Cu.insert(t, { type: 0, doc: e.doc }))
                    : 1 === e.type && 0 === n.type
                      ? (this.Cu = this.Cu.remove(t))
                      : 1 === e.type && 2 === n.type
                        ? (this.Cu = this.Cu.insert(t, { type: 1, doc: n.doc }))
                        : 0 === e.type && 1 === n.type
                          ? (this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }))
                          : oi()
            : (this.Cu = this.Cu.insert(t, e));
        }
        xu() {
          const e = [];
          return (
            this.Cu.inorderTraversal((t, n) => {
              e.push(n);
            }),
            e
          );
        }
      }
      class Vf {
        constructor(e, t, n, r, i, o, s, a, u) {
          (this.query = e),
            (this.docs = t),
            (this.oldDocs = n),
            (this.docChanges = r),
            (this.mutatedKeys = i),
            (this.fromCache = o),
            (this.syncStateChanged = s),
            (this.excludesMetadataChanges = a),
            (this.hasCachedResults = u);
        }
        static fromInitialDocuments(e, t, n, r, i) {
          const o = [];
          return (
            t.forEach(e => {
              o.push({ type: 0, doc: e });
            }),
            new Vf(e, t, Ff.emptySet(t), o, n, r, !0, !1, i)
          );
        }
        get hasPendingWrites() {
          return !this.mutatedKeys.isEmpty();
        }
        isEqual(e) {
          if (
            !(
              this.fromCache === e.fromCache &&
              this.hasCachedResults === e.hasCachedResults &&
              this.syncStateChanged === e.syncStateChanged &&
              this.mutatedKeys.isEqual(e.mutatedKeys) &&
              va(this.query, e.query) &&
              this.docs.isEqual(e.docs) &&
              this.oldDocs.isEqual(e.oldDocs)
            )
          )
            return !1;
          const t = this.docChanges,
            n = e.docChanges;
          if (t.length !== n.length) return !1;
          for (let r = 0; r < t.length; r++) if (t[r].type !== n[r].type || !t[r].doc.isEqual(n[r].doc)) return !1;
          return !0;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Bf {
        constructor() {
          (this.Nu = void 0), (this.listeners = []);
        }
      }
      class $f {
        constructor() {
          (this.queries = new Sa(e => ya(e), va)), (this.onlineState = 'Unknown'), (this.ku = new Set());
        }
      }
      async function qf(e, t) {
        const n = ui(e),
          r = t.query;
        let i = !1,
          o = n.queries.get(r);
        if ((o || ((i = !0), (o = new Bf())), i))
          try {
            o.Nu = await n.onListen(r);
          } catch (e) {
            const n = Mf(e, `Initialization of query '${wa(t.query)}' failed`);
            return void t.onError(n);
          }
        n.queries.set(r, o), o.listeners.push(t), t.Mu(n.onlineState), o.Nu && t.$u(o.Nu) && Hf(n);
      }
      async function zf(e, t) {
        const n = ui(e),
          r = t.query;
        let i = !1;
        const o = n.queries.get(r);
        if (o) {
          const e = o.listeners.indexOf(t);
          e >= 0 && (o.listeners.splice(e, 1), (i = 0 === o.listeners.length));
        }
        if (i) return n.queries.delete(r), n.onUnlisten(r);
      }
      function Gf(e, t) {
        const n = ui(e);
        let r = !1;
        for (const i of t) {
          const e = i.query,
            t = n.queries.get(e);
          if (t) {
            for (const e of t.listeners) e.$u(i) && (r = !0);
            t.Nu = i;
          }
        }
        r && Hf(n);
      }
      function Wf(e, t, n) {
        const r = ui(e),
          i = r.queries.get(t);
        if (i) for (const o of i.listeners) o.onError(n);
        r.queries.delete(t);
      }
      function Hf(e) {
        e.ku.forEach(e => {
          e.next();
        });
      }
      class Kf {
        constructor(e, t, n) {
          (this.query = e), (this.Ou = t), (this.Fu = !1), (this.Bu = null), (this.onlineState = 'Unknown'), (this.options = n || {});
        }
        $u(e) {
          if (!this.options.includeMetadataChanges) {
            const t = [];
            for (const n of e.docChanges) 3 !== n.type && t.push(n);
            e = new Vf(e.query, e.docs, e.oldDocs, t, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults);
          }
          let t = !1;
          return this.Fu ? this.Lu(e) && (this.Ou.next(e), (t = !0)) : this.qu(e, this.onlineState) && (this.Uu(e), (t = !0)), (this.Bu = e), t;
        }
        onError(e) {
          this.Ou.error(e);
        }
        Mu(e) {
          this.onlineState = e;
          let t = !1;
          return this.Bu && !this.Fu && this.qu(this.Bu, e) && (this.Uu(this.Bu), (t = !0)), t;
        }
        qu(e, t) {
          if (!e.fromCache) return !0;
          const n = 'Offline' !== t;
          return (!this.options.Ku || !n) && (!e.docs.isEmpty() || e.hasCachedResults || 'Offline' === t);
        }
        Lu(e) {
          if (e.docChanges.length > 0) return !0;
          const t = this.Bu && this.Bu.hasPendingWrites !== e.hasPendingWrites;
          return !(!e.syncStateChanged && !t) && !0 === this.options.includeMetadataChanges;
        }
        Uu(e) {
          (e = Vf.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults)), (this.Fu = !0), this.Ou.next(e);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Qf {
        constructor(e, t) {
          (this.Gu = e), (this.byteLength = t);
        }
        Qu() {
          return 'metadata' in this.Gu;
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Yf {
        constructor(e) {
          this.serializer = e;
        }
        rr(e) {
          return ec(this.serializer, e);
        }
        ur(e) {
          return e.metadata.exists ? sc(this.serializer, e.document, !1) : xs.newNoDocument(this.rr(e.metadata.name), this.cr(e.metadata.readTime));
        }
        cr(e) {
          return Yu(e);
        }
      }
      class Xf {
        constructor(e, t, n) {
          (this.ju = e),
            (this.localStore = t),
            (this.serializer = n),
            (this.queries = []),
            (this.documents = []),
            (this.collectionGroups = new Set()),
            (this.progress = Jf(e));
        }
        zu(e) {
          this.progress.bytesLoaded += e.byteLength;
          let t = this.progress.documentsLoaded;
          if (e.Gu.namedQuery) this.queries.push(e.Gu.namedQuery);
          else if (e.Gu.documentMetadata) {
            this.documents.push({ metadata: e.Gu.documentMetadata }), e.Gu.documentMetadata.exists || ++t;
            const n = Ci.fromString(e.Gu.documentMetadata.name);
            this.collectionGroups.add(n.get(n.length - 2));
          } else e.Gu.document && ((this.documents[this.documents.length - 1].document = e.Gu.document), ++t);
          return t !== this.progress.documentsLoaded ? ((this.progress.documentsLoaded = t), Object.assign({}, this.progress)) : null;
        }
        Wu(e) {
          const t = new Map(),
            n = new Yf(this.serializer);
          for (const r of e)
            if (r.metadata.queries) {
              const e = n.rr(r.metadata.name);
              for (const n of r.metadata.queries) {
                const r = (t.get(n) || La()).add(e);
                t.set(n, r);
              }
            }
          return t;
        }
        async complete() {
          const e = await Nh(this.localStore, new Yf(this.serializer), this.documents, this.ju.id),
            t = this.Wu(this.documents);
          for (const n of this.queries) await Rh(this.localStore, n, t.get(n.name));
          return (this.progress.taskState = 'Success'), { progress: this.progress, Hu: this.collectionGroups, Ju: e };
        }
      }
      function Jf(e) {
        return { taskState: 'Running', documentsLoaded: 0, bytesLoaded: 0, totalDocuments: e.totalDocuments, totalBytes: e.totalBytes };
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Zf {
        constructor(e) {
          this.key = e;
        }
      }
      class ed {
        constructor(e) {
          this.key = e;
        }
      }
      class td {
        constructor(e, t) {
          (this.query = e),
            (this.Yu = t),
            (this.Xu = null),
            (this.hasCachedResults = !1),
            (this.current = !1),
            (this.Zu = La()),
            (this.mutatedKeys = La()),
            (this.tc = Ia(e)),
            (this.ec = new Ff(this.tc));
        }
        get nc() {
          return this.Yu;
        }
        sc(e, t) {
          const n = t ? t.ic : new Uf(),
            r = t ? t.ec : this.ec;
          let i = t ? t.mutatedKeys : this.mutatedKeys,
            o = r,
            s = !1;
          const a = 'F' === this.query.limitType && r.size === this.query.limit ? r.last() : null,
            u = 'L' === this.query.limitType && r.size === this.query.limit ? r.first() : null;
          if (
            (e.inorderTraversal((e, t) => {
              const c = r.get(e),
                l = ba(this.query, t) ? t : null,
                h = !!c && this.mutatedKeys.has(c.key),
                f = !!l && (l.hasLocalMutations || (this.mutatedKeys.has(l.key) && l.hasCommittedMutations));
              let d = !1;
              c && l
                ? c.data.isEqual(l.data)
                  ? h !== f && (n.track({ type: 3, doc: l }), (d = !0))
                  : this.rc(c, l) || (n.track({ type: 2, doc: l }), (d = !0), ((a && this.tc(l, a) > 0) || (u && this.tc(l, u) < 0)) && (s = !0))
                : !c && l
                  ? (n.track({ type: 0, doc: l }), (d = !0))
                  : c && !l && (n.track({ type: 1, doc: c }), (d = !0), (a || u) && (s = !0)),
                d && (l ? ((o = o.add(l)), (i = f ? i.add(e) : i.delete(e))) : ((o = o.delete(e)), (i = i.delete(e))));
            }),
            null !== this.query.limit)
          )
            for (; o.size > this.query.limit; ) {
              const e = 'F' === this.query.limitType ? o.last() : o.first();
              (o = o.delete(e.key)), (i = i.delete(e.key)), n.track({ type: 1, doc: e });
            }
          return { ec: o, ic: n, zi: s, mutatedKeys: i };
        }
        rc(e, t) {
          return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations;
        }
        applyChanges(e, t, n) {
          const r = this.ec;
          (this.ec = e.ec), (this.mutatedKeys = e.mutatedKeys);
          const i = e.ic.xu();
          i.sort(
            (e, t) =>
              (function (e, t) {
                const n = e => {
                  switch (e) {
                    case 0:
                      return 1;
                    case 2:
                    case 3:
                      return 2;
                    case 1:
                      return 0;
                    default:
                      return oi();
                  }
                };
                return n(e) - n(t);
              })(
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */ e.type,
                t.type
              ) || this.tc(e.doc, t.doc)
          ),
            this.oc(n);
          const o = t ? this.uc() : [],
            s = 0 === this.Zu.size && this.current ? 1 : 0,
            a = s !== this.Xu;
          return (
            (this.Xu = s),
            0 !== i.length || a
              ? { snapshot: new Vf(this.query, e.ec, r, i, e.mutatedKeys, 0 === s, a, !1, !!n && n.resumeToken.approximateByteSize() > 0), cc: o }
              : { cc: o }
          );
        }
        Mu(e) {
          return this.current && 'Offline' === e
            ? ((this.current = !1), this.applyChanges({ ec: this.ec, ic: new Uf(), mutatedKeys: this.mutatedKeys, zi: !1 }, !1))
            : { cc: [] };
        }
        ac(e) {
          return !this.Yu.has(e) && !!this.ec.has(e) && !this.ec.get(e).hasLocalMutations;
        }
        oc(e) {
          e &&
            (e.addedDocuments.forEach(e => (this.Yu = this.Yu.add(e))),
            e.modifiedDocuments.forEach(e => {}),
            e.removedDocuments.forEach(e => (this.Yu = this.Yu.delete(e))),
            (this.current = e.current));
        }
        uc() {
          if (!this.current) return [];
          const e = this.Zu;
          (this.Zu = La()),
            this.ec.forEach(e => {
              this.ac(e.key) && (this.Zu = this.Zu.add(e.key));
            });
          const t = [];
          return (
            e.forEach(e => {
              this.Zu.has(e) || t.push(new ed(e));
            }),
            this.Zu.forEach(n => {
              e.has(n) || t.push(new Zf(n));
            }),
            t
          );
        }
        hc(e) {
          (this.Yu = e.ir), (this.Zu = La());
          const t = this.sc(e.documents);
          return this.applyChanges(t, !0);
        }
        lc() {
          return Vf.fromInitialDocuments(this.query, this.ec, this.mutatedKeys, 0 === this.Xu, this.hasCachedResults);
        }
      }
      class nd {
        constructor(e, t, n) {
          (this.query = e), (this.targetId = t), (this.view = n);
        }
      }
      class rd {
        constructor(e) {
          (this.key = e), (this.fc = !1);
        }
      }
      class id {
        constructor(e, t, n, r, i, o) {
          (this.localStore = e),
            (this.remoteStore = t),
            (this.eventManager = n),
            (this.sharedClientState = r),
            (this.currentUser = i),
            (this.maxConcurrentLimboResolutions = o),
            (this.dc = {}),
            (this.wc = new Sa(e => ya(e), va)),
            (this._c = new Map()),
            (this.mc = new Set()),
            (this.gc = new Uo(Ni.comparator)),
            (this.yc = new Map()),
            (this.Ic = new Zl()),
            (this.Tc = {}),
            (this.Ec = new Map()),
            (this.Ac = Cl.Mn()),
            (this.onlineState = 'Unknown'),
            (this.vc = void 0);
        }
        get isPrimaryClient() {
          return !0 === this.vc;
        }
      }
      async function od(e, t) {
        const n = Dd(e);
        let r, i;
        const o = n.wc.get(t);
        if (o) (r = o.targetId), n.sharedClientState.addLocalQueryTarget(r), (i = o.view.lc());
        else {
          const e = await Th(n.localStore, pa(t)),
            o = n.sharedClientState.addLocalQueryTarget(e.targetId);
          (r = e.targetId), (i = await sd(n, t, r, 'current' === o, e.resumeToken)), n.isPrimaryClient && lf(n.remoteStore, e);
        }
        return i;
      }
      async function sd(e, t, n, r, i) {
        e.Rc = (t, n, r) =>
          (async function (e, t, n, r) {
            let i = t.view.sc(n);
            i.zi && (i = await xh(e.localStore, t.query, !1).then(({ documents: e }) => t.view.sc(e, i)));
            const o = r && r.targetChanges.get(t.targetId),
              s = t.view.applyChanges(i, e.isPrimaryClient, o);
            return wd(e, t.targetId, s.cc), s.snapshot;
          })(e, t, n, r);
        const o = await xh(e.localStore, t, !0),
          s = new td(t, o.ir),
          a = s.sc(o.documents),
          u = Du.createSynthesizedTargetChangeForCurrentChange(n, r && 'Offline' !== e.onlineState, i),
          c = s.applyChanges(a, e.isPrimaryClient, u);
        wd(e, n, c.cc);
        const l = new nd(t, n, s);
        return e.wc.set(t, l), e._c.has(n) ? e._c.get(n).push(t) : e._c.set(n, [t]), c.snapshot;
      }
      async function ad(e, t) {
        const n = ui(e),
          r = n.wc.get(t),
          i = n._c.get(r.targetId);
        if (i.length > 1)
          return (
            n._c.set(
              r.targetId,
              i.filter(e => !va(e, t))
            ),
            void n.wc.delete(t)
          );
        n.isPrimaryClient
          ? (n.sharedClientState.removeLocalQueryTarget(r.targetId),
            n.sharedClientState.isActiveQueryTarget(r.targetId) ||
              (await Ah(n.localStore, r.targetId, !1)
                .then(() => {
                  n.sharedClientState.clearQueryState(r.targetId), hf(n.remoteStore, r.targetId), vd(n, r.targetId);
                })
                .catch(qi)))
          : (vd(n, r.targetId), await Ah(n.localStore, r.targetId, !0));
      }
      async function ud(e, t, n) {
        const r = Ld(e);
        try {
          const e = await (function (e, t) {
            const n = ui(e),
              r = Ti.now(),
              i = t.reduce((e, t) => e.add(t.key), La());
            let o, s;
            return n.persistence
              .runTransaction('Locally write mutations', 'readwrite', e => {
                let a = Aa(),
                  u = La();
                return n.Zi.getEntries(e, i)
                  .next(e => {
                    (a = e),
                      a.forEach((e, t) => {
                        t.isValidDocument() || (u = u.add(e));
                      });
                  })
                  .next(() => n.localDocuments.getOverlayedDocuments(e, a))
                  .next(i => {
                    o = i;
                    const s = [];
                    for (const e of t) {
                      const t = uu(e, o.get(e.key).overlayedDocument);
                      null != t && s.push(new hu(e.key, t, As(t.value.mapValue), nu.exists(!0)));
                    }
                    return n.mutationQueue.addMutationBatch(e, r, s, t);
                  })
                  .next(t => {
                    s = t;
                    const r = t.applyToLocalDocumentSet(o, u);
                    return n.documentOverlayCache.saveOverlays(e, t.batchId, r);
                  });
              })
              .then(() => ({ batchId: s.batchId, changes: ka(o) }));
          })(r.localStore, t);
          r.sharedClientState.addPendingMutation(e.batchId),
            (function (e, t, n) {
              let r = e.Tc[e.currentUser.toKey()];
              r || (r = new Uo(Ii)), (r = r.insert(t, n)), (e.Tc[e.currentUser.toKey()] = r);
            })(r, e.batchId, n),
            await Id(r, e.changes),
            await Ef(r.remoteStore);
        } catch (e) {
          const t = Mf(e, 'Failed to persist write');
          n.reject(t);
        }
      }
      async function cd(e, t) {
        const n = ui(e);
        try {
          const e = await Ih(n.localStore, t);
          t.targetChanges.forEach((e, t) => {
            const r = n.yc.get(t);
            r &&
              (si(e.addedDocuments.size + e.modifiedDocuments.size + e.removedDocuments.size <= 1),
              e.addedDocuments.size > 0
                ? (r.fc = !0)
                : e.modifiedDocuments.size > 0
                  ? si(r.fc)
                  : e.removedDocuments.size > 0 && (si(r.fc), (r.fc = !1)));
          }),
            await Id(n, e, t);
        } catch (e) {
          await qi(e);
        }
      }
      function ld(e, t, n) {
        const r = ui(e);
        if ((r.isPrimaryClient && 0 === n) || (!r.isPrimaryClient && 1 === n)) {
          const e = [];
          r.wc.forEach((n, r) => {
            const i = r.view.Mu(t);
            i.snapshot && e.push(i.snapshot);
          }),
            (function (e, t) {
              const n = ui(e);
              n.onlineState = t;
              let r = !1;
              n.queries.forEach((e, n) => {
                for (const i of n.listeners) i.Mu(t) && (r = !0);
              }),
                r && Hf(n);
            })(r.eventManager, t),
            e.length && r.dc.nu(e),
            (r.onlineState = t),
            r.isPrimaryClient && r.sharedClientState.setOnlineState(t);
        }
      }
      async function hd(e, t, n) {
        const r = ui(e);
        r.sharedClientState.updateQueryState(t, 'rejected', n);
        const i = r.yc.get(t),
          o = i && i.key;
        if (o) {
          let e = new Uo(Ni.comparator);
          e = e.insert(o, xs.newNoDocument(o, Ai.min()));
          const n = La().add(o),
            i = new Pu(Ai.min(), new Map(), new Uo(Ii), e, n);
          await cd(r, i), (r.gc = r.gc.remove(o)), r.yc.delete(t), _d(r);
        } else
          await Ah(r.localStore, t, !1)
            .then(() => vd(r, t, n))
            .catch(qi);
      }
      async function fd(e, t) {
        const n = ui(e),
          r = t.batch.batchId;
        try {
          const e = await bh(n.localStore, t);
          md(n, r, null), gd(n, r), n.sharedClientState.updateMutationState(r, 'acknowledged'), await Id(n, e);
        } catch (e) {
          await qi(e);
        }
      }
      async function dd(e, t, n) {
        const r = ui(e);
        try {
          const e = await (function (e, t) {
            const n = ui(e);
            return n.persistence.runTransaction('Reject batch', 'readwrite-primary', e => {
              let r;
              return n.mutationQueue
                .lookupMutationBatch(e, t)
                .next(t => (si(null !== t), (r = t.keys()), n.mutationQueue.removeMutationBatch(e, t)))
                .next(() => n.mutationQueue.performConsistencyCheck(e))
                .next(() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t))
                .next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, r))
                .next(() => n.localDocuments.getDocuments(e, r));
            });
          })(r.localStore, t);
          md(r, t, n), gd(r, t), r.sharedClientState.updateMutationState(t, 'rejected', n), await Id(r, e);
        } catch (n) {
          await qi(n);
        }
      }
      async function pd(e, t) {
        const n = ui(e);
        mf(n.remoteStore) ||
          ti('SyncEngine', "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
        try {
          const e = await (function (e) {
            const t = ui(e);
            return t.persistence.runTransaction('Get highest unacknowledged batch id', 'readonly', e =>
              t.mutationQueue.getHighestUnacknowledgedBatchId(e)
            );
          })(n.localStore);
          if (-1 === e) return void t.resolve();
          const r = n.Ec.get(e) || [];
          r.push(t), n.Ec.set(e, r);
        } catch (e) {
          const n = Mf(e, 'Initialization of waitForPendingWrites() operation failed');
          t.reject(n);
        }
      }
      function gd(e, t) {
        (e.Ec.get(t) || []).forEach(e => {
          e.resolve();
        }),
          e.Ec.delete(t);
      }
      function md(e, t, n) {
        const r = ui(e);
        let i = r.Tc[r.currentUser.toKey()];
        if (i) {
          const e = i.get(t);
          e && (n ? e.reject(n) : e.resolve(), (i = i.remove(t))), (r.Tc[r.currentUser.toKey()] = i);
        }
      }
      function vd(e, t, n = null) {
        e.sharedClientState.removeLocalQueryTarget(t);
        for (const r of e._c.get(t)) e.wc.delete(r), n && e.dc.Pc(r, n);
        e._c.delete(t),
          e.isPrimaryClient &&
            e.Ic.Is(t).forEach(t => {
              e.Ic.containsKey(t) || yd(e, t);
            });
      }
      function yd(e, t) {
        e.mc.delete(t.path.canonicalString());
        const n = e.gc.get(t);
        null !== n && (hf(e.remoteStore, n), (e.gc = e.gc.remove(t)), e.yc.delete(n), _d(e));
      }
      function wd(e, t, n) {
        for (const r of n)
          r instanceof Zf
            ? (e.Ic.addReference(r.key, t), bd(e, r))
            : r instanceof ed
              ? (ti('SyncEngine', 'Document no longer in limbo: ' + r.key), e.Ic.removeReference(r.key, t), e.Ic.containsKey(r.key) || yd(e, r.key))
              : oi();
      }
      function bd(e, t) {
        const n = t.key,
          r = n.path.canonicalString();
        e.gc.get(n) || e.mc.has(r) || (ti('SyncEngine', 'New document in limbo: ' + n), e.mc.add(r), _d(e));
      }
      function _d(e) {
        for (; e.mc.size > 0 && e.gc.size < e.maxConcurrentLimboResolutions; ) {
          const t = e.mc.values().next().value;
          e.mc.delete(t);
          const n = new Ni(Ci.fromString(t)),
            r = e.Ac.next();
          e.yc.set(r, new rd(n)), (e.gc = e.gc.insert(n, r)), lf(e.remoteStore, new Tc(pa(ua(n.path)), r, 'TargetPurposeLimboResolution', no.ct));
        }
      }
      async function Id(e, t, n) {
        const r = ui(e),
          i = [],
          o = [],
          s = [];
        r.wc.isEmpty() ||
          (r.wc.forEach((e, a) => {
            s.push(
              r.Rc(a, t, n).then(e => {
                if (
                  ((e || n) &&
                    r.isPrimaryClient &&
                    r.sharedClientState.updateQueryState(a.targetId, (null == e ? void 0 : e.fromCache) ? 'not-current' : 'current'),
                  e)
                ) {
                  i.push(e);
                  const t = gh.Li(a.targetId, e);
                  o.push(t);
                }
              })
            );
          }),
          await Promise.all(s),
          r.dc.nu(i),
          await (async function (e, t) {
            const n = ui(e);
            try {
              await n.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', e =>
                zi.forEach(t, t =>
                  zi
                    .forEach(t.Fi, r => n.persistence.referenceDelegate.addReference(e, t.targetId, r))
                    .next(() => zi.forEach(t.Bi, r => n.persistence.referenceDelegate.removeReference(e, t.targetId, r)))
                )
              );
            } catch (e) {
              if (!Qi(e)) throw e;
              ti('LocalStore', 'Failed to update sequence numbers: ' + e);
            }
            for (const r of t) {
              const e = r.targetId;
              if (!r.fromCache) {
                const t = n.Ji.get(e),
                  r = t.snapshotVersion,
                  i = t.withLastLimboFreeSnapshotVersion(r);
                n.Ji = n.Ji.insert(e, i);
              }
            }
          })(r.localStore, o));
      }
      async function Ed(e, t) {
        const n = ui(e);
        if (!n.currentUser.isEqual(t)) {
          ti('SyncEngine', 'User change. New user:', t.toKey());
          const e = await wh(n.localStore, t);
          (n.currentUser = t),
            (function (e, t) {
