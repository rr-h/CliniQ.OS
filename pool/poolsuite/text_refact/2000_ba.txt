remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
          (this.settings = e),
            (this.databaseId = t),
            (this.serializer = n),
            (this.ignoreUndefinedProperties = r),
            void 0 === i && this.ua(),
            (this.fieldTransforms = i || []),
            (this.fieldMask = o || []);
        }
        get path() {
          return this.settings.path;
        }
        get ca() {
          return this.settings.ca;
        }
        aa(e) {
          return new ig(
            Object.assign(Object.assign({}, this.settings), e),
            this.databaseId,
            this.serializer,
            this.ignoreUndefinedProperties,
            this.fieldTransforms,
            this.fieldMask
          );
        }
        ha(e) {
          var t;
          const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e),
            r = this.aa({ path: n, la: !1 });
          return r.fa(e), r;
        }
        da(e) {
          var t;
          const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e),
            r = this.aa({ path: n, la: !1 });
          return r.ua(), r;
        }
        wa(e) {
          return this.aa({ path: void 0, la: !0 });
        }
        _a(e) {
          return Sg(e, this.settings.methodName, this.settings.ma || !1, this.path, this.settings.ga);
        }
        contains(e) {
          return void 0 !== this.fieldMask.find(t => e.isPrefixOf(t)) || void 0 !== this.fieldTransforms.find(t => e.isPrefixOf(t.field));
        }
        ua() {
          if (this.path) for (let e = 0; e < this.path.length; e++) this.fa(this.path.get(e));
        }
        fa(e) {
          if (0 === e.length) throw this._a('Document fields must not be empty');
          if (rg(this.ca) && eg.test(e)) throw this._a('Document fields cannot begin and end with "__"');
        }
      }
      class og {
        constructor(e, t, n) {
          (this.databaseId = e), (this.ignoreUndefinedProperties = t), (this.serializer = n || Zh(e));
        }
        ya(e, t, n, r = !1) {
          return new ig(
            { ca: e, methodName: t, ga: n, path: Oi.emptyPath(), la: !1, ma: r },
            this.databaseId,
            this.serializer,
            this.ignoreUndefinedProperties
          );
        }
      }
      function sg(e) {
        const t = e._freezeSettings(),
          n = Zh(e._databaseId);
        return new og(e._databaseId, !!t.ignoreUndefinedProperties, n);
      }
      function ag(e, t, n, r, i, o = {}) {
        const s = e.ya(o.merge || o.mergeFields ? 2 : 0, t, n, i);
        bg('Data must be an object, but it was:', s, r);
        const a = yg(r, s);
        let u, c;
        if (o.merge) (u = new Go(s.fieldMask)), (c = s.fieldTransforms);
        else if (o.mergeFields) {
          const e = [];
          for (const r of o.mergeFields) {
            const i = _g(t, r, n);
            if (!s.contains(i)) throw new li(ci.INVALID_ARGUMENT, `Field '${i}' is specified in your field mask but missing from your input data.`);
            Tg(e, i) || e.push(i);
          }
          (u = new Go(e)), (c = s.fieldTransforms.filter(e => u.covers(e.field)));
        } else (u = null), (c = s.fieldTransforms);
        return new tg(new Ts(a), u, c);
      }
      class ug extends Jp {
        _toFieldTransform(e) {
          if (2 !== e.ca)
            throw 1 === e.ca
              ? e._a(`${this._methodName}() can only appear at the top level of your update data`)
              : e._a(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
          return e.fieldMask.push(e.path), null;
        }
        isEqual(e) {
          return e instanceof ug;
        }
      }
      function cg(e, t, n) {
        return new ig({ ca: 3, ga: t.settings.ga, methodName: e._methodName, la: n }, t.databaseId, t.serializer, t.ignoreUndefinedProperties);
      }
      class lg extends Jp {
        _toFieldTransform(e) {
          return new Za(e.path, new Ga());
        }
        isEqual(e) {
          return e instanceof lg;
        }
      }
      class hg extends Jp {
        constructor(e, t) {
          super(e), (this.pa = t);
        }
        _toFieldTransform(e) {
          const t = cg(this, e, !0),
            n = this.pa.map(e => vg(e, t)),
            r = new Wa(n);
          return new Za(e.path, r);
        }
        isEqual(e) {
          return this === e;
        }
      }
      class fg extends Jp {
        constructor(e, t) {
          super(e), (this.pa = t);
        }
        _toFieldTransform(e) {
          const t = cg(this, e, !0),
            n = this.pa.map(e => vg(e, t)),
            r = new Ka(n);
          return new Za(e.path, r);
        }
        isEqual(e) {
          return this === e;
        }
      }
      class dg extends Jp {
        constructor(e, t) {
          super(e), (this.Ia = t);
        }
        _toFieldTransform(e) {
          const t = new Ya(e.serializer, Va(e.serializer, this.Ia));
          return new Za(e.path, t);
        }
        isEqual(e) {
          return this === e;
        }
      }
      function pg(e, t, n, r) {
        const i = e.ya(1, t, n);
        bg('Data must be an object, but it was:', i, r);
        const o = [],
          s = Ts.empty();
        Mo(r, (e, r) => {
          const a = Eg(t, e, n);
          r = (0, u.m9)(r);
          const c = i.da(a);
          if (r instanceof ug) o.push(a);
          else {
            const e = vg(r, c);
            null != e && (o.push(a), s.set(a, e));
          }
        });
        const a = new Go(o);
        return new ng(s, a, i.fieldTransforms);
      }
      function gg(e, t, n, r, i, o) {
        const s = e.ya(1, t, n),
          a = [_g(t, r, n)],
          c = [i];
        if (o.length % 2 != 0)
          throw new li(
            ci.INVALID_ARGUMENT,
            `Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`
          );
        for (let u = 0; u < o.length; u += 2) a.push(_g(t, o[u])), c.push(o[u + 1]);
        const l = [],
          h = Ts.empty();
        for (let d = a.length - 1; d >= 0; --d)
          if (!Tg(l, a[d])) {
            const e = a[d];
            let t = c[d];
            t = (0, u.m9)(t);
            const n = s.da(e);
            if (t instanceof ug) l.push(e);
            else {
              const r = vg(t, n);
              null != r && (l.push(e), h.set(e, r));
            }
          }
        const f = new Go(l);
        return new ng(h, f, s.fieldTransforms);
      }
      function mg(e, t, n, r = !1) {
        return vg(n, e.ya(r ? 4 : 3, t));
      }
      function vg(e, t) {
        if (wg((e = (0, u.m9)(e)))) return bg('Unsupported field value:', t, e), yg(e, t);
        if (e instanceof Jp)
          return (
            (function (e, t) {
              if (!rg(t.ca)) throw t._a(`${e._methodName}() can only be used with update() and set()`);
              if (!t.path) throw t._a(`${e._methodName}() is not currently supported inside arrays`);
              const n = e._toFieldTransform(t);
              n && t.fieldTransforms.push(n);
            })(e, t),
            null
          );
        if (void 0 === e && t.ignoreUndefinedProperties) return null;
        if ((t.path && t.fieldMask.push(t.path), e instanceof Array)) {
          if (t.settings.la && 4 !== t.ca) throw t._a('Nested arrays are not supported');
          return (function (e, t) {
            const n = [];
            let r = 0;
            for (const i of e) {
              let e = vg(i, t.wa(r));
              null == e && (e = { nullValue: 'NULL_VALUE' }), n.push(e), r++;
            }
            return { arrayValue: { values: n } };
          })(e, t);
        }
        return (function (e, t) {
          if (null === (e = (0, u.m9)(e))) return { nullValue: 'NULL_VALUE' };
          if ('number' == typeof e) return Va(t.serializer, e);
          if ('boolean' == typeof e) return { booleanValue: e };
          if ('string' == typeof e) return { stringValue: e };
          if (e instanceof Date) {
            const n = Ti.fromDate(e);
            return { timestampValue: Hu(t.serializer, n) };
          }
          if (e instanceof Ti) {
            const n = new Ti(e.seconds, 1e3 * Math.floor(e.nanoseconds / 1e3));
            return { timestampValue: Hu(t.serializer, n) };
          }
          if (e instanceof Zp) return { geoPointValue: { latitude: e.latitude, longitude: e.longitude } };
          if (e instanceof Yp) return { bytesValue: Ku(t.serializer, e._byteString) };
          if (e instanceof Tp) {
            const n = t.databaseId,
              r = e.firestore._databaseId;
            if (!r.isEqual(n))
              throw t._a(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);
            return { referenceValue: Xu(e.firestore._databaseId || t.databaseId, e._key.path) };
          }
          throw t._a(`Unsupported field value: ${wp(e)}`);
        })(e, t);
      }
      function yg(e, t) {
        const n = {};
        return (
          Fo(e)
            ? t.path && t.path.length > 0 && t.fieldMask.push(t.path)
            : Mo(e, (e, r) => {
                const i = vg(r, t.ha(e));
                null != i && (n[e] = i);
              }),
          { mapValue: { fields: n } }
        );
      }
      function wg(e) {
        return !(
          'object' != typeof e ||
          null === e ||
          e instanceof Array ||
          e instanceof Date ||
          e instanceof Ti ||
          e instanceof Zp ||
          e instanceof Yp ||
          e instanceof Tp ||
          e instanceof Jp
        );
      }
      function bg(e, t, n) {
        if (
          !wg(n) ||
          !(function (e) {
            return 'object' == typeof e && null !== e && (Object.getPrototypeOf(e) === Object.prototype || null === Object.getPrototypeOf(e));
          })(n)
        ) {
          const r = wp(n);
          throw 'an object' === r ? t._a(e + ' a custom object') : t._a(e + ' ' + r);
        }
      }
      function _g(e, t, n) {
        if ((t = (0, u.m9)(t)) instanceof Xp) return t._internalPath;
        if ('string' == typeof t) return Eg(e, t);
        throw Sg('Field path arguments must be of type string or ', e, !1, void 0, n);
      }
      const Ig = new RegExp('[~\\*/\\[\\]]');
      function Eg(e, t, n) {
        if (t.search(Ig) >= 0) throw Sg(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, n);
        try {
          return new Xp(...t.split('.'))._internalPath;
        } catch (r) {
          throw Sg(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, n);
        }
      }
      function Sg(e, t, n, r, i) {
        const o = r && !r.isEmpty(),
          s = void 0 !== i;
        let a = `Function ${t}() called with invalid data`;
        n && (a += ' (via `toFirestore()`)'), (a += '. ');
        let u = '';
        return (
          (o || s) && ((u += ' (found'), o && (u += ` in field ${r}`), s && (u += ` in document ${i}`), (u += ')')),
          new li(ci.INVALID_ARGUMENT, a + e + u)
        );
      }
      function Tg(e, t) {
        return e.some(e => e.isEqual(t));
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ag {
        constructor(e, t, n, r, i) {
          (this._firestore = e), (this._userDataWriter = t), (this._key = n), (this._document = r), (this._converter = i);
        }
        get id() {
          return this._key.path.lastSegment();
        }
        get ref() {
          return new Tp(this._firestore, this._converter, this._key);
        }
        exists() {
          return null !== this._document;
        }
        data() {
          if (this._document) {
            if (this._converter) {
              const e = new xg(this._firestore, this._userDataWriter, this._key, this._document, null);
              return this._converter.fromFirestore(e);
            }
            return this._userDataWriter.convertValue(this._document.data.value);
          }
        }
        get(e) {
          if (this._document) {
            const t = this._document.data.field(Cg('DocumentSnapshot.get', e));
            if (null !== t) return this._userDataWriter.convertValue(t);
          }
        }
      }
      class xg extends Ag {
        data() {
          return super.data();
        }
      }
      function Cg(e, t) {
        return 'string' == typeof t ? Eg(e, t) : t instanceof Xp ? t._internalPath : t._delegate._internalPath;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function kg(e) {
        if ('L' === e.limitType && 0 === e.explicitOrderBy.length)
          throw new li(ci.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');
      }
      class Og {}
      class Ng extends Og {}
      function Rg(e, t, ...n) {
        let r = [];
        t instanceof Og && r.push(t),
          (r = r.concat(n)),
          (function (e) {
            const t = e.filter(e => e instanceof Lg).length,
              n = e.filter(e => e instanceof Pg).length;
            if (t > 1 || (t > 0 && n > 0))
              throw new li(
                ci.INVALID_ARGUMENT,
                'InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.'
              );
          })(
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ r
          );
        for (const i of r) e = i._apply(e);
        return e;
      }
      class Pg extends Ng {
        constructor(e, t, n) {
          super(), (this._field = e), (this._op = t), (this._value = n), (this.type = 'where');
        }
        static _create(e, t, n) {
          return new Pg(e, t, n);
        }
        _apply(e) {
          const t = this._parse(e);
          return Yg(e._query, t), new Ap(e.firestore, e.converter, ga(e._query, t));
        }
        _parse(e) {
          const t = sg(e.firestore),
            n = (function (e, t, n, r, i, o, s) {
              let a;
              if (i.isKeyField()) {
                if ('array-contains' === o || 'array-contains-any' === o)
                  throw new li(ci.INVALID_ARGUMENT, `Invalid Query. You can't perform '${o}' queries on documentId().`);
                if ('in' === o || 'not-in' === o) {
                  Qg(s, o);
                  const t = [];
                  for (const n of s) t.push(Kg(r, e, n));
                  a = { arrayValue: { values: t } };
                } else a = Kg(r, e, s);
              } else ('in' !== o && 'not-in' !== o && 'array-contains-any' !== o) || Qg(s, o), (a = mg(n, t, s, 'in' === o || 'not-in' === o));
              return Ds.create(i, o, a);
            })(e._query, 'where', t, e.firestore._databaseId, this._field, this._op, this._value);
          return n;
        }
      }
      function Dg(e, t, n) {
        const r = t,
          i = Cg('where', e);
        return Pg._create(i, r, n);
      }
      class Lg extends Og {
        constructor(e, t) {
          super(), (this.type = e), (this._queryConstraints = t);
        }
        static _create(e, t) {
          return new Lg(e, t);
        }
        _parse(e) {
          const t = this._queryConstraints.map(t => t._parse(e)).filter(e => e.getFilters().length > 0);
          return 1 === t.length ? t[0] : Ls.create(t, this._getOperator());
        }
        _apply(e) {
          const t = this._parse(e);
          return 0 === t.getFilters().length
            ? e
            : ((function (e, t) {
                let n = e;
                const r = t.getFlattenedFilters();
                for (const i of r) Yg(n, i), (n = ga(n, i));
              })(e._query, t),
              new Ap(e.firestore, e.converter, ga(e._query, t)));
        }
        _getQueryConstraints() {
          return this._queryConstraints;
        }
        _getOperator() {
          return 'and' === this.type ? 'and' : 'or';
        }
      }
      class jg extends Ng {
        constructor(e, t) {
          super(), (this._field = e), (this._direction = t), (this.type = 'orderBy');
        }
        static _create(e, t) {
          return new jg(e, t);
        }
        _apply(e) {
          const t = (function (e, t, n) {
            if (null !== e.startAt)
              throw new li(ci.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before calling orderBy().');
            if (null !== e.endAt)
              throw new li(ci.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before calling orderBy().');
            const r = new Ns(t, n);
            return (
              (function (e, t) {
                if (null === la(e)) {
                  const n = ha(e);
                  null !== n && Xg(e, n, t.field);
                }
              })(e, r),
              r
            );
          })(e._query, this._field, this._direction);
          return new Ap(
            e.firestore,
            e.converter,
            (function (e, t) {
              const n = e.explicitOrderBy.concat([t]);
              return new sa(e.path, e.collectionGroup, n, e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt);
            })(e._query, t)
          );
        }
      }
      function Mg(e, t = 'asc') {
        const n = t,
          r = Cg('orderBy', e);
        return jg._create(r, n);
      }
      class Fg extends Ng {
        constructor(e, t, n) {
          super(), (this.type = e), (this._limit = t), (this._limitType = n);
        }
        static _create(e, t, n) {
          return new Fg(e, t, n);
        }
        _apply(e) {
          return new Ap(e.firestore, e.converter, ma(e._query, this._limit, this._limitType));
        }
      }
      function Ug(e) {
        return _p('limit', e), Fg._create('limit', e, 'F');
      }
      function Vg(e) {
        return _p('limitToLast', e), Fg._create('limitToLast', e, 'L');
      }
      class Bg extends Ng {
        constructor(e, t, n) {
          super(), (this.type = e), (this._docOrFields = t), (this._inclusive = n);
        }
        static _create(e, t, n) {
          return new Bg(e, t, n);
        }
        _apply(e) {
          const t = Hg(e, this.type, this._docOrFields, this._inclusive);
          return new Ap(
            e.firestore,
            e.converter,
            (function (e, t) {
              return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, t, e.endAt);
            })(e._query, t)
          );
        }
      }
      function $g(...e) {
        return Bg._create('startAt', e, !0);
      }
      function qg(...e) {
        return Bg._create('startAfter', e, !1);
      }
      class zg extends Ng {
        constructor(e, t, n) {
          super(), (this.type = e), (this._docOrFields = t), (this._inclusive = n);
        }
        static _create(e, t, n) {
          return new zg(e, t, n);
        }
        _apply(e) {
          const t = Hg(e, this.type, this._docOrFields, this._inclusive);
          return new Ap(
            e.firestore,
            e.converter,
            (function (e, t) {
              return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, t);
            })(e._query, t)
          );
        }
      }
      function Gg(...e) {
        return zg._create('endBefore', e, !1);
      }
      function Wg(...e) {
        return zg._create('endAt', e, !0);
      }
      function Hg(e, t, n, r) {
        if (((n[0] = (0, u.m9)(n[0])), n[0] instanceof Ag))
          return (function (e, t, n, r, i) {
            if (!r) throw new li(ci.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n}().`);
            const o = [];
            for (const s of da(e))
              if (s.field.isKeyField()) o.push(ds(t, r.key));
              else {
                const e = r.data.field(s.field);
                if (Zo(e))
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    'Invalid query. You are trying to start or end a query using a document for which the field "' +
                      s.field +
                      '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)'
                  );
                if (null === e) {
                  const e = s.field.canonicalString();
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    `Invalid query. You are trying to start or end a query using a document for which the field '${e}' (used as the orderBy) does not exist.`
                  );
                }
                o.push(e);
              }
            return new Cs(o, i);
          })(e._query, e.firestore._databaseId, t, n[0]._document, r);
        {
          const i = sg(e.firestore);
          return (function (e, t, n, r, i, o) {
            const s = e.explicitOrderBy;
            if (i.length > s.length)
              throw new li(
                ci.INVALID_ARGUMENT,
                `Too many arguments provided to ${r}(). The number of arguments must be less than or equal to the number of orderBy() clauses`
              );
            const a = [];
            for (let u = 0; u < i.length; u++) {
              const o = i[u];
              if (s[u].field.isKeyField()) {
                if ('string' != typeof o)
                  throw new li(ci.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${r}(), but got a ${typeof o}`);
                if (!fa(e) && -1 !== o.indexOf('/'))
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${r}() must be a plain document ID, but '${o}' contains a slash.`
                  );
                const n = e.path.child(Ci.fromString(o));
                if (!Ni.isDocumentKey(n))
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${r}() must result in a valid document path, but '${n}' is not because it contains an odd number of segments.`
                  );
                const i = new Ni(n);
                a.push(ds(t, i));
              } else {
                const e = mg(n, r, o);
                a.push(e);
              }
            }
            return new Cs(a, o);
          })(e._query, e.firestore._databaseId, i, t, n, r);
        }
      }
      function Kg(e, t, n) {
        if ('string' == typeof (n = (0, u.m9)(n))) {
          if ('' === n)
            throw new li(
              ci.INVALID_ARGUMENT,
              'Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.'
            );
          if (!fa(t) && -1 !== n.indexOf('/'))
            throw new li(
              ci.INVALID_ARGUMENT,
              `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`
            );
          const r = t.path.child(Ci.fromString(n));
          if (!Ni.isDocumentKey(r))
            throw new li(
              ci.INVALID_ARGUMENT,
              `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`
            );
          return ds(e, new Ni(r));
        }
        if (n instanceof Tp) return ds(e, n._key);
        throw new li(
          ci.INVALID_ARGUMENT,
          `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${wp(n)}.`
        );
      }
      function Qg(e, t) {
        if (!Array.isArray(e) || 0 === e.length)
          throw new li(ci.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${t.toString()}' filters.`);
      }
      function Yg(e, t) {
        if (t.isInequality()) {
          const n = ha(e),
            r = t.field;
          if (null !== n && !n.isEqual(r))
            throw new li(
              ci.INVALID_ARGUMENT,
              `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n.toString()}' and '${r.toString()}'`
            );
          const i = la(e);
          null !== i && Xg(e, r, i);
        }
        const n = (function (e, t) {
          for (const n of e) for (const e of n.getFlattenedFilters()) if (t.indexOf(e.op) >= 0) return e.op;
          return null;
        })(
          e.filters,
          (function (e) {
            switch (e) {
              case '!=':
                return ['!=', 'not-in'];
              case 'array-contains-any':
              case 'in':
                return ['not-in'];
              case 'not-in':
                return ['array-contains-any', 'in', 'not-in', '!='];
              default:
                return [];
            }
          })(t.op)
        );
        if (null !== n)
          throw n === t.op
            ? new li(ci.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${t.op.toString()}' filter.`)
            : new li(ci.INVALID_ARGUMENT, `Invalid query. You cannot use '${t.op.toString()}' filters with '${n.toString()}' filters.`);
      }
      function Xg(e, t, n) {
        if (!n.isEqual(t))
          throw new li(
            ci.INVALID_ARGUMENT,
            `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${t.toString()}' and so you must also use '${t.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`
          );
      }
      class Jg {
        convertValue(e, t = 'none') {
          switch (ss(e)) {
            case 0:
              return null;
            case 1:
              return e.booleanValue;
            case 2:
              return Xo(e.integerValue || e.doubleValue);
            case 3:
              return this.convertTimestamp(e.timestampValue);
            case 4:
              return this.convertServerTimestamp(e, t);
            case 5:
              return e.stringValue;
            case 6:
              return this.convertBytes(Jo(e.bytesValue));
            case 7:
              return this.convertReference(e.referenceValue);
            case 8:
              return this.convertGeoPoint(e.geoPointValue);
            case 9:
              return this.convertArray(e.arrayValue, t);
            case 10:
              return this.convertObject(e.mapValue, t);
            default:
              throw oi();
          }
        }
        convertObject(e, t) {
          return this.convertObjectMap(e.fields, t);
        }
        convertObjectMap(e, t = 'none') {
          const n = {};
          return (
            Mo(e, (e, r) => {
              n[e] = this.convertValue(r, t);
            }),
            n
          );
        }
        convertGeoPoint(e) {
          return new Zp(Xo(e.latitude), Xo(e.longitude));
        }
        convertArray(e, t) {
          return (e.values || []).map(e => this.convertValue(e, t));
        }
        convertServerTimestamp(e, t) {
          switch (t) {
            case 'previous':
              const n = es(e);
              return null == n ? null : this.convertValue(n, t);
            case 'estimate':
              return this.convertTimestamp(ts(e));
            default:
              return null;
          }
        }
        convertTimestamp(e) {
          const t = Yo(e);
          return new Ti(t.seconds, t.nanos);
        }
        convertDocumentKey(e, t) {
          const n = Ci.fromString(e);
          si(Sc(n));
          const r = new rs(n.get(1), n.get(3)),
            i = new Ni(n.popFirst(5));
          return (
            r.isEqual(t) ||
              ni(
                `Document ${i} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`
              ),
            i
          );
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Zg(e, t, n) {
        let r;
        return (r = e ? (n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t)) : t), r;
      }
      class em extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Yp(e);
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return new Tp(this.firestore, null, t);
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class tm {
        constructor(e, t) {
          (this.hasPendingWrites = e), (this.fromCache = t);
        }
        isEqual(e) {
          return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache;
        }
      }
      class nm extends Ag {
        constructor(e, t, n, r, i, o) {
          super(e, t, n, r, o), (this._firestore = e), (this._firestoreImpl = e), (this.metadata = i);
        }
        exists() {
          return super.exists();
        }
        data(e = {}) {
          if (this._document) {
            if (this._converter) {
              const t = new rm(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
              return this._converter.fromFirestore(t, e);
            }
            return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps);
          }
        }
        get(e, t = {}) {
          if (this._document) {
            const n = this._document.data.field(Cg('DocumentSnapshot.get', e));
            if (null !== n) return this._userDataWriter.convertValue(n, t.serverTimestamps);
          }
        }
      }
      class rm extends nm {
        data(e = {}) {
          return super.data(e);
        }
      }
      class im {
        constructor(e, t, n, r) {
          (this._firestore = e),
            (this._userDataWriter = t),
            (this._snapshot = r),
            (this.metadata = new tm(r.hasPendingWrites, r.fromCache)),
            (this.query = n);
        }
        get docs() {
          const e = [];
          return this.forEach(t => e.push(t)), e;
        }
        get size() {
          return this._snapshot.docs.size;
        }
        get empty() {
          return 0 === this.size;
        }
        forEach(e, t) {
          this._snapshot.docs.forEach(n => {
            e.call(
              t,
              new rm(
                this._firestore,
                this._userDataWriter,
                n.key,
                n,
                new tm(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache),
                this.query.converter
              )
            );
          });
        }
        docChanges(e = {}) {
          const t = !!e.includeMetadataChanges;
          if (t && this._snapshot.excludesMetadataChanges)
            throw new li(
              ci.INVALID_ARGUMENT,
              'To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().'
            );
          return (
            (this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t) ||
              ((this._cachedChanges = (function (e, t) {
                if (e._snapshot.oldDocs.isEmpty()) {
                  let t = 0;
                  return e._snapshot.docChanges.map(n => {
                    const r = new rm(
                      e._firestore,
                      e._userDataWriter,
                      n.doc.key,
                      n.doc,
                      new tm(e._snapshot.mutatedKeys.has(n.doc.key), e._snapshot.fromCache),
                      e.query.converter
                    );
                    return n.doc, { type: 'added', doc: r, oldIndex: -1, newIndex: t++ };
                  });
                }
                {
                  let n = e._snapshot.oldDocs;
                  return e._snapshot.docChanges
                    .filter(e => t || 3 !== e.type)
                    .map(t => {
                      const r = new rm(
                        e._firestore,
                        e._userDataWriter,
                        t.doc.key,
                        t.doc,
                        new tm(e._snapshot.mutatedKeys.has(t.doc.key), e._snapshot.fromCache),
                        e.query.converter
                      );
                      let i = -1,
                        o = -1;
                      return (
                        0 !== t.type && ((i = n.indexOf(t.doc.key)), (n = n.delete(t.doc.key))),
                        1 !== t.type && ((n = n.add(t.doc)), (o = n.indexOf(t.doc.key))),
                        { type: om(t.type), doc: r, oldIndex: i, newIndex: o }
                      );
                    });
                }
              })(this, t)),
              (this._cachedChangesIncludeMetadataChanges = t)),
            this._cachedChanges
          );
        }
      }
      function om(e) {
        switch (e) {
          case 0:
            return 'added';
          case 2:
          case 3:
            return 'modified';
          case 1:
            return 'removed';
          default:
            return oi();
        }
      }
      function sm(e, t) {
        return e instanceof nm && t instanceof nm
          ? e._firestore === t._firestore &&
              e._key.isEqual(t._key) &&
              (null === e._document ? null === t._document : e._document.isEqual(t._document)) &&
              e._converter === t._converter
          : e instanceof im &&
              t instanceof im &&
              e._firestore === t._firestore &&
              Rp(e.query, t.query) &&
              e.metadata.isEqual(t.metadata) &&
              e._snapshot.isEqual(t._snapshot);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function am(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp);
        return ap(Fp(t), e._key).then(n => _m(t, e, n));
      }
      class um extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Yp(e);
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return new Tp(this.firestore, null, t);
        }
      }
      function cm(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return sp(n, e._key).then(n => new nm(t, r, e._key, n, new tm(null !== n && n.hasLocalMutations, !0), e.converter));
      }
      function lm(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp);
        return ap(Fp(t), e._key, { source: 'server' }).then(n => _m(t, e, n));
      }
      function hm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return kg(e._query), cp(n, e._query).then(n => new im(t, r, e, n));
      }
      function fm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return up(n, e._query).then(n => new im(t, r, e, n));
      }
      function dm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return cp(n, e._query, { source: 'server' }).then(n => new im(t, r, e, n));
      }
      function pm(e, t, n) {
        e = bp(e, Tp);
        const r = bp(e.firestore, Mp),
          i = Zg(e.converter, t, n);
        return bm(r, [ag(sg(r), 'setDoc', e._key, i, null !== e.converter, n).toMutation(e._key, nu.none())]);
      }
      function gm(e, t, n, ...r) {
        e = bp(e, Tp);
        const i = bp(e.firestore, Mp),
          o = sg(i);
        let s;
        return (
          (s = 'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp ? gg(o, 'updateDoc', e._key, t, n, r) : pg(o, 'updateDoc', e._key, t)),
          bm(i, [s.toMutation(e._key, nu.exists(!0))])
        );
      }
      function mm(e) {
        return bm(bp(e.firestore, Mp), [new gu(e._key, nu.none())]);
      }
      function vm(e, t) {
        const n = bp(e.firestore, Mp),
          r = Op(e),
          i = Zg(e.converter, t);
        return bm(n, [ag(sg(e.firestore), 'addDoc', r._key, i, null !== e.converter, {}).toMutation(r._key, nu.exists(!1))]).then(() => r);
      }
      function ym(e, ...t) {
        var n, r, i;
        e = (0, u.m9)(e);
        let o = { includeMetadataChanges: !1 },
          s = 0;
        'object' != typeof t[s] || Dp(t[s]) || ((o = t[s]), s++);
        const a = { includeMetadataChanges: o.includeMetadataChanges };
        if (Dp(t[s])) {
          const e = t[s];
          (t[s] = null === (n = e.next) || void 0 === n ? void 0 : n.bind(e)),
            (t[s + 1] = null === (r = e.error) || void 0 === r ? void 0 : r.bind(e)),
            (t[s + 2] = null === (i = e.complete) || void 0 === i ? void 0 : i.bind(e));
        }
        let c, l, h;
        if (e instanceof Tp)
          (l = bp(e.firestore, Mp)),
            (h = ua(e._key.path)),
            (c = {
              next: n => {
                t[s] && t[s](_m(l, e, n));
              },
              error: t[s + 1],
              complete: t[s + 2]
            });
        else {
          const n = bp(e, Ap);
          (l = bp(n.firestore, Mp)), (h = n._query);
          const r = new um(l);
          (c = {
            next: e => {
              t[s] && t[s](new im(l, r, n, e));
            },
            error: t[s + 1],
            complete: t[s + 2]
          }),
            kg(e._query);
        }
        return (function (e, t, n, r) {
          const i = new $d(r),
            o = new Kf(t, i, n);
          return (
            e.asyncQueue.enqueueAndForget(async () => qf(await rp(e), o)),
            () => {
              i.Dc(), e.asyncQueue.enqueueAndForget(async () => zf(await rp(e), o));
            }
          );
        })(Fp(l), h, a, c);
      }
      function wm(e, t) {
        return lp(Fp((e = bp(e, Mp))), Dp(t) ? t : { next: t });
      }
      function bm(e, t) {
        return (function (e, t) {
          const n = new hi();
          return e.asyncQueue.enqueueAndForget(async () => ud(await tp(e), t, n)), n.promise;
        })(Fp(e), t);
      }
      function _m(e, t, n) {
        const r = n.docs.get(t._key),
          i = new um(e);
        return new nm(e, i, t._key, r, new tm(n.hasPendingWrites, n.fromCache), t.converter);
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const Im = { maxAttempts: 5 };
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Em {
        constructor(e, t) {
          (this._firestore = e), (this._commitHandler = t), (this._mutations = []), (this._committed = !1), (this._dataReader = sg(e));
        }
        set(e, t, n) {
          this._verifyNotCommitted();
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'WriteBatch.set', r._key, i, null !== r.converter, n);
          return this._mutations.push(o.toMutation(r._key, nu.none())), this;
        }
        update(e, t, n, ...r) {
          this._verifyNotCommitted();
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'WriteBatch.update', i._key, t, n, r)
                : pg(this._dataReader, 'WriteBatch.update', i._key, t)),
            this._mutations.push(o.toMutation(i._key, nu.exists(!0))),
            this
          );
        }
        delete(e) {
          this._verifyNotCommitted();
          const t = Sm(e, this._firestore);
          return (this._mutations = this._mutations.concat(new gu(t._key, nu.none()))), this;
        }
        commit() {
          return (
            this._verifyNotCommitted(), (this._committed = !0), this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
          );
        }
        _verifyNotCommitted() {
          if (this._committed) throw new li(ci.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() has been called.');
        }
      }
      function Sm(e, t) {
        if ((e = (0, u.m9)(e)).firestore !== t)
          throw new li(ci.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');
        return e;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tm extends class {
        constructor(e, t) {
          (this._firestore = e), (this._transaction = t), (this._dataReader = sg(e));
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new em(this._firestore);
          return this._transaction.lookup([t._key]).then(e => {
            if (!e || 1 !== e.length) return oi();
            const r = e[0];
            if (r.isFoundDocument()) return new Ag(this._firestore, n, r.key, r, t.converter);
            if (r.isNoDocument()) return new Ag(this._firestore, n, t._key, null, t.converter);
            throw oi();
          });
        }
        set(e, t, n) {
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'Transaction.set', r._key, i, null !== r.converter, n);
          return this._transaction.set(r._key, o), this;
        }
        update(e, t, n, ...r) {
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'Transaction.update', i._key, t, n, r)
                : pg(this._dataReader, 'Transaction.update', i._key, t)),
            this._transaction.update(i._key, o),
            this
          );
        }
        delete(e) {
          const t = Sm(e, this._firestore);
          return this._transaction.delete(t._key), this;
        }
      } {
        constructor(e, t) {
          super(e, t), (this._firestore = e);
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new um(this._firestore);
          return super.get(e).then(e => new nm(this._firestore, n, t._key, e._document, new tm(!1, !1), t.converter));
        }
      }
      function Am(e, t, n) {
        e = bp(e, Mp);
        const r = Object.assign(Object.assign({}, Im), n);
        return (
          (function (e) {
            if (e.maxAttempts < 1) throw new li(ci.INVALID_ARGUMENT, 'Max attempts must be at least 1');
          })(r),
          (function (e, t, n) {
            const r = new hi();
            return (
              e.asyncQueue.enqueueAndForget(async () => {
                const i = await np(e);
                new Gd(e.asyncQueue, i, n, t, r).run();
              }),
              r.promise
            );
          })(Fp(e), n => t(new Tm(e, n)), r)
        );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function xm() {
        return new ug('deleteField');
      }
      function Cm() {
        return new lg('serverTimestamp');
      }
      function km(...e) {
        return new hg('arrayUnion', e);
      }
      function Om(...e) {
        return new fg('arrayRemove', e);
      }
      function Nm(e) {
        return new dg('increment', e);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ !(function (e, t = !0) {
        !(function (e) {
          Xr = e;
        })(o.SDK_VERSION),
          (0, o._registerComponent)(
            new s.wA(
              'firestore',
              (e, { instanceIdentifier: n, options: r }) => {
                const i = e.getProvider('app').getImmediate(),
                  o = new Mp(
                    new gi(e.getProvider('auth-internal')),
                    new wi(e.getProvider('app-check-internal')),
                    (function (e, t) {
                      if (!Object.prototype.hasOwnProperty.apply(e.options, ['projectId']))
                        throw new li(ci.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
                      return new rs(e.options.projectId, t);
                    })(i, n),
                    i
                  );
                return (r = Object.assign({ useFetchStreams: t }, r)), o._setSettings(r), o;
              },
              'PUBLIC'
            ).setMultipleInstances(!0)
          ),
          (0, o.registerVersion)(Qr, '3.13.0', e),
          (0, o.registerVersion)(Qr, '3.13.0', 'esm2017');
      })();
      const Rm = '@firebase/firestore-compat',
        Pm = '0.3.12';
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function Dm(e, t) {
        if (void 0 === t) return { merge: !1 };
        if (void 0 !== t.mergeFields && void 0 !== t.merge)
          throw new li('invalid-argument', `Invalid options passed to function ${e}(): You cannot specify both "merge" and "mergeFields".`);
        return t;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Lm() {
        if ('undefined' === typeof Uint8Array) throw new li('unimplemented', 'Uint8Arrays are not available in this environment.');
      }
      function jm() {
        if (!Ho()) throw new li('unimplemented', 'Blobs are unavailable in Firestore in this environment.');
      }
      class Mm {
        constructor(e) {
          this._delegate = e;
        }
        static fromBase64String(e) {
          return jm(), new Mm(Yp.fromBase64String(e));
        }
        static fromUint8Array(e) {
          return Lm(), new Mm(Yp.fromUint8Array(e));
        }
        toBase64() {
          return jm(), this._delegate.toBase64();
        }
        toUint8Array() {
          return Lm(), this._delegate.toUint8Array();
        }
        isEqual(e) {
          return this._delegate.isEqual(e._delegate);
        }
        toString() {
          return 'Blob(base64: ' + this.toBase64() + ')';
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Fm(e) {
        return Um(e, ['next', 'error', 'complete']);
      }
      function Um(e, t) {
        if ('object' !== typeof e || null === e) return !1;
        const n = e;
        for (const r of t) if (r in n && 'function' === typeof n[r]) return !0;
        return !1;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Vm {
        enableIndexedDbPersistence(e, t) {
          return Vp(e._delegate, { forceOwnership: t });
        }
        enableMultiTabIndexedDbPersistence(e) {
          return Bp(e._delegate);
        }
        clearIndexedDbPersistence(e) {
          return qp(e._delegate);
        }
      }
      class Bm {
        constructor(e, t, n) {
          (this._delegate = t),
            (this._persistenceProvider = n),
            (this.INTERNAL = { delete: () => this.terminate() }),
            e instanceof rs || (this._appCompat = e);
        }
        get _databaseId() {
          return this._delegate._databaseId;
        }
        settings(e) {
          const t = this._delegate._getSettings();
          e.merge ||
            t.host === e.host ||
            ri('You are overriding the original host. If you did not intend to override your settings, use {merge: true}.'),
            e.merge && ((e = Object.assign(Object.assign({}, t), e)), delete e.merge),
            this._delegate._setSettings(e);
        }
        useEmulator(e, t, n = {}) {
          Sp(this._delegate, e, t, n);
        }
        enableNetwork() {
          return Gp(this._delegate);
        }
        disableNetwork() {
          return Wp(this._delegate);
        }
        enablePersistence(e) {
          let t = !1,
            n = !1;
          return (
            e && ((t = !!e.synchronizeTabs), (n = !!e.experimentalForceOwningTab), mp('synchronizeTabs', t, 'experimentalForceOwningTab', n)),
            t ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, n)
          );
        }
        clearPersistence() {
          return this._persistenceProvider.clearIndexedDbPersistence(this);
        }
        terminate() {
          return (
            this._appCompat && (this._appCompat._removeServiceInstance('firestore-compat'), this._appCompat._removeServiceInstance('firestore')),
            this._delegate._delete()
          );
        }
        waitForPendingWrites() {
          return zp(this._delegate);
        }
        onSnapshotsInSync(e) {
          return wm(this._delegate, e);
        }
        get app() {
          if (!this._appCompat) throw new li('failed-precondition', "Firestore was not initialized using the Firebase SDK. 'app' is not available");
          return this._appCompat;
        }
        collection(e) {
          try {
            return new nv(this, Cp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collection()', 'Firestore.collection()');
          }
        }
        doc(e) {
          try {
            return new Hm(this, Op(this._delegate, e));
          } catch (t) {
            throw Km(t, 'doc()', 'Firestore.doc()');
          }
        }
        collectionGroup(e) {
          try {
            return new Zm(this, kp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collectionGroup()', 'Firestore.collectionGroup()');
          }
        }
        runTransaction(e) {
          return Am(this._delegate, t => e(new zm(this, t)));
        }
        batch() {
          return Fp(this._delegate), new Gm(new Em(this._delegate, e => bm(this._delegate, e)));
        }
        loadBundle(e) {
          return Hp(this._delegate, e);
        }
        namedQuery(e) {
          return Kp(this._delegate, e).then(e => (e ? new Zm(this, e) : null));
        }
      }
      class $m extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Mm(new Yp(e));
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return Hm.forKey(t, this.firestore, null);
        }
      }
      function qm(e) {
        ei(e);
      }
      class zm {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t), (this._userDataWriter = new $m(e));
        }
        get(e) {
          const t = rv(e);
          return this._delegate
            .get(t)
            .then(
              e => new Xm(this._firestore, new nm(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, t.converter))
            );
        }
        set(e, t, n) {
          const r = rv(e);
          return n ? (Dm('Transaction.set', n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this;
        }
        update(e, t, n, ...r) {
          const i = rv(e);
          return 2 === arguments.length ? this._delegate.update(i, t) : this._delegate.update(i, t, n, ...r), this;
        }
        delete(e) {
          const t = rv(e);
          return this._delegate.delete(t), this;
        }
      }
      class Gm {
        constructor(e) {
          this._delegate = e;
        }
        set(e, t, n) {
          const r = rv(e);
          return n ? (Dm('WriteBatch.set', n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this;
        }
        update(e, t, n, ...r) {
          const i = rv(e);
          return 2 === arguments.length ? this._delegate.update(i, t) : this._delegate.update(i, t, n, ...r), this;
        }
        delete(e) {
          const t = rv(e);
          return this._delegate.delete(t), this;
        }
        commit() {
          return this._delegate.commit();
        }
      }
      class Wm {
        constructor(e, t, n) {
          (this._firestore = e), (this._userDataWriter = t), (this._delegate = n);
        }
        fromFirestore(e, t) {
          const n = new rm(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, null);
          return this._delegate.fromFirestore(new Jm(this._firestore, n), null !== t && void 0 !== t ? t : {});
        }
        toFirestore(e, t) {
          return t ? this._delegate.toFirestore(e, t) : this._delegate.toFirestore(e);
        }
        static getInstance(e, t) {
          const n = Wm.INSTANCES;
          let r = n.get(e);
          r || ((r = new WeakMap()), n.set(e, r));
          let i = r.get(t);
          return i || ((i = new Wm(e, new $m(e), t)), r.set(t, i)), i;
        }
      }
      Wm.INSTANCES = new WeakMap();
      class Hm {
        constructor(e, t) {
          (this.firestore = e), (this._delegate = t), (this._userDataWriter = new $m(e));
        }
        static forPath(e, t, n) {
          if (e.length % 2 !== 0)
            throw new li(
              'invalid-argument',
              `Invalid document reference. Document references must have an even number of segments, but ${e.canonicalString()} has ${e.length}`
            );
          return new Hm(t, new Tp(t._delegate, n, new Ni(e)));
        }
        static forKey(e, t, n) {
          return new Hm(t, new Tp(t._delegate, n, e));
        }
        get id() {
          return this._delegate.id;
        }
        get parent() {
          return new nv(this.firestore, this._delegate.parent);
        }
        get path() {
          return this._delegate.path;
        }
        collection(e) {
          try {
            return new nv(this.firestore, Cp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collection()', 'DocumentReference.collection()');
          }
        }
        isEqual(e) {
          return (e = (0, u.m9)(e)), e instanceof Tp && Np(this._delegate, e);
        }
        set(e, t) {
          t = Dm('DocumentReference.set', t);
          try {
            return t ? pm(this._delegate, e, t) : pm(this._delegate, e);
          } catch (n) {
            throw Km(n, 'setDoc()', 'DocumentReference.set()');
          }
        }
        update(e, t, ...n) {
          try {
            return 1 === arguments.length ? gm(this._delegate, e) : gm(this._delegate, e, t, ...n);
          } catch (r) {
            throw Km(r, 'updateDoc()', 'DocumentReference.update()');
          }
        }
        delete() {
          return mm(this._delegate);
        }
        onSnapshot(...e) {
          const t = Qm(e),
            n = Ym(
              e,
              e =>
                new Xm(
                  this.firestore,
                  new nm(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter)
                )
            );
          return ym(this._delegate, t, n);
        }
        get(e) {
          let t;
          return (
            (t =
              'cache' === (null === e || void 0 === e ? void 0 : e.source)
                ? cm(this._delegate)
                : 'server' === (null === e || void 0 === e ? void 0 : e.source)
                  ? lm(this._delegate)
                  : am(this._delegate)),
            t.then(
              e =>
                new Xm(
                  this.firestore,
                  new nm(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter)
                )
            )
          );
        }
        withConverter(e) {
          return new Hm(this.firestore, e ? this._delegate.withConverter(Wm.getInstance(this.firestore, e)) : this._delegate.withConverter(null));
        }
      }
      function Km(e, t, n) {
        return (e.message = e.message.replace(t, n)), e;
      }
      function Qm(e) {
        for (const t of e) if ('object' === typeof t && !Fm(t)) return t;
        return {};
      }
      function Ym(e, t) {
        var n, r;
        let i;
        return (
          (i = Fm(e[0])
            ? e[0]
            : Fm(e[1])
              ? e[1]
              : 'function' === typeof e[0]
                ? { next: e[0], error: e[1], complete: e[2] }
                : { next: e[1], error: e[2], complete: e[3] }),
          {
            next: e => {
              i.next && i.next(t(e));
            },
            error: null === (n = i.error) || void 0 === n ? void 0 : n.bind(i),
            complete: null === (r = i.complete) || void 0 === r ? void 0 : r.bind(i)
          }
        );
      }
      class Xm {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t);
        }
        get ref() {
          return new Hm(this._firestore, this._delegate.ref);
        }
        get id() {
          return this._delegate.id;
        }
        get metadata() {
          return this._delegate.metadata;
        }
        get exists() {
          return this._delegate.exists();
        }
        data(e) {
          return this._delegate.data(e);
        }
        get(e, t) {
          return this._delegate.get(e, t);
        }
        isEqual(e) {
          return sm(this._delegate, e._delegate);
        }
      }
      class Jm extends Xm {
        data(e) {
          const t = this._delegate.data(e);
          return ai(void 0 !== t, 'Document in a QueryDocumentSnapshot should exist'), t;
        }
      }
      class Zm {
        constructor(e, t) {
          (this.firestore = e), (this._delegate = t), (this._userDataWriter = new $m(e));
        }
        where(e, t, n) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Dg(e, t, n)));
          } catch (r) {
            throw Km(r, /(orderBy|where)\(\)/, 'Query.$1()');
          }
        }
        orderBy(e, t) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Mg(e, t)));
          } catch (n) {
            throw Km(n, /(orderBy|where)\(\)/, 'Query.$1()');
          }
        }
        limit(e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Ug(e)));
          } catch (t) {
            throw Km(t, 'limit()', 'Query.limit()');
          }
        }
        limitToLast(e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Vg(e)));
          } catch (t) {
            throw Km(t, 'limitToLast()', 'Query.limitToLast()');
          }
        }
        startAt(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, $g(...e)));
          } catch (t) {
            throw Km(t, 'startAt()', 'Query.startAt()');
          }
        }
        startAfter(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, qg(...e)));
          } catch (t) {
            throw Km(t, 'startAfter()', 'Query.startAfter()');
          }
        }
        endBefore(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Gg(...e)));
          } catch (t) {
            throw Km(t, 'endBefore()', 'Query.endBefore()');
          }
        }
        endAt(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Wg(...e)));
          } catch (t) {
            throw Km(t, 'endAt()', 'Query.endAt()');
          }
        }
        isEqual(e) {
          return Rp(this._delegate, e._delegate);
        }
        get(e) {
          let t;
          return (
            (t =
              'cache' === (null === e || void 0 === e ? void 0 : e.source)
                ? fm(this._delegate)
                : 'server' === (null === e || void 0 === e ? void 0 : e.source)
                  ? dm(this._delegate)
                  : hm(this._delegate)),
            t.then(e => new tv(this.firestore, new im(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot)))
          );
        }
        onSnapshot(...e) {
          const t = Qm(e),
            n = Ym(e, e => new tv(this.firestore, new im(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot)));
          return ym(this._delegate, t, n);
        }
        withConverter(e) {
          return new Zm(this.firestore, e ? this._delegate.withConverter(Wm.getInstance(this.firestore, e)) : this._delegate.withConverter(null));
        }
      }
      class ev {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t);
        }
        get type() {
          return this._delegate.type;
        }
        get doc() {
          return new Jm(this._firestore, this._delegate.doc);
        }
        get oldIndex() {
          return this._delegate.oldIndex;
        }
        get newIndex() {
          return this._delegate.newIndex;
        }
      }
      class tv {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t);
        }z
        get query() {
          return new Zm(this._firestore, this._delegate.query);
        }
        get metadata() {
          return this._delegate.metadata;
        }
        get size() {
          return this._delegate.size;
        }
        get empty() {
          return this._delegate.empty;
        }
        get docs() {
          return this._delegate.docs.map(e => new Jm(this._firestore, e));
        }
        docChanges(e) {
          return this._delegate.docChanges(e).map(e => new ev(this._firestore, e));
        }
        forEach(e, t) {
          this._delegate.forEach(n => {
            e.call(t, new Jm(this._firestore, n));
          });
        }
        isEqual(e) {
          return sm(this._delegate, e._delegate);
        }
      }
      class nv extends Zm {
        constructor(e, t) {
          super(e, t), (this.firestore = e), (this._delegate = t);
        }
        get id() {
          return this._delegate.id;
        }
        get path() {
          return this._delegate.path;
        }
        get parent() {
          const e = this._delegate.parent;
          return e ? new Hm(this.firestore, e) : null;
        }
        doc(e) {
