        if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
        if (e.byteLength < t + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
        var r;
        return (
          (r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n)),
          Object.setPrototypeOf(r, c.prototype),
          r
        );
      }
      function y(e) {
        if (c.isBuffer(e)) {
          var t = 0 | w(e.length),
            n = u(t);
          return 0 === n.length || e.copy(n, 0, 0, t), n;
        }
        return void 0 !== e.length
          ? 'number' !== typeof e.length || J(e.length)
            ? u(0)
            : g(e)
          : 'Buffer' === e.type && Array.isArray(e.data)
            ? g(e.data)
            : void 0;
      }
      function w(e) {
        if (e >= s) throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' + s.toString(16) + ' bytes');
        return 0 | e;
      }
      function b(e) {
        return +e != e && (e = 0), c.alloc(+e);
      }
      function _(e, t) {
        if (c.isBuffer(e)) return e.length;
        if (ArrayBuffer.isView(e) || X(e, ArrayBuffer)) return e.byteLength;
        if ('string' !== typeof e)
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
        var n = e.length,
          r = arguments.length > 2 && !0 === arguments[2];
        if (!r && 0 === n) return 0;
        for (var i = !1; ; )
          switch (t) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return n;
            case 'utf8':
            case 'utf-8':
              return W(e).length;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 2 * n;
            case 'hex':
              return n >>> 1;
            case 'base64':
              return Q(e).length;
            default:
              if (i) return r ? -1 : W(e).length;
              (t = ('' + t).toLowerCase()), (i = !0);
          }
      }
      function I(e, t, n) {
        var r = !1;
        if (((void 0 === t || t < 0) && (t = 0), t > this.length)) return '';
        if (((void 0 === n || n > this.length) && (n = this.length), n <= 0)) return '';
        if (((n >>>= 0), (t >>>= 0), n <= t)) return '';
        e || (e = 'utf8');
        while (1)
          switch (e) {
            case 'hex':
              return M(this, t, n);
            case 'utf8':
            case 'utf-8':
              return R(this, t, n);
            case 'ascii':
              return L(this, t, n);
            case 'latin1':
            case 'binary':
              return j(this, t, n);
            case 'base64':
              return N(this, t, n);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return F(this, t, n);
            default:
              if (r) throw new TypeError('Unknown encoding: ' + e);
              (e = (e + '').toLowerCase()), (r = !0);
          }
      }
      function E(e, t, n) {
        var r = e[t];
        (e[t] = e[n]), (e[n] = r);
      }
      function S(e, t, n, r, i) {
        if (0 === e.length) return -1;
        if (
          ('string' === typeof n ? ((r = n), (n = 0)) : n > 2147483647 ? (n = 2147483647) : n < -2147483648 && (n = -2147483648),
          (n = +n),
          J(n) && (n = i ? 0 : e.length - 1),
          n < 0 && (n = e.length + n),
          n >= e.length)
        ) {
          if (i) return -1;
          n = e.length - 1;
        } else if (n < 0) {
          if (!i) return -1;
          n = 0;
        }
        if (('string' === typeof t && (t = c.from(t, r)), c.isBuffer(t))) return 0 === t.length ? -1 : T(e, t, n, r, i);
        if ('number' === typeof t)
          return (
            (t &= 255),
            'function' === typeof Uint8Array.prototype.indexOf
              ? i
                ? Uint8Array.prototype.indexOf.call(e, t, n)
                : Uint8Array.prototype.lastIndexOf.call(e, t, n)
              : T(e, [t], n, r, i)
          );
        throw new TypeError('val must be string, number or Buffer');
      }
      function T(e, t, n, r, i) {
        var o,
          s = 1,
          a = e.length,
          u = t.length;
        if (void 0 !== r && ((r = String(r).toLowerCase()), 'ucs2' === r || 'ucs-2' === r || 'utf16le' === r || 'utf-16le' === r)) {
          if (e.length < 2 || t.length < 2) return -1;
          (s = 2), (a /= 2), (u /= 2), (n /= 2);
        }
        function c(e, t) {
          return 1 === s ? e[t] : e.readUInt16BE(t * s);
        }
        if (i) {
          var l = -1;
          for (o = n; o < a; o++)
            if (c(e, o) === c(t, -1 === l ? 0 : o - l)) {
              if ((-1 === l && (l = o), o - l + 1 === u)) return l * s;
            } else -1 !== l && (o -= o - l), (l = -1);
        } else
          for (n + u > a && (n = a - u), o = n; o >= 0; o--) {
            for (var h = !0, f = 0; f < u; f++)
              if (c(e, o + f) !== c(t, f)) {
                h = !1;
                break;
              }
            if (h) return o;
          }
        return -1;
      }
      function A(e, t, n, r) {
        n = Number(n) || 0;
        var i = e.length - n;
        r ? ((r = Number(r)), r > i && (r = i)) : (r = i);
        var o = t.length;
        r > o / 2 && (r = o / 2);
        for (var s = 0; s < r; ++s) {
          var a = parseInt(t.substr(2 * s, 2), 16);
          if (J(a)) return s;
          e[n + s] = a;
        }
        return s;
      }
      function x(e, t, n, r) {
        return Y(W(t, e.length - n), e, n, r);
      }
      function C(e, t, n, r) {
        return Y(H(t), e, n, r);
      }
      function k(e, t, n, r) {
        return Y(Q(t), e, n, r);
      }
      function O(e, t, n, r) {
        return Y(K(t, e.length - n), e, n, r);
      }
      function N(e, t, n) {
        return 0 === t && n === e.length ? r.fromByteArray(e) : r.fromByteArray(e.slice(t, n));
      }
      function R(e, t, n) {
        n = Math.min(e.length, n);
        var r = [],
          i = t;
        while (i < n) {
          var o,
            s,
            a,
            u,
            c = e[i],
            l = null,
            h = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
          if (i + h <= n)
            switch (h) {
              case 1:
                c < 128 && (l = c);
                break;
              case 2:
                (o = e[i + 1]), 128 === (192 & o) && ((u = ((31 & c) << 6) | (63 & o)), u > 127 && (l = u));
                break;
              case 3:
                (o = e[i + 1]),
                  (s = e[i + 2]),
                  128 === (192 & o) &&
                    128 === (192 & s) &&
                    ((u = ((15 & c) << 12) | ((63 & o) << 6) | (63 & s)), u > 2047 && (u < 55296 || u > 57343) && (l = u));
                break;
              case 4:
                (o = e[i + 1]),
                  (s = e[i + 2]),
                  (a = e[i + 3]),
                  128 === (192 & o) &&
                    128 === (192 & s) &&
                    128 === (192 & a) &&
                    ((u = ((15 & c) << 18) | ((63 & o) << 12) | ((63 & s) << 6) | (63 & a)), u > 65535 && u < 1114112 && (l = u));
            }
          null === l ? ((l = 65533), (h = 1)) : l > 65535 && ((l -= 65536), r.push(((l >>> 10) & 1023) | 55296), (l = 56320 | (1023 & l))),
            r.push(l),
            (i += h);
        }
        return D(r);
      }
      (t.kMaxLength = s),
        (c.TYPED_ARRAY_SUPPORT = a()),
        c.TYPED_ARRAY_SUPPORT ||
          'undefined' === typeof console ||
          'function' !== typeof console.error ||
          console.error(
            'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
          ),
        Object.defineProperty(c.prototype, 'parent', {
          enumerable: !0,
          get: function () {
            if (c.isBuffer(this)) return this.buffer;
          }
        }),
        Object.defineProperty(c.prototype, 'offset', {
          enumerable: !0,
          get: function () {
            if (c.isBuffer(this)) return this.byteOffset;
          }
        }),
        (c.poolSize = 8192),
        (c.from = function (e, t, n) {
          return l(e, t, n);
        }),
        Object.setPrototypeOf(c.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(c, Uint8Array),
        (c.alloc = function (e, t, n) {
          return f(e, t, n);
        }),
        (c.allocUnsafe = function (e) {
          return d(e);
        }),
        (c.allocUnsafeSlow = function (e) {
          return d(e);
        }),
        (c.isBuffer = function (e) {
          return null != e && !0 === e._isBuffer && e !== c.prototype;
        }),
        (c.compare = function (e, t) {
          if (
            (X(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)),
            X(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)),
            !c.isBuffer(e) || !c.isBuffer(t))
          )
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (e === t) return 0;
          for (var n = e.length, r = t.length, i = 0, o = Math.min(n, r); i < o; ++i)
            if (e[i] !== t[i]) {
              (n = e[i]), (r = t[i]);
              break;
            }
          return n < r ? -1 : r < n ? 1 : 0;
        }),
        (c.isEncoding = function (e) {
          switch (String(e).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return !0;
            default:
              return !1;
          }
        }),
        (c.concat = function (e, t) {
          if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === e.length) return c.alloc(0);
          var n;
          if (void 0 === t) for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
          var r = c.allocUnsafe(t),
            i = 0;
          for (n = 0; n < e.length; ++n) {
            var o = e[n];
            if (X(o, Uint8Array)) i + o.length > r.length ? c.from(o).copy(r, i) : Uint8Array.prototype.set.call(r, o, i);
            else {
              if (!c.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers');
              o.copy(r, i);
            }
            i += o.length;
          }
          return r;
        }),
        (c.byteLength = _),
        (c.prototype._isBuffer = !0),
        (c.prototype.swap16 = function () {
          var e = this.length;
          if (e % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
          for (var t = 0; t < e; t += 2) E(this, t, t + 1);
          return this;
        }),
        (c.prototype.swap32 = function () {
          var e = this.length;
          if (e % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
          for (var t = 0; t < e; t += 4) E(this, t, t + 3), E(this, t + 1, t + 2);
          return this;
        }),
        (c.prototype.swap64 = function () {
          var e = this.length;
          if (e % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
          for (var t = 0; t < e; t += 8) E(this, t, t + 7), E(this, t + 1, t + 6), E(this, t + 2, t + 5), E(this, t + 3, t + 4);
          return this;
        }),
        (c.prototype.toString = function () {
          var e = this.length;
          return 0 === e ? '' : 0 === arguments.length ? R(this, 0, e) : I.apply(this, arguments);
        }),
        (c.prototype.toLocaleString = c.prototype.toString),
        (c.prototype.equals = function (e) {
          if (!c.isBuffer(e)) throw new TypeError('Argument must be a Buffer');
          return this === e || 0 === c.compare(this, e);
        }),
        (c.prototype.inspect = function () {
          var e = '',
            n = t.INSPECT_MAX_BYTES;
          return (
            (e = this.toString('hex', 0, n)
              .replace(/(.{2})/g, '$1 ')
              .trim()),
            this.length > n && (e += ' ... '),
            '<Buffer ' + e + '>'
          );
        }),
        o && (c.prototype[o] = c.prototype.inspect),
        (c.prototype.compare = function (e, t, n, r, i) {
          if ((X(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)), !c.isBuffer(e)))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
          if (
            (void 0 === t && (t = 0),
            void 0 === n && (n = e ? e.length : 0),
            void 0 === r && (r = 0),
            void 0 === i && (i = this.length),
            t < 0 || n > e.length || r < 0 || i > this.length)
          )
            throw new RangeError('out of range index');
          if (r >= i && t >= n) return 0;
          if (r >= i) return -1;
          if (t >= n) return 1;
          if (((t >>>= 0), (n >>>= 0), (r >>>= 0), (i >>>= 0), this === e)) return 0;
          for (var o = i - r, s = n - t, a = Math.min(o, s), u = this.slice(r, i), l = e.slice(t, n), h = 0; h < a; ++h)
            if (u[h] !== l[h]) {
              (o = u[h]), (s = l[h]);
              break;
            }
          return o < s ? -1 : s < o ? 1 : 0;
        }),
        (c.prototype.includes = function (e, t, n) {
          return -1 !== this.indexOf(e, t, n);
        }),
        (c.prototype.indexOf = function (e, t, n) {
          return S(this, e, t, n, !0);
        }),
        (c.prototype.lastIndexOf = function (e, t, n) {
          return S(this, e, t, n, !1);
        }),
        (c.prototype.write = function (e, t, n, r) {
          if (void 0 === t) (r = 'utf8'), (n = this.length), (t = 0);
          else if (void 0 === n && 'string' === typeof t) (r = t), (n = this.length), (t = 0);
          else {
            if (!isFinite(t)) throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
            (t >>>= 0), isFinite(n) ? ((n >>>= 0), void 0 === r && (r = 'utf8')) : ((r = n), (n = void 0));
          }
          var i = this.length - t;
          if (((void 0 === n || n > i) && (n = i), (e.length > 0 && (n < 0 || t < 0)) || t > this.length))
            throw new RangeError('Attempt to write outside buffer bounds');
          r || (r = 'utf8');
          for (var o = !1; ; )
            switch (r) {
              case 'hex':
                return A(this, e, t, n);
              case 'utf8':
              case 'utf-8':
                return x(this, e, t, n);
