          this.hi = this.ii.enqueueAfterDelay('client_metadata_refresh', 4e3, () =>
            this.mi()
              .then(() => this.bi())
              .then(() => this.pi())
          );
        }
        Ri(e) {
          return !!e && e.ownerId === this.clientId;
        }
        Ei(e) {
          return this.oi
            ? zi.resolve(!0)
            : fh(e)
                .get('owner')
                .next(t => {
                  if (null !== t && this.Vi(t.leaseTimestampMs, 5e3) && !this.Ci(t.ownerId)) {
                    if (this.Ri(t) && this.networkEnabled) return !0;
                    if (!this.Ri(t)) {
                      if (!t.allowTabSynchronization) throw new li(ci.FAILED_PRECONDITION, lh);
                      return !1;
                    }
                  }
                  return (
                    !(!this.networkEnabled || !this.inForeground) ||
                    dh(e)
                      .j()
                      .next(
                        e =>
                          void 0 ===
                          this.Si(e, 5e3).find(e => {
                            if (this.clientId !== e.clientId) {
                              const t = !this.networkEnabled && e.networkEnabled,
                                n = !this.inForeground && e.inForeground,
                                r = this.networkEnabled === e.networkEnabled;
                              if (t || (n && r)) return !0;
                            }
                            return !1;
                          })
                      )
                  );
                })
                .next(e => (this.isPrimary !== e && ti('IndexedDbPersistence', `Client ${e ? 'is' : 'is not'} eligible for a primary lease.`), e));
        }
        async shutdown() {
          (this.Fs = !1),
            this.xi(),
            this.hi && (this.hi.cancel(), (this.hi = null)),
            this.Ni(),
            this.ki(),
            await this.wi.runTransaction('shutdown', 'readwrite', ['owner', 'clientMetadata'], e => {
              const t = new Do(e, no.ct);
              return this.Ai(t).next(() => this.Pi(t));
            }),
            this.wi.close(),
            this.Mi();
        }
        Si(e, t) {
          return e.filter(e => this.Vi(e.updateTimeMs, t) && !this.Ci(e.clientId));
        }
        $i() {
          return this.runTransaction('getActiveClients', 'readonly', e =>
            dh(e)
              .j()
              .next(e => this.Si(e, 18e5).map(e => e.clientId))
          );
        }
        get started() {
          return this.Fs;
        }
        getMutationQueue(e, t) {
          return El.de(e, this.serializer, t, this.referenceDelegate);
        }
        getTargetCache() {
          return this.Bs;
        }
        getRemoteDocumentCache() {
          return this.remoteDocumentCache;
        }
        getIndexManager(e) {
          return new dl(e, this.serializer.fe.databaseId);
        }
        getDocumentOverlayCache(e) {
          return $c.de(this.serializer, e);
        }
        getBundleCache() {
          return this.qs;
        }
        runTransaction(e, t, n) {
          ti('IndexedDbPersistence', 'Starting transaction:', e);
          const r = 'readonly' === t ? 'readonly' : 'readwrite',
            i = 15 === (o = this.ui) ? Po : 14 === o ? Ro : 13 === o ? No : 12 === o ? Oo : 11 === o ? ko : void oi();
          var o;
          let s;
          return this.wi
            .runTransaction(
              e,
              r,
              i,
              r => (
                (s = new Do(r, this.Os ? this.Os.next() : no.ct)),
                'readwrite-primary' === t
                  ? this.Ti(s)
                      .next(e => !!e || this.Ei(s))
                      .next(t => {
                        if (!t)
                          throw (
                            (ni(`Failed to obtain primary lease for action '${e}'.`),
                            (this.isPrimary = !1),
                            this.ii.enqueueRetryable(() => this.fi(!1)),
                            new li(ci.FAILED_PRECONDITION, Bi))
                          );
                        return n(s);
                      })
                      .next(e => this.vi(s).next(() => e))
                  : this.Oi(s).next(() => n(s))
              )
            )
            .then(e => (s.raiseOnCommittedEvent(), e));
        }
        Oi(e) {
          return fh(e)
            .get('owner')
            .next(e => {
              if (
                null !== e &&
                this.Vi(e.leaseTimestampMs, 5e3) &&
                !this.Ci(e.ownerId) &&
                !this.Ri(e) &&
                !(this.oi || (this.allowTabSynchronization && e.allowTabSynchronization))
              )
                throw new li(ci.FAILED_PRECONDITION, lh);
            });
        }
        vi(e) {
          const t = { ownerId: this.clientId, allowTabSynchronization: this.allowTabSynchronization, leaseTimestampMs: Date.now() };
          return fh(e).put('owner', t);
        }
        static D() {
          return Wi.D();
        }
        Ai(e) {
          const t = fh(e);
          return t.get('owner').next(e => (this.Ri(e) ? (ti('IndexedDbPersistence', 'Releasing primary lease.'), t.delete('owner')) : zi.resolve()));
        }
        Vi(e, t) {
          const n = Date.now();
          return !(e < n - t) && (!(e > n) || (ni(`Detected an update time that is in the future: ${e} > ${n}`), !1));
        }
        gi() {
          null !== this.document &&
            'function' == typeof this.document.addEventListener &&
            ((this.ai = () => {
              this.ii.enqueueAndForget(() => ((this.inForeground = 'visible' === this.document.visibilityState), this.mi()));
            }),
            this.document.addEventListener('visibilitychange', this.ai),
            (this.inForeground = 'visible' === this.document.visibilityState));
        }
        Ni() {
          this.ai && (this.document.removeEventListener('visibilitychange', this.ai), (this.ai = null));
        }
        yi() {
          var e;
          'function' == typeof (null === (e = this.window) || void 0 === e ? void 0 : e.addEventListener) &&
            ((this.ci = () => {
              this.xi();
              const e = /(?:Version|Mobile)\/1[456]/;
              (0, u.G6)() && (navigator.appVersion.match(e) || navigator.userAgent.match(e)) && this.ii.enterRestrictedMode(!0),
                this.ii.enqueueAndForget(() => this.shutdown());
            }),
            this.window.addEventListener('pagehide', this.ci));
        }
        ki() {
          this.ci && (this.window.removeEventListener('pagehide', this.ci), (this.ci = null));
        }
        Ci(e) {
          var t;
          try {
            const n = null !== (null === (t = this._i) || void 0 === t ? void 0 : t.getItem(this.Di(e)));
            return ti('IndexedDbPersistence', `Client '${e}' ${n ? 'is' : 'is not'} zombied in LocalStorage`), n;
          } catch (e) {
            return ni('IndexedDbPersistence', 'Failed to get zombied client id.', e), !1;
          }
        }
        xi() {
          if (this._i)
            try {
              this._i.setItem(this.Di(this.clientId), String(Date.now()));
            } catch (e) {
              ni('Failed to set zombie client id.', e);
            }
        }
        Mi() {
          if (this._i)
            try {
              this._i.removeItem(this.Di(this.clientId));
            } catch (e) {}
        }
        Di(e) {
          return `firestore_zombie_${this.persistenceKey}_${e}`;
        }
      }
      function fh(e) {
        return Lo(e, 'owner');
      }
      function dh(e) {
        return Lo(e, 'clientMetadata');
      }
      function ph(e, t) {
        let n = e.projectId;
        return e.isDefaultDatabase || (n += '.' + e.database), 'firestore/' + t + '/' + n + '/';
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class gh {
        constructor(e, t, n, r) {
          (this.targetId = e), (this.fromCache = t), (this.Fi = n), (this.Bi = r);
        }
        static Li(e, t) {
          let n = La(),
            r = La();
          for (const i of t.docChanges)
            switch (i.type) {
              case 0:
                n = n.add(i.doc.key);
                break;
              case 1:
                r = r.add(i.doc.key);
            }
          return new gh(e, t.fromCache, n, r);
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class mh {
        constructor() {
          this.qi = !1;
        }
        initialize(e, t) {
          (this.Ui = e), (this.indexManager = t), (this.qi = !0);
        }
        getDocumentsMatchingQuery(e, t, n, r) {
          return this.Ki(e, t)
            .next(i => i || this.Gi(e, t, r, n))
            .next(n => n || this.Qi(e, t));
        }
        Ki(e, t) {
          if (ca(t)) return zi.resolve(null);
          let n = pa(t);
          return this.indexManager.getIndexType(e, n).next(r =>
            0 === r
              ? null
              : (null !== t.limit && 1 === r && ((t = ma(t, null, 'F')), (n = pa(t))),
                this.indexManager.getDocumentsMatchingTarget(e, n).next(r => {
                  const i = La(...r);
                  return this.Ui.getDocuments(e, i).next(r =>
                    this.indexManager.getMinOffset(e, n).next(n => {
                      const o = this.ji(t, r);
                      return this.zi(t, o, i, n.readTime) ? this.Ki(e, ma(t, null, 'F')) : this.Wi(e, o, t, n);
                    })
                  );
                }))
          );
        }
        Gi(e, t, n, r) {
          return ca(t) || r.isEqual(Ai.min())
            ? this.Qi(e, t)
            : this.Ui.getDocuments(e, n).next(i => {
                const o = this.ji(t, i);
                return this.zi(t, o, n, r)
                  ? this.Qi(e, t)
                  : (Zr() <= a['in'].DEBUG && ti('QueryEngine', 'Re-using previous result from %s to execute query: %s', r.toString(), wa(t)),
                    this.Wi(e, o, t, Mi(r, -1)));
              });
        }
        ji(e, t) {
          let n = new $o(Ia(e));
          return (
            t.forEach((t, r) => {
              ba(e, r) && (n = n.add(r));
            }),
            n
          );
        }
        zi(e, t, n, r) {
          if (null === e.limit) return !1;
          if (n.size !== t.size) return !0;
          const i = 'F' === e.limitType ? t.last() : t.first();
          return !!i && (i.hasPendingWrites || i.version.compareTo(r) > 0);
        }
        Qi(e, t) {
          return (
            Zr() <= a['in'].DEBUG && ti('QueryEngine', 'Using full collection scan to execute query:', wa(t)),
            this.Ui.getDocumentsMatchingQuery(e, t, Ui.min())
          );
        }
        Wi(e, t, n, r) {
          return this.Ui.getDocumentsMatchingQuery(e, n, r).next(
            e => (
              t.forEach(t => {
                e = e.insert(t.key, t);
              }),
              e
            )
          );
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class vh {
        constructor(e, t, n, r) {
          (this.persistence = e),
            (this.Hi = t),
            (this.serializer = r),
            (this.Ji = new Uo(Ii)),
            (this.Yi = new Sa(e => ea(e), ta)),
            (this.Xi = new Map()),
            (this.Zi = e.getRemoteDocumentCache()),
            (this.Bs = e.getTargetCache()),
            (this.qs = e.getBundleCache()),
            this.tr(n);
        }
        tr(e) {
          (this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e)),
            (this.indexManager = this.persistence.getIndexManager(e)),
            (this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager)),
            (this.localDocuments = new Yl(this.Zi, this.mutationQueue, this.documentOverlayCache, this.indexManager)),
            this.Zi.setIndexManager(this.indexManager),
            this.Hi.initialize(this.localDocuments, this.indexManager);
        }
        collectGarbage(e) {
          return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', t => e.collect(t, this.Ji));
        }
      }
      function yh(e, t, n, r) {
        return new vh(e, t, n, r);
      }
      async function wh(e, t) {
        const n = ui(e);
        return await n.persistence.runTransaction('Handle user change', 'readonly', e => {
          let r;
          return n.mutationQueue
            .getAllMutationBatches(e)
            .next(i => ((r = i), n.tr(t), n.mutationQueue.getAllMutationBatches(e)))
            .next(t => {
              const i = [],
                o = [];
              let s = La();
              for (const e of r) {
                i.push(e.batchId);
                for (const t of e.mutations) s = s.add(t.key);
              }
              for (const e of t) {
                o.push(e.batchId);
                for (const t of e.mutations) s = s.add(t.key);
              }
              return n.localDocuments.getDocuments(e, s).next(e => ({ er: e, removedBatchIds: i, addedBatchIds: o }));
            });
        });
      }
      function bh(e, t) {
        const n = ui(e);
        return n.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', e => {
          const r = t.batch.keys(),
            i = n.Zi.newChangeBuffer({ trackRemovals: !0 });
          return (function (e, t, n, r) {
            const i = n.batch,
              o = i.keys();
            let s = zi.resolve();
            return (
              o.forEach(e => {
                s = s
                  .next(() => r.getEntry(t, e))
                  .next(t => {
                    const o = n.docVersions.get(e);
                    si(null !== o),
                      t.version.compareTo(o) < 0 &&
                        (i.applyToRemoteDocument(t, n), t.isValidDocument() && (t.setReadTime(n.commitVersion), r.addEntry(t)));
                  });
              }),
              s.next(() => e.mutationQueue.removeMutationBatch(t, i))
            );
          })(n, e, t, i)
            .next(() => i.apply(e))
            .next(() => n.mutationQueue.performConsistencyCheck(e))
            .next(() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t.batch.batchId))
            .next(() =>
              n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(
                e,
                (function (e) {
                  let t = La();
                  for (let n = 0; n < e.mutationResults.length; ++n)
                    e.mutationResults[n].transformResults.length > 0 && (t = t.add(e.batch.mutations[n].key));
                  return t;
                })(t)
              )
            )
            .next(() => n.localDocuments.getDocuments(e, r));
        });
      }
      function _h(e) {
        const t = ui(e);
        return t.persistence.runTransaction('Get last remote snapshot version', 'readonly', e => t.Bs.getLastRemoteSnapshotVersion(e));
      }
      function Ih(e, t) {
        const n = ui(e),
          r = t.snapshotVersion;
        let i = n.Ji;
        return n.persistence
          .runTransaction('Apply remote event', 'readwrite-primary', e => {
            const o = n.Zi.newChangeBuffer({ trackRemovals: !0 });
            i = n.Ji;
            const s = [];
            t.targetChanges.forEach((o, a) => {
              const u = i.get(a);
              if (!u) return;
              s.push(n.Bs.removeMatchingKeys(e, o.removedDocuments, a).next(() => n.Bs.addMatchingKeys(e, o.addedDocuments, a)));
              let c = u.withSequenceNumber(e.currentSequenceNumber);
              null !== t.targetMismatches.get(a)
                ? (c = c.withResumeToken(Ko.EMPTY_BYTE_STRING, Ai.min()).withLastLimboFreeSnapshotVersion(Ai.min()))
                : o.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(o.resumeToken, r)),
                (i = i.insert(a, c)),
                (function (e, t, n) {
                  return (
                    0 === e.resumeToken.approximateByteSize() ||
                    t.snapshotVersion.toMicroseconds() - e.snapshotVersion.toMicroseconds() >= 3e8 ||
                    n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size > 0
                  );
                })(u, c, o) && s.push(n.Bs.updateTargetData(e, c));
            });
            let a = Aa(),
              u = La();
            if (
              (t.documentUpdates.forEach(r => {
                t.resolvedLimboDocuments.has(r) && s.push(n.persistence.referenceDelegate.updateLimboDocument(e, r));
              }),
              s.push(
                Eh(e, o, t.documentUpdates).next(e => {
                  (a = e.nr), (u = e.sr);
                })
              ),
              !r.isEqual(Ai.min()))
            ) {
              const t = n.Bs.getLastRemoteSnapshotVersion(e).next(t => n.Bs.setTargetsMetadata(e, e.currentSequenceNumber, r));
              s.push(t);
            }
            return zi
              .waitFor(s)
              .next(() => o.apply(e))
              .next(() => n.localDocuments.getLocalViewOfDocuments(e, a, u))
              .next(() => a);
          })
          .then(e => ((n.Ji = i), e));
      }
      function Eh(e, t, n) {
        let r = La(),
          i = La();
        return (
          n.forEach(e => (r = r.add(e))),
          t.getEntries(e, r).next(e => {
            let r = Aa();
