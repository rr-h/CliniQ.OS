            return (
              n.forEach((n, o) => {
                const s = e.get(n);
                o.isFoundDocument() !== s.isFoundDocument() && (i = i.add(n)),
                  o.isNoDocument() && o.version.isEqual(Ai.min())
                    ? (t.removeEntry(n, o.readTime), (r = r.insert(n, o)))
                    : !s.isValidDocument() || o.version.compareTo(s.version) > 0 || (0 === o.version.compareTo(s.version) && s.hasPendingWrites)
                      ? (t.addEntry(o), (r = r.insert(n, o)))
                      : ti('LocalStore', 'Ignoring outdated watch update for ', n, '. Current version:', s.version, ' Watch version:', o.version);
              }),
              { nr: r, sr: i }
            );
          })
        );
      }
      function Sh(e, t) {
        const n = ui(e);
        return n.persistence.runTransaction(
          'Get next mutation batch',
          'readonly',
          e => (void 0 === t && (t = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(e, t))
        );
      }
      function Th(e, t) {
        const n = ui(e);
        return n.persistence
          .runTransaction('Allocate target', 'readwrite', e => {
            let r;
            return n.Bs.getTargetData(e, t).next(i =>
              i
                ? ((r = i), zi.resolve(r))
                : n.Bs.allocateTargetId(e).next(
                    i => ((r = new Tc(t, i, 'TargetPurposeListen', e.currentSequenceNumber)), n.Bs.addTargetData(e, r).next(() => r))
                  )
            );
          })
          .then(e => {
            const r = n.Ji.get(e.targetId);
            return (
              (null === r || e.snapshotVersion.compareTo(r.snapshotVersion) > 0) && ((n.Ji = n.Ji.insert(e.targetId, e)), n.Yi.set(t, e.targetId)), e
            );
          });
      }
      async function Ah(e, t, n) {
        const r = ui(e),
          i = r.Ji.get(t),
          o = n ? 'readwrite' : 'readwrite-primary';
        try {
          n || (await r.persistence.runTransaction('Release target', o, e => r.persistence.referenceDelegate.removeTarget(e, i)));
        } catch (e) {
          if (!Qi(e)) throw e;
          ti('LocalStore', `Failed to update sequence numbers for target ${t}: ${e}`);
        }
        (r.Ji = r.Ji.remove(t)), r.Yi.delete(i.target);
      }
      function xh(e, t, n) {
        const r = ui(e);
        let i = Ai.min(),
          o = La();
        return r.persistence.runTransaction('Execute query', 'readonly', e =>
          (function (e, t, n) {
            const r = ui(e),
              i = r.Yi.get(n);
            return void 0 !== i ? zi.resolve(r.Ji.get(i)) : r.Bs.getTargetData(t, n);
          })(r, e, pa(t))
            .next(t => {
              if (t)
                return (
                  (i = t.lastLimboFreeSnapshotVersion),
                  r.Bs.getMatchingKeysForTargetId(e, t.targetId).next(e => {
                    o = e;
                  })
                );
            })
            .next(() => r.Hi.getDocumentsMatchingQuery(e, t, n ? i : Ai.min(), n ? o : La()))
            .next(e => (Oh(r, _a(t), e), { documents: e, ir: o }))
        );
      }
      function Ch(e, t) {
        const n = ui(e),
          r = ui(n.Bs),
          i = n.Ji.get(t);
        return i
          ? Promise.resolve(i.target)
          : n.persistence.runTransaction('Get target data', 'readonly', e => r.le(e, t).next(e => (e ? e.target : null)));
      }
      function kh(e, t) {
        const n = ui(e),
          r = n.Xi.get(t) || Ai.min();
        return n.persistence
          .runTransaction('Get new document changes', 'readonly', e => n.Zi.getAllFromCollectionGroup(e, t, Mi(r, -1), Number.MAX_SAFE_INTEGER))
          .then(e => (Oh(n, t, e), e));
      }
      function Oh(e, t, n) {
        let r = e.Xi.get(t) || Ai.min();
        n.forEach((e, t) => {
          t.readTime.compareTo(r) > 0 && (r = t.readTime);
        }),
          e.Xi.set(t, r);
      }
      async function Nh(e, t, n, r) {
        const i = ui(e);
        let o = La(),
          s = Aa();
        for (const c of n) {
          const e = t.rr(c.metadata.name);
          c.document && (o = o.add(e));
          const n = t.ur(c);
          n.setReadTime(t.cr(c.metadata.readTime)), (s = s.insert(e, n));
        }
        const a = i.Zi.newChangeBuffer({ trackRemovals: !0 }),
          u = await Th(
            i,
            (function (e) {
              return pa(ua(Ci.fromString(`__bundle__/docs/${e}`)));
            })(r)
          );
        return i.persistence.runTransaction('Apply bundle documents', 'readwrite', e =>
          Eh(e, a, s)
            .next(t => (a.apply(e), t))
            .next(t =>
              i.Bs.removeMatchingKeysForTargetId(e, u.targetId)
                .next(() => i.Bs.addMatchingKeys(e, o, u.targetId))
                .next(() => i.localDocuments.getLocalViewOfDocuments(e, t.nr, t.sr))
                .next(() => t.nr)
            )
        );
      }
      async function Rh(e, t, n = La()) {
        const r = await Th(e, pa(Lc(t.bundledQuery))),
          i = ui(e);
        return i.persistence.runTransaction('Save named query', 'readwrite', e => {
          const o = Yu(t.readTime);
          if (r.snapshotVersion.compareTo(o) >= 0) return i.qs.saveNamedQuery(e, t);
          const s = r.withResumeToken(Ko.EMPTY_BYTE_STRING, o);
          return (
            (i.Ji = i.Ji.insert(s.targetId, s)),
            i.Bs.updateTargetData(e, s)
              .next(() => i.Bs.removeMatchingKeysForTargetId(e, r.targetId))
              .next(() => i.Bs.addMatchingKeys(e, n, r.targetId))
              .next(() => i.qs.saveNamedQuery(e, t))
          );
        });
      }
      function Ph(e, t) {
        return `firestore_clients_${e}_${t}`;
      }
      function Dh(e, t, n) {
        let r = `firestore_mutations_${e}_${n}`;
        return t.isAuthenticated() && (r += `_${t.uid}`), r;
      }
      function Lh(e, t) {
        return `firestore_targets_${e}_${t}`;
      }
      class jh {
        constructor(e, t, n, r) {
          (this.user = e), (this.batchId = t), (this.state = n), (this.error = r);
        }
        static ar(e, t, n) {
          const r = JSON.parse(n);
          let i,
            o =
              'object' == typeof r &&
              -1 !== ['pending', 'acknowledged', 'rejected'].indexOf(r.state) &&
              (void 0 === r.error || 'object' == typeof r.error);
          return (
            o &&
              r.error &&
              ((o = 'string' == typeof r.error.message && 'string' == typeof r.error.code), o && (i = new li(r.error.code, r.error.message))),
            o ? new jh(e, t, r.state, i) : (ni('SharedClientState', `Failed to parse mutation state for ID '${t}': ${n}`), null)
          );
        }
        hr() {
          const e = { state: this.state, updateTimeMs: Date.now() };
          return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e);
        }
      }
      class Mh {
        constructor(e, t, n) {
          (this.targetId = e), (this.state = t), (this.error = n);
        }
        static ar(e, t) {
          const n = JSON.parse(t);
          let r,
            i =
              'object' == typeof n &&
              -1 !== ['not-current', 'current', 'rejected'].indexOf(n.state) &&
              (void 0 === n.error || 'object' == typeof n.error);
          return (
            i &&
              n.error &&
              ((i = 'string' == typeof n.error.message && 'string' == typeof n.error.code), i && (r = new li(n.error.code, n.error.message))),
            i ? new Mh(e, n.state, r) : (ni('SharedClientState', `Failed to parse target state for ID '${e}': ${t}`), null)
          );
        }
        hr() {
          const e = { state: this.state, updateTimeMs: Date.now() };
          return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e);
        }
      }
      class Fh {
        constructor(e, t) {
          (this.clientId = e), (this.activeTargetIds = t);
        }
        static ar(e, t) {
          const n = JSON.parse(t);
          let r = 'object' == typeof n && n.activeTargetIds instanceof Array,
            i = Ma();
          for (let o = 0; r && o < n.activeTargetIds.length; ++o) (r = oo(n.activeTargetIds[o])), (i = i.add(n.activeTargetIds[o]));
          return r ? new Fh(e, i) : (ni('SharedClientState', `Failed to parse client data for instance '${e}': ${t}`), null);
        }
      }
      class Uh {
        constructor(e, t) {
          (this.clientId = e), (this.onlineState = t);
        }
        static ar(e) {
          const t = JSON.parse(e);
          return 'object' == typeof t && -1 !== ['Unknown', 'Online', 'Offline'].indexOf(t.onlineState) && 'string' == typeof t.clientId
            ? new Uh(t.clientId, t.onlineState)
            : (ni('SharedClientState', `Failed to parse online state: ${e}`), null);
        }
      }
      class Vh {
        constructor() {
          this.activeTargetIds = Ma();
        }
        lr(e) {
          this.activeTargetIds = this.activeTargetIds.add(e);
        }
        dr(e) {
          this.activeTargetIds = this.activeTargetIds.delete(e);
        }
        hr() {
          const e = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() };
          return JSON.stringify(e);
        }
      }
      class Bh {
        constructor(e, t, n, r, i) {
          (this.window = e),
            (this.ii = t),
            (this.persistenceKey = n),
            (this.wr = r),
            (this.syncEngine = null),
            (this.onlineStateHandler = null),
            (this.sequenceNumberHandler = null),
            (this._r = this.mr.bind(this)),
            (this.gr = new Uo(Ii)),
            (this.started = !1),
            (this.yr = []);
          const o = n.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          (this.storage = this.window.localStorage),
            (this.currentUser = i),
            (this.pr = Ph(this.persistenceKey, this.wr)),
            (this.Ir = (function (e) {
              return `firestore_sequence_number_${e}`;
            })(
              /**
               * @license
               * Copyright 2018 Google LLC
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *   http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */ this.persistenceKey
            )),
            (this.gr = this.gr.insert(this.wr, new Vh())),
            (this.Tr = new RegExp(`^firestore_clients_${o}_([^_]*)$`)),
            (this.Er = new RegExp(`^firestore_mutations_${o}_(\\d+)(?:_(.*))?$`)),
            (this.Ar = new RegExp(`^firestore_targets_${o}_(\\d+)$`)),
            (this.vr = (function (e) {
              return `firestore_online_state_${e}`;
            })(this.persistenceKey)),
            (this.Rr = (function (e) {
              return `firestore_bundle_loaded_v2_${e}`;
            })(this.persistenceKey)),
            this.window.addEventListener('storage', this._r);
        }
        static D(e) {
          return !(!e || !e.localStorage);
        }
        async start() {
          const e = await this.syncEngine.$i();
          for (const n of e) {
            if (n === this.wr) continue;
            const e = this.getItem(Ph(this.persistenceKey, n));
            if (e) {
              const t = Fh.ar(n, e);
              t && (this.gr = this.gr.insert(t.clientId, t));
            }
          }
          this.Pr();
          const t = this.storage.getItem(this.vr);
          if (t) {
            const e = this.br(t);
            e && this.Vr(e);
          }
          for (const n of this.yr) this.mr(n);
          (this.yr = []), this.window.addEventListener('pagehide', () => this.shutdown()), (this.started = !0);
        }
        writeSequenceNumber(e) {
          this.setItem(this.Ir, JSON.stringify(e));
        }
        getAllActiveQueryTargets() {
          return this.Sr(this.gr);
        }
        isActiveQueryTarget(e) {
          let t = !1;
          return (
            this.gr.forEach((n, r) => {
              r.activeTargetIds.has(e) && (t = !0);
            }),
            t
          );
        }
        addPendingMutation(e) {
          this.Dr(e, 'pending');
        }
        updateMutationState(e, t, n) {
          this.Dr(e, t, n), this.Cr(e);
        }
        addLocalQueryTarget(e) {
          let t = 'not-current';
          if (this.isActiveQueryTarget(e)) {
            const n = this.storage.getItem(Lh(this.persistenceKey, e));
            if (n) {
              const r = Mh.ar(e, n);
              r && (t = r.state);
            }
          }
          return this.Nr.lr(e), this.Pr(), t;
        }
        removeLocalQueryTarget(e) {
          this.Nr.dr(e), this.Pr();
        }
        isLocalQueryTarget(e) {
          return this.Nr.activeTargetIds.has(e);
        }
        clearQueryState(e) {
          this.removeItem(Lh(this.persistenceKey, e));
        }
        updateQueryState(e, t, n) {
          this.kr(e, t, n);
        }
        handleUserChange(e, t, n) {
          t.forEach(e => {
            this.Cr(e);
          }),
            (this.currentUser = e),
            n.forEach(e => {
              this.addPendingMutation(e);
            });
        }
        setOnlineState(e) {
          this.Mr(e);
        }
        notifyBundleLoaded(e) {
          this.$r(e);
        }
        shutdown() {
          this.started && (this.window.removeEventListener('storage', this._r), this.removeItem(this.pr), (this.started = !1));
        }
        getItem(e) {
          const t = this.storage.getItem(e);
          return ti('SharedClientState', 'READ', e, t), t;
        }
        setItem(e, t) {
          ti('SharedClientState', 'SET', e, t), this.storage.setItem(e, t);
        }
        removeItem(e) {
          ti('SharedClientState', 'REMOVE', e), this.storage.removeItem(e);
        }
        mr(e) {
          const t = e;
          if (t.storageArea === this.storage) {
            if ((ti('SharedClientState', 'EVENT', t.key, t.newValue), t.key === this.pr))
              return void ni('Received WebStorage notification for local change. Another client might have garbage-collected our state');
            this.ii.enqueueRetryable(async () => {
              if (this.started) {
                if (null !== t.key)
                  if (this.Tr.test(t.key)) {
                    if (null == t.newValue) {
                      const e = this.Or(t.key);
                      return this.Fr(e, null);
                    }
                    {
                      const e = this.Br(t.key, t.newValue);
                      if (e) return this.Fr(e.clientId, e);
                    }
                  } else if (this.Er.test(t.key)) {
                    if (null !== t.newValue) {
                      const e = this.Lr(t.key, t.newValue);
                      if (e) return this.qr(e);
                    }
                  } else if (this.Ar.test(t.key)) {
                    if (null !== t.newValue) {
                      const e = this.Ur(t.key, t.newValue);
                      if (e) return this.Kr(e);
                    }
                  } else if (t.key === this.vr) {
                    if (null !== t.newValue) {
                      const e = this.br(t.newValue);
                      if (e) return this.Vr(e);
                    }
                  } else if (t.key === this.Ir) {
                    const e = (function (e) {
                      let t = no.ct;
                      if (null != e)
                        try {
                          const n = JSON.parse(e);
                          si('number' == typeof n), (t = n);
                        } catch (e) {
                          ni('SharedClientState', 'Failed to read sequence number from WebStorage', e);
                        }
                      return t;
                    })(t.newValue);
                    e !== no.ct && this.sequenceNumberHandler(e);
                  } else if (t.key === this.Rr) {
                    const e = this.Gr(t.newValue);
                    await Promise.all(e.map(e => this.syncEngine.Qr(e)));
                  }
              } else this.yr.push(t);
            });
          }
        }
        get Nr() {
          return this.gr.get(this.wr);
        }
        Pr() {
          this.setItem(this.pr, this.Nr.hr());
        }
        Dr(e, t, n) {
          const r = new jh(this.currentUser, e, t, n),
            i = Dh(this.persistenceKey, this.currentUser, e);
          this.setItem(i, r.hr());
        }
        Cr(e) {
          const t = Dh(this.persistenceKey, this.currentUser, e);
          this.removeItem(t);
        }
        Mr(e) {
          const t = { clientId: this.wr, onlineState: e };
          this.storage.setItem(this.vr, JSON.stringify(t));
        }
        kr(e, t, n) {
          const r = Lh(this.persistenceKey, e),
            i = new Mh(e, t, n);
          this.setItem(r, i.hr());
        }
        $r(e) {
          const t = JSON.stringify(Array.from(e));
          this.setItem(this.Rr, t);
        }
        Or(e) {
          const t = this.Tr.exec(e);
          return t ? t[1] : null;
        }
        Br(e, t) {
          const n = this.Or(e);
          return Fh.ar(n, t);
        }
        Lr(e, t) {
          const n = this.Er.exec(e),
            r = Number(n[1]),
            i = void 0 !== n[2] ? n[2] : null;
          return jh.ar(new Yr(i), r, t);
        }
        Ur(e, t) {
          const n = this.Ar.exec(e),
            r = Number(n[1]);
          return Mh.ar(r, t);
        }
        br(e) {
          return Uh.ar(e);
        }
        Gr(e) {
          return JSON.parse(e);
        }
        async qr(e) {
          if (e.user.uid === this.currentUser.uid) return this.syncEngine.jr(e.batchId, e.state, e.error);
          ti('SharedClientState', `Ignoring mutation for non-active user ${e.user.uid}`);
        }
        Kr(e) {
          return this.syncEngine.zr(e.targetId, e.state, e.error);
        }
        Fr(e, t) {
          const n = t ? this.gr.insert(e, t) : this.gr.remove(e),
            r = this.Sr(this.gr),
            i = this.Sr(n),
            o = [],
            s = [];
