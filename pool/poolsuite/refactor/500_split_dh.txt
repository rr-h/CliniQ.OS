          (this.Pt = e), (this.removedTargetIds = t), (this.key = n), (this.bt = r);
        }
      }
      class ju {
        constructor(e, t) {
          (this.targetId = e), (this.Vt = t);
        }
      }
      class Mu {
        constructor(e, t, n = Ko.EMPTY_BYTE_STRING, r = null) {
          (this.state = e), (this.targetIds = t), (this.resumeToken = n), (this.cause = r);
        }
      }
      class Fu {
        constructor() {
          (this.St = 0), (this.Dt = Bu()), (this.Ct = Ko.EMPTY_BYTE_STRING), (this.xt = !1), (this.Nt = !0);
        }
        get current() {
          return this.xt;
        }
        get resumeToken() {
          return this.Ct;
        }
        get kt() {
          return 0 !== this.St;
        }
        get Mt() {
          return this.Nt;
        }
        $t(e) {
          e.approximateByteSize() > 0 && ((this.Nt = !0), (this.Ct = e));
        }
        Ot() {
          let e = La(),
            t = La(),
            n = La();
          return (
            this.Dt.forEach((r, i) => {
              switch (i) {
                case 0:
                  e = e.add(r);
                  break;
                case 2:
                  t = t.add(r);
                  break;
                case 1:
                  n = n.add(r);
                  break;
                default:
                  oi();
              }
            }),
            new Du(this.Ct, this.xt, e, t, n)
          );
        }
        Ft() {
          (this.Nt = !1), (this.Dt = Bu());
        }
        Bt(e, t) {
          (this.Nt = !0), (this.Dt = this.Dt.insert(e, t));
        }
        Lt(e) {
          (this.Nt = !0), (this.Dt = this.Dt.remove(e));
        }
        qt() {
          this.St += 1;
        }
        Ut() {
          this.St -= 1;
        }
        Kt() {
          (this.Nt = !0), (this.xt = !0);
        }
      }
      class Uu {
        constructor(e) {
          (this.Gt = e), (this.Qt = new Map()), (this.jt = Aa()), (this.zt = Vu()), (this.Wt = new Uo(Ii));
        }
        Ht(e) {
          for (const t of e.Pt) e.bt && e.bt.isFoundDocument() ? this.Jt(t, e.bt) : this.Yt(t, e.key, e.bt);
          for (const t of e.removedTargetIds) this.Yt(t, e.key, e.bt);
        }
        Xt(e) {
          this.forEachTarget(e, t => {
            const n = this.Zt(t);
            switch (e.state) {
              case 0:
                this.te(t) && n.$t(e.resumeToken);
                break;
              case 1:
                n.Ut(), n.kt || n.Ft(), n.$t(e.resumeToken);
                break;
              case 2:
                n.Ut(), n.kt || this.removeTarget(t);
                break;
              case 3:
                this.te(t) && (n.Kt(), n.$t(e.resumeToken));
                break;
              case 4:
                this.te(t) && (this.ee(t), n.$t(e.resumeToken));
                break;
              default:
                oi();
            }
          });
        }
        forEachTarget(e, t) {
          e.targetIds.length > 0
            ? e.targetIds.forEach(t)
            : this.Qt.forEach((e, n) => {
                this.te(n) && t(n);
              });
        }
        ne(e) {
          var t;
          const n = e.targetId,
            r = e.Vt.count,
            i = this.se(n);
          if (i) {
            const o = i.target;
            if (na(o))
              if (0 === r) {
                const e = new Ni(o.path);
                this.Yt(n, e, xs.newNoDocument(e, Ai.min()));
              } else si(1 === r);
            else {
              const i = this.ie(n);
              if (i !== r) {
                const r = this.re(e, i);
                if (0 !== r) {
                  this.ee(n);
                  const e = 2 === r ? 'TargetPurposeExistenceFilterMismatchBloom' : 'TargetPurposeExistenceFilterMismatch';
                  this.Wt = this.Wt.insert(n, e);
                }
                null === (t = Tu.instance) ||
                  void 0 === t ||
                  t.notifyOnExistenceFilterMismatch(
                    (function (e, t, n) {
                      var r, i, o, s, a, u;
                      const c = { localCacheCount: t, existenceFilterCount: n.count },
                        l = n.unchangedNames;
                      return (
                        l &&
                          (c.bloomFilter = {
                            applied: 0 === e,
                            hashCount: null !== (r = null == l ? void 0 : l.hashCount) && void 0 !== r ? r : 0,
                            bitmapLength:
                              null !==
                                (s =
                                  null === (o = null === (i = null == l ? void 0 : l.bits) || void 0 === i ? void 0 : i.bitmap) || void 0 === o
                                    ? void 0
                                    : o.length) && void 0 !== s
                                ? s
                                : 0,
                            padding:
                              null !== (u = null === (a = null == l ? void 0 : l.bits) || void 0 === a ? void 0 : a.padding) && void 0 !== u ? u : 0
                          }),
                        c
                      );
                    })(
                      /**
                       * @license
                       * Copyright 2017 Google LLC
                       *
                       * Licensed under the Apache License, Version 2.0 (the "License");
                       * you may not use this file except in compliance with the License.
                       * You may obtain a copy of the License at
                       *
                       *   http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */ r,
                      i,
                      e.Vt
                    )
                  );
              }
            }
          }
        }
        re(e, t) {
          const { unchangedNames: n, count: r } = e.Vt;
          if (!n || !n.bits) return 1;
          const {
            bits: { bitmap: i = '', padding: o = 0 },
            hashCount: s = 0
          } = n;
          let a, u;
          try {
            a = Jo(i).toUint8Array();
          } catch (e) {
            if (e instanceof Wo)
              return (
                ri(
                  'Decoding the base64 bloom filter in existence filter failed (' +
                    e.message +
                    '); ignoring the bloom filter and falling back to full re-query.'
                ),
                1
              );
            throw e;
          }
          try {
            u = new Nu(a, o, s);
          } catch (e) {
            return ri(e instanceof Ru ? 'BloomFilter error: ' : 'Applying bloom filter failed: ', e), 1;
          }
          return 0 === u.It ? 1 : r !== t - this.oe(e.targetId, u) ? 2 : 0;
        }
        oe(e, t) {
          const n = this.Gt.getRemoteKeysForTarget(e);
          let r = 0;
          return (
            n.forEach(n => {
              const i = this.Gt.ue(),
                o = `projects/${i.projectId}/databases/${i.database}/documents/${n.path.canonicalString()}`;
              t.vt(o) || (this.Yt(e, n, null), r++);
            }),
            r
          );
        }
        ce(e) {
          const t = new Map();
          this.Qt.forEach((n, r) => {
            const i = this.se(r);
            if (i) {
              if (n.current && na(i.target)) {
                const t = new Ni(i.target.path);
                null !== this.jt.get(t) || this.ae(r, t) || this.Yt(r, t, xs.newNoDocument(t, e));
              }
              n.Mt && (t.set(r, n.Ot()), n.Ft());
            }
          });
          let n = La();
          this.zt.forEach((e, t) => {
            let r = !0;
            t.forEachWhile(e => {
              const t = this.se(e);
              return !t || 'TargetPurposeLimboResolution' === t.purpose || ((r = !1), !1);
            }),
              r && (n = n.add(e));
          }),
            this.jt.forEach((t, n) => n.setReadTime(e));
          const r = new Pu(e, t, this.Wt, this.jt, n);
          return (this.jt = Aa()), (this.zt = Vu()), (this.Wt = new Uo(Ii)), r;
        }
        Jt(e, t) {
          if (!this.te(e)) return;
          const n = this.ae(e, t.key) ? 2 : 0;
          this.Zt(e).Bt(t.key, n), (this.jt = this.jt.insert(t.key, t)), (this.zt = this.zt.insert(t.key, this.he(t.key).add(e)));
        }
        Yt(e, t, n) {
          if (!this.te(e)) return;
          const r = this.Zt(e);
          this.ae(e, t) ? r.Bt(t, 1) : r.Lt(t), (this.zt = this.zt.insert(t, this.he(t).delete(e))), n && (this.jt = this.jt.insert(t, n));
        }
        removeTarget(e) {
          this.Qt.delete(e);
        }
        ie(e) {
          const t = this.Zt(e).Ot();
          return this.Gt.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size;
        }
        qt(e) {
          this.Zt(e).qt();
        }
        Zt(e) {
          let t = this.Qt.get(e);
          return t || ((t = new Fu()), this.Qt.set(e, t)), t;
        }
        he(e) {
          let t = this.zt.get(e);
          return t || ((t = new $o(Ii)), (this.zt = this.zt.insert(e, t))), t;
        }
        te(e) {
          const t = null !== this.se(e);
          return t || ti('WatchChangeAggregator', 'Detected inactive target', e), t;
        }
        se(e) {
          const t = this.Qt.get(e);
          return t && t.kt ? null : this.Gt.le(e);
        }
        ee(e) {
          this.Qt.set(e, new Fu()),
            this.Gt.getRemoteKeysForTarget(e).forEach(t => {
              this.Yt(e, t, null);
            });
        }
        ae(e, t) {
          return this.Gt.getRemoteKeysForTarget(e).has(t);
        }
      }
      function Vu() {
        return new Uo(Ni.comparator);
      }
      function Bu() {
        return new Uo(Ni.comparator);
      }
      const $u = (() => {
          const e = { asc: 'ASCENDING', desc: 'DESCENDING' };
          return e;
        })(),
        qu = (() => {
          const e = {
            '<': 'LESS_THAN',
            '<=': 'LESS_THAN_OR_EQUAL',
            '>': 'GREATER_THAN',
            '>=': 'GREATER_THAN_OR_EQUAL',
            '==': 'EQUAL',
            '!=': 'NOT_EQUAL',
            'array-contains': 'ARRAY_CONTAINS',
            in: 'IN',
            'not-in': 'NOT_IN',
            'array-contains-any': 'ARRAY_CONTAINS_ANY'
          };
          return e;
        })(),
        zu = (() => {
          const e = { and: 'AND', or: 'OR' };
          return e;
        })();
      class Gu {
        constructor(e, t) {
          (this.databaseId = e), (this.useProto3Json = t);
        }
      }
      function Wu(e, t) {
        return e.useProto3Json || ro(t) ? t : { value: t };
      }
      function Hu(e, t) {
        return e.useProto3Json
          ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, '').replace('Z', '')}.${('000000000' + t.nanoseconds).slice(-9)}Z`
          : { seconds: '' + t.seconds, nanos: t.nanoseconds };
      }
      function Ku(e, t) {
        return e.useProto3Json ? t.toBase64() : t.toUint8Array();
      }
      function Qu(e, t) {
        return Hu(e, t.toTimestamp());
      }
      function Yu(e) {
        return (
          si(!!e),
          Ai.fromTimestamp(
            (function (e) {
              const t = Yo(e);
              return new Ti(t.seconds, t.nanos);
            })(e)
          )
        );
      }
      function Xu(e, t) {
        return (function (e) {
          return new Ci(['projects', e.projectId, 'databases', e.database]);
        })(e)
          .child('documents')
          .child(t)
          .canonicalString();
      }
      function Ju(e) {
        const t = Ci.fromString(e);
        return si(Sc(t)), t;
      }
      function Zu(e, t) {
        return Xu(e.databaseId, t.path);
      }
      function ec(e, t) {
        const n = Ju(t);
        if (n.get(1) !== e.databaseId.projectId)
          throw new li(ci.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' + n.get(1) + ' vs ' + e.databaseId.projectId);
        if (n.get(3) !== e.databaseId.database)
          throw new li(ci.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' + n.get(3) + ' vs ' + e.databaseId.database);
        return new Ni(ic(n));
      }
      function tc(e, t) {
        return Xu(e.databaseId, t);
      }
      function nc(e) {
        const t = Ju(e);
        return 4 === t.length ? Ci.emptyPath() : ic(t);
      }
      function rc(e) {
        return new Ci(['projects', e.databaseId.projectId, 'databases', e.databaseId.database]).canonicalString();
      }
      function ic(e) {
        return si(e.length > 4 && 'documents' === e.get(4)), e.popFirst(5);
      }
      function oc(e, t, n) {
        return { name: Zu(e, t), fields: n.value.mapValue.fields };
      }
      function sc(e, t, n) {
        const r = ec(e, t.name),
          i = Yu(t.updateTime),
          o = t.createTime ? Yu(t.createTime) : Ai.min(),
          s = new Ts({ mapValue: { fields: t.fields } }),
          a = xs.newFoundDocument(r, i, o, s);
        return n && a.setHasCommittedMutations(), n ? a.setHasCommittedMutations() : a;
      }
      function ac(e, t) {
        return 'found' in t
          ? (function (e, t) {
              si(!!t.found), t.found.name, t.found.updateTime;
              const n = ec(e, t.found.name),
                r = Yu(t.found.updateTime),
                i = t.found.createTime ? Yu(t.found.createTime) : Ai.min(),
                o = new Ts({ mapValue: { fields: t.found.fields } });
              return xs.newFoundDocument(n, r, i, o);
            })(e, t)
          : 'missing' in t
            ? (function (e, t) {
                si(!!t.missing), si(!!t.readTime);
                const n = ec(e, t.missing),
                  r = Yu(t.readTime);
                return xs.newNoDocument(n, r);
              })(e, t)
            : oi();
      }
      function uc(e, t) {
        let n;
        if ('targetChange' in t) {
          t.targetChange;
          const r = (function (e) {
              return 'NO_CHANGE' === e ? 0 : 'ADD' === e ? 1 : 'REMOVE' === e ? 2 : 'CURRENT' === e ? 3 : 'RESET' === e ? 4 : oi();
            })(t.targetChange.targetChangeType || 'NO_CHANGE'),
            i = t.targetChange.targetIds || [],
            o = (function (e, t) {
              return e.useProto3Json
                ? (si(void 0 === t || 'string' == typeof t), Ko.fromBase64String(t || ''))
                : (si(void 0 === t || t instanceof Uint8Array), Ko.fromUint8Array(t || new Uint8Array()));
            })(e, t.targetChange.resumeToken),
            s = t.targetChange.cause,
            a =
              s &&
              (function (e) {
                const t = void 0 === e.code ? ci.UNKNOWN : Su(e.code);
                return new li(t, e.message || '');
              })(s);
          n = new Mu(r, i, o, a || null);
        } else if ('documentChange' in t) {
          t.documentChange;
          const r = t.documentChange;
          r.document, r.document.name, r.document.updateTime;
          const i = ec(e, r.document.name),
            o = Yu(r.document.updateTime),
            s = r.document.createTime ? Yu(r.document.createTime) : Ai.min(),
            a = new Ts({ mapValue: { fields: r.document.fields } }),
            u = xs.newFoundDocument(i, o, s, a),
            c = r.targetIds || [],
            l = r.removedTargetIds || [];
          n = new Lu(c, l, u.key, u);
        } else if ('documentDelete' in t) {
          t.documentDelete;
          const r = t.documentDelete;
          r.document;
          const i = ec(e, r.document),
            o = r.readTime ? Yu(r.readTime) : Ai.min(),
            s = xs.newNoDocument(i, o),
            a = r.removedTargetIds || [];
          n = new Lu([], a, s.key, s);
        } else if ('documentRemove' in t) {
          t.documentRemove;
          const r = t.documentRemove;
          r.document;
          const i = ec(e, r.document),
            o = r.removedTargetIds || [];
          n = new Lu([], o, i, null);
        } else {
          if (!('filter' in t)) return oi();
          {
            t.filter;
            const e = t.filter;
            e.targetId;
            const { count: r = 0, unchangedNames: i } = e,
              o = new bu(r, i),
              s = e.targetId;
            n = new ju(s, o);
          }
        }
        return n;
      }
      function cc(e, t) {
        let n;
        if (t instanceof lu) n = { update: oc(e, t.key, t.value) };
        else if (t instanceof gu) n = { delete: Zu(e, t.key) };
        else if (t instanceof hu) n = { update: oc(e, t.key, t.data), updateMask: Ec(t.fieldMask) };
        else {
          if (!(t instanceof mu)) return oi();
          n = { verify: Zu(e, t.key) };
        }
        return (
          t.fieldTransforms.length > 0 &&
            (n.updateTransforms = t.fieldTransforms.map(e =>
              (function (e, t) {
                const n = t.transform;
                if (n instanceof Ga) return { fieldPath: t.field.canonicalString(), setToServerValue: 'REQUEST_TIME' };
                if (n instanceof Wa) return { fieldPath: t.field.canonicalString(), appendMissingElements: { values: n.elements } };
