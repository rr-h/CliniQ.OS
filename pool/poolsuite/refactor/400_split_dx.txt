          let e = 0;
          return {
            next: () => (e < this.binaryString.length ? { value: this.binaryString.charCodeAt(e++), done: !1 } : { value: void 0, done: !0 })
          };
        }
        toBase64() {
          return (e = this.binaryString), btoa(e);
          var e;
        }
        toUint8Array() {
          return (function (e) {
            const t = new Uint8Array(e.length);
            for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
            return t;
          })(
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ this.binaryString
          );
        }
        approximateByteSize() {
          return 2 * this.binaryString.length;
        }
        compareTo(e) {
          return Ii(this.binaryString, e.binaryString);
        }
        isEqual(e) {
          return this.binaryString === e.binaryString;
        }
      }
      Ko.EMPTY_BYTE_STRING = new Ko('');
      const Qo = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
      function Yo(e) {
        if ((si(!!e), 'string' == typeof e)) {
          let t = 0;
          const n = Qo.exec(e);
          if ((si(!!n), n[1])) {
            let e = n[1];
            (e = (e + '000000000').substr(0, 9)), (t = Number(e));
          }
          const r = new Date(e);
          return { seconds: Math.floor(r.getTime() / 1e3), nanos: t };
        }
        return { seconds: Xo(e.seconds), nanos: Xo(e.nanos) };
      }
      function Xo(e) {
        return 'number' == typeof e ? e : 'string' == typeof e ? Number(e) : 0;
      }
      function Jo(e) {
        return 'string' == typeof e ? Ko.fromBase64String(e) : Ko.fromUint8Array(e);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Zo(e) {
        var t, n;
        return (
          'server_timestamp' ===
          (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {}).__type__) || void 0 === n
            ? void 0
            : n.stringValue)
        );
      }
      function es(e) {
        const t = e.mapValue.fields.__previous_value__;
        return Zo(t) ? es(t) : t;
      }
      function ts(e) {
        const t = Yo(e.mapValue.fields.__local_write_time__.timestampValue);
        return new Ti(t.seconds, t.nanos);
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ns {
        constructor(e, t, n, r, i, o, s, a, u) {
          (this.databaseId = e),
            (this.appId = t),
            (this.persistenceKey = n),
            (this.host = r),
            (this.ssl = i),
            (this.forceLongPolling = o),
            (this.autoDetectLongPolling = s),
            (this.longPollingOptions = a),
            (this.useFetchStreams = u);
        }
      }
      class rs {
        constructor(e, t) {
          (this.projectId = e), (this.database = t || '(default)');
        }
        static empty() {
          return new rs('', '');
        }
        get isDefaultDatabase() {
          return '(default)' === this.database;
        }
        isEqual(e) {
          return e instanceof rs && e.projectId === this.projectId && e.database === this.database;
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const is = { mapValue: { fields: { __type__: { stringValue: '__max__' } } } },
        os = { nullValue: 'NULL_VALUE' };
      function ss(e) {
        return 'nullValue' in e
          ? 0
          : 'booleanValue' in e
            ? 1
            : 'integerValue' in e || 'doubleValue' in e
              ? 2
              : 'timestampValue' in e
                ? 3
                : 'stringValue' in e
                  ? 5
                  : 'bytesValue' in e
                    ? 6
                    : 'referenceValue' in e
                      ? 7
                      : 'geoPointValue' in e
                        ? 8
                        : 'arrayValue' in e
                          ? 9
                          : 'mapValue' in e
                            ? Zo(e)
                              ? 4
                              : bs(e)
                                ? 9007199254740991
                                : 10
                            : oi();
      }
      function as(e, t) {
        if (e === t) return !0;
        const n = ss(e);
        if (n !== ss(t)) return !1;
        switch (n) {
          case 0:
          case 9007199254740991:
            return !0;
          case 1:
            return e.booleanValue === t.booleanValue;
          case 4:
            return ts(e).isEqual(ts(t));
          case 3:
            return (function (e, t) {
              if ('string' == typeof e.timestampValue && 'string' == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length)
                return e.timestampValue === t.timestampValue;
              const n = Yo(e.timestampValue),
                r = Yo(t.timestampValue);
              return n.seconds === r.seconds && n.nanos === r.nanos;
            })(e, t);
          case 5:
            return e.stringValue === t.stringValue;
          case 6:
            return (function (e, t) {
              return Jo(e.bytesValue).isEqual(Jo(t.bytesValue));
            })(e, t);
          case 7:
            return e.referenceValue === t.referenceValue;
          case 8:
            return (function (e, t) {
              return Xo(e.geoPointValue.latitude) === Xo(t.geoPointValue.latitude) && Xo(e.geoPointValue.longitude) === Xo(t.geoPointValue.longitude);
            })(e, t);
          case 2:
            return (function (e, t) {
              if ('integerValue' in e && 'integerValue' in t) return Xo(e.integerValue) === Xo(t.integerValue);
              if ('doubleValue' in e && 'doubleValue' in t) {
                const n = Xo(e.doubleValue),
                  r = Xo(t.doubleValue);
                return n === r ? io(n) === io(r) : isNaN(n) && isNaN(r);
              }
              return !1;
            })(e, t);
          case 9:
            return Ei(e.arrayValue.values || [], t.arrayValue.values || [], as);
          case 10:
            return (function (e, t) {
              const n = e.mapValue.fields || {},
                r = t.mapValue.fields || {};
              if (jo(n) !== jo(r)) return !1;
              for (const i in n) if (n.hasOwnProperty(i) && (void 0 === r[i] || !as(n[i], r[i]))) return !1;
              return !0;
            })(e, t);
          default:
            return oi();
        }
      }
      function us(e, t) {
        return void 0 !== (e.values || []).find(e => as(e, t));
      }
      function cs(e, t) {
        if (e === t) return 0;
        const n = ss(e),
          r = ss(t);
        if (n !== r) return Ii(n, r);
        switch (n) {
          case 0:
          case 9007199254740991:
            return 0;
          case 1:
            return Ii(e.booleanValue, t.booleanValue);
          case 2:
            return (function (e, t) {
              const n = Xo(e.integerValue || e.doubleValue),
                r = Xo(t.integerValue || t.doubleValue);
              return n < r ? -1 : n > r ? 1 : n === r ? 0 : isNaN(n) ? (isNaN(r) ? 0 : -1) : 1;
            })(e, t);
          case 3:
            return ls(e.timestampValue, t.timestampValue);
          case 4:
            return ls(ts(e), ts(t));
          case 5:
            return Ii(e.stringValue, t.stringValue);
          case 6:
            return (function (e, t) {
              const n = Jo(e),
                r = Jo(t);
              return n.compareTo(r);
            })(e.bytesValue, t.bytesValue);
          case 7:
            return (function (e, t) {
              const n = e.split('/'),
                r = t.split('/');
              for (let i = 0; i < n.length && i < r.length; i++) {
                const e = Ii(n[i], r[i]);
                if (0 !== e) return e;
              }
              return Ii(n.length, r.length);
            })(e.referenceValue, t.referenceValue);
          case 8:
            return (function (e, t) {
              const n = Ii(Xo(e.latitude), Xo(t.latitude));
              return 0 !== n ? n : Ii(Xo(e.longitude), Xo(t.longitude));
            })(e.geoPointValue, t.geoPointValue);
          case 9:
            return (function (e, t) {
              const n = e.values || [],
                r = t.values || [];
              for (let i = 0; i < n.length && i < r.length; ++i) {
                const e = cs(n[i], r[i]);
                if (e) return e;
              }
              return Ii(n.length, r.length);
            })(e.arrayValue, t.arrayValue);
          case 10:
            return (function (e, t) {
              if (e === is.mapValue && t === is.mapValue) return 0;
              if (e === is.mapValue) return 1;
              if (t === is.mapValue) return -1;
              const n = e.fields || {},
                r = Object.keys(n),
                i = t.fields || {},
                o = Object.keys(i);
              r.sort(), o.sort();
              for (let s = 0; s < r.length && s < o.length; ++s) {
                const e = Ii(r[s], o[s]);
                if (0 !== e) return e;
                const t = cs(n[r[s]], i[o[s]]);
                if (0 !== t) return t;
              }
              return Ii(r.length, o.length);
            })(e.mapValue, t.mapValue);
          default:
            throw oi();
        }
      }
      function ls(e, t) {
        if ('string' == typeof e && 'string' == typeof t && e.length === t.length) return Ii(e, t);
        const n = Yo(e),
          r = Yo(t),
          i = Ii(n.seconds, r.seconds);
        return 0 !== i ? i : Ii(n.nanos, r.nanos);
      }
      function hs(e) {
        return fs(e);
      }
      function fs(e) {
        return 'nullValue' in e
          ? 'null'
          : 'booleanValue' in e
            ? '' + e.booleanValue
            : 'integerValue' in e
              ? '' + e.integerValue
              : 'doubleValue' in e
                ? '' + e.doubleValue
                : 'timestampValue' in e
                  ? (function (e) {
                      const t = Yo(e);
                      return `time(${t.seconds},${t.nanos})`;
                    })(e.timestampValue)
                  : 'stringValue' in e
                    ? e.stringValue
                    : 'bytesValue' in e
                      ? Jo(e.bytesValue).toBase64()
                      : 'referenceValue' in e
                        ? ((n = e.referenceValue), Ni.fromName(n).toString())
                        : 'geoPointValue' in e
                          ? `geo(${(t = e.geoPointValue).latitude},${t.longitude})`
                          : 'arrayValue' in e
                            ? (function (e) {
                                let t = '[',
                                  n = !0;
                                for (const r of e.values || []) n ? (n = !1) : (t += ','), (t += fs(r));
                                return t + ']';
                              })(e.arrayValue)
                            : 'mapValue' in e
                              ? (function (e) {
                                  const t = Object.keys(e.fields || {}).sort();
                                  let n = '{',
                                    r = !0;
                                  for (const i of t) r ? (r = !1) : (n += ','), (n += `${i}:${fs(e.fields[i])}`);
                                  return n + '}';
                                })(e.mapValue)
                              : oi();
        var t, n;
      }
      function ds(e, t) {
        return { referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}` };
      }
      function ps(e) {
        return !!e && 'integerValue' in e;
      }
      function gs(e) {
        return !!e && 'arrayValue' in e;
      }
      function ms(e) {
        return !!e && 'nullValue' in e;
      }
      function vs(e) {
        return !!e && 'doubleValue' in e && isNaN(Number(e.doubleValue));
      }
      function ys(e) {
        return !!e && 'mapValue' in e;
      }
      function ws(e) {
        if (e.geoPointValue) return { geoPointValue: Object.assign({}, e.geoPointValue) };
        if (e.timestampValue && 'object' == typeof e.timestampValue) return { timestampValue: Object.assign({}, e.timestampValue) };
        if (e.mapValue) {
          const t = { mapValue: { fields: {} } };
          return Mo(e.mapValue.fields, (e, n) => (t.mapValue.fields[e] = ws(n))), t;
        }
        if (e.arrayValue) {
          const t = { arrayValue: { values: [] } };
          for (let n = 0; n < (e.arrayValue.values || []).length; ++n) t.arrayValue.values[n] = ws(e.arrayValue.values[n]);
          return t;
        }
        return Object.assign({}, e);
      }
      function bs(e) {
