              .then(e => (r.raiseOnCommittedEvent(), e))
          );
        }
        Gs(e, t) {
          return zi.or(Object.values(this.$s).map(n => () => n.containsKey(e, t)));
        }
      }
      class sh extends $i {
        constructor(e) {
          super(), (this.currentSequenceNumber = e);
        }
      }
      class ah {
        constructor(e) {
          (this.persistence = e), (this.Qs = new Zl()), (this.js = null);
        }
        static zs(e) {
          return new ah(e);
        }
        get Ws() {
          if (this.js) return this.js;
          throw oi();
        }
        addReference(e, t, n) {
          return this.Qs.addReference(n, t), this.Ws.delete(n.toString()), zi.resolve();
        }
        removeReference(e, t, n) {
          return this.Qs.removeReference(n, t), this.Ws.add(n.toString()), zi.resolve();
        }
        markPotentiallyOrphaned(e, t) {
          return this.Ws.add(t.toString()), zi.resolve();
        }
        removeTarget(e, t) {
          this.Qs.Is(t.targetId).forEach(e => this.Ws.add(e.toString()));
          const n = this.persistence.getTargetCache();
          return n
            .getMatchingKeysForTargetId(e, t.targetId)
            .next(e => {
              e.forEach(e => this.Ws.add(e.toString()));
            })
            .next(() => n.removeTargetData(e, t));
        }
        Us() {
          this.js = new Set();
        }
        Ks(e) {
          const t = this.persistence.getRemoteDocumentCache().newChangeBuffer();
          return zi
            .forEach(this.Ws, n => {
              const r = Ni.fromPath(n);
              return this.Hs(e, r).next(e => {
                e || t.removeEntry(r, Ai.min());
              });
            })
            .next(() => ((this.js = null), t.apply(e)));
        }
        updateLimboDocument(e, t) {
          return this.Hs(e, t).next(e => {
            e ? this.Ws.delete(t.toString()) : this.Ws.add(t.toString());
          });
        }
        Ls(e) {
          return 0;
        }
        Hs(e, t) {
          return zi.or([
            () => zi.resolve(this.Qs.containsKey(t)),
            () => this.persistence.getTargetCache().containsKey(e, t),
            () => this.persistence.Gs(e, t)
          ]);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class uh {
        constructor(e) {
          this.serializer = e;
        }
        O(e, t, n, r) {
          const i = new Gi('createOrUpgrade', t);
          n < 1 &&
            r >= 1 &&
            ((function (e) {
              e.createObjectStore('owner');
            })(e),
            (function (e) {
              e.createObjectStore('mutationQueues', { keyPath: 'userId' }),
                e.createObjectStore('mutations', { keyPath: 'batchId', autoIncrement: !0 }).createIndex('userMutationsIndex', lo, { unique: !0 }),
                e.createObjectStore('documentMutations');
            })(e),
            ch(e),
            (function (e) {
              e.createObjectStore('remoteDocuments');
            })(e));
          let o = zi.resolve();
          return (
            n < 3 &&
              r >= 3 &&
              (0 !== n &&
                ((function (e) {
                  e.deleteObjectStore('targetDocuments'), e.deleteObjectStore('targets'), e.deleteObjectStore('targetGlobal');
                })(e),
                ch(e)),
              (o = o.next(() =>
                (function (e) {
                  const t = e.store('targetGlobal'),
                    n = { highestTargetId: 0, highestListenSequenceNumber: 0, lastRemoteSnapshotVersion: Ai.min().toTimestamp(), targetCount: 0 };
                  return t.put('targetGlobalKey', n);
                })(i)
              ))),
            n < 4 &&
              r >= 4 &&
              (0 !== n &&
                (o = o.next(() =>
                  (function (e, t) {
                    return t
                      .store('mutations')
                      .j()
                      .next(n => {
                        e.deleteObjectStore('mutations'),
                          e
                            .createObjectStore('mutations', { keyPath: 'batchId', autoIncrement: !0 })
                            .createIndex('userMutationsIndex', lo, { unique: !0 });
                        const r = t.store('mutations'),
                          i = n.map(e => r.put(e));
                        return zi.waitFor(i);
                      });
                  })(e, i)
                )),
              (o = o.next(() => {
                !(function (e) {
                  e.createObjectStore('clientMetadata', { keyPath: 'clientId' });
                })(e);
              }))),
            n < 5 && r >= 5 && (o = o.next(() => this.Ys(i))),
            n < 6 &&
              r >= 6 &&
              (o = o.next(
                () => (
                  (function (e) {
                    e.createObjectStore('remoteDocumentGlobal');
                  })(e),
                  this.Xs(i)
                )
              )),
            n < 7 && r >= 7 && (o = o.next(() => this.Zs(i))),
            n < 8 && r >= 8 && (o = o.next(() => this.ti(e, i))),
            n < 9 &&
              r >= 9 &&
              (o = o.next(() => {
                !(function (e) {
                  e.objectStoreNames.contains('remoteDocumentChanges') && e.deleteObjectStore('remoteDocumentChanges');
                })(e);
              })),
            n < 10 && r >= 10 && (o = o.next(() => this.ei(i))),
            n < 11 &&
              r >= 11 &&
              (o = o.next(() => {
                !(function (e) {
                  e.createObjectStore('bundles', { keyPath: 'bundleId' });
                })(e),
                  (function (e) {
                    e.createObjectStore('namedQueries', { keyPath: 'name' });
                  })(e);
              })),
            n < 12 &&
              r >= 12 &&
              (o = o.next(() => {
                !(function (e) {
                  const t = e.createObjectStore('documentOverlays', { keyPath: Ao });
                  t.createIndex('collectionPathOverlayIndex', xo, { unique: !1 }), t.createIndex('collectionGroupOverlayIndex', Co, { unique: !1 });
                })(e);
              })),
            n < 13 &&
              r >= 13 &&
              (o = o
                .next(() =>
                  (function (e) {
                    const t = e.createObjectStore('remoteDocumentsV14', { keyPath: go });
                    t.createIndex('documentKeyIndex', mo), t.createIndex('collectionGroupIndex', vo);
                  })(e)
                )
                .next(() => this.ni(e, i))
                .next(() => e.deleteObjectStore('remoteDocuments'))),
            n < 14 && r >= 14 && (o = o.next(() => this.si(e, i))),
            n < 15 &&
              r >= 15 &&
              (o = o.next(() =>
                (function (e) {
                  e
                    .createObjectStore('indexConfiguration', { keyPath: 'indexId', autoIncrement: !0 })
                    .createIndex('collectionGroupIndex', 'collectionGroup', { unique: !1 }),
                    e.createObjectStore('indexState', { keyPath: Io }).createIndex('sequenceNumberIndex', Eo, { unique: !1 }),
                    e.createObjectStore('indexEntries', { keyPath: So }).createIndex('documentKeyIndex', To, { unique: !1 });
                })(e)
              )),
            o
          );
        }
        Xs(e) {
          let t = 0;
          return e
            .store('remoteDocuments')
            .X((e, n) => {
              t += Il(n);
            })
            .next(() => {
              const n = { byteSize: t };
              return e.store('remoteDocumentGlobal').put('remoteDocumentGlobalKey', n);
            });
        }
        Ys(e) {
          const t = e.store('mutationQueues'),
            n = e.store('mutations');
          return t.j().next(t =>
            zi.forEach(t, t => {
              const r = IDBKeyRange.bound([t.userId, -1], [t.userId, t.lastAcknowledgedBatchId]);
              return n.j('userMutationsIndex', r).next(n =>
                zi.forEach(n, n => {
                  si(n.userId === t.userId);
                  const r = Rc(this.serializer, n);
                  return _l(e, t.userId, r).next(() => {});
                })
              );
            })
          );
        }
        Zs(e) {
          const t = e.store('targetDocuments'),
            n = e.store('remoteDocuments');
          return e
            .store('targetGlobal')
            .get('targetGlobalKey')
            .next(e => {
              const r = [];
              return n
                .X((n, i) => {
                  const o = new Ci(n),
                    s = (function (e) {
                      return [0, so(e)];
                    })(o);
                  r.push(
                    t
                      .get(s)
                      .next(n => (n ? zi.resolve() : (n => t.put({ targetId: 0, path: so(n), sequenceNumber: e.highestListenSequenceNumber }))(o)))
                  );
                })
                .next(() => zi.waitFor(r));
            });
        }
        ti(e, t) {
          e.createObjectStore('collectionParents', { keyPath: _o });
          const n = t.store('collectionParents'),
            r = new hl(),
            i = e => {
              if (r.add(e)) {
                const t = e.lastSegment(),
                  r = e.popLast();
                return n.put({ collectionId: t, parent: so(r) });
              }
            };
          return t
            .store('remoteDocuments')
            .X({ Y: !0 }, (e, t) => {
              const n = new Ci(e);
              return i(n.popLast());
            })
            .next(() =>
              t.store('documentMutations').X({ Y: !0 }, ([e, t, n], r) => {
                const o = co(t);
                return i(o.popLast());
              })
            );
        }
        ei(e) {
          const t = e.store('targets');
          return t.X((e, n) => {
            const r = Pc(n),
              i = Dc(this.serializer, r);
            return t.put(i);
          });
        }
        ni(e, t) {
          const n = t.store('remoteDocuments'),
            r = [];
          return n
            .X((e, n) => {
              const i = t.store('remoteDocumentsV14'),
                o = ((s = n),
                s.document
                  ? new Ni(Ci.fromString(s.document.name).popFirst(5))
                  : s.noDocument
                    ? Ni.fromSegments(s.noDocument.path)
                    : s.unknownDocument
                      ? Ni.fromSegments(s.unknownDocument.path)
                      : oi()).path.toArray();
              var s;
              /**
               * @license
               * Copyright 2017 Google LLC
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *   http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */ const a = {
                prefixPath: o.slice(0, o.length - 2),
                collectionGroup: o[o.length - 2],
                documentId: o[o.length - 1],
                readTime: n.readTime || [0, 0],
                unknownDocument: n.unknownDocument,
                noDocument: n.noDocument,
                document: n.document,
                hasCommittedMutations: !!n.hasCommittedMutations
              };
              r.push(i.put(a));
            })
            .next(() => zi.waitFor(r));
        }
        si(e, t) {
          const n = t.store('mutations'),
            r = $l(this.serializer),
            i = new oh(ah.zs, this.serializer.fe);
          return n.j().next(e => {
            const n = new Map();
            return (
              e.forEach(e => {
                var t;
                let r = null !== (t = n.get(e.userId)) && void 0 !== t ? t : La();
                Rc(this.serializer, e)
                  .keys()
                  .forEach(e => (r = r.add(e))),
                  n.set(e.userId, r);
              }),
              zi.forEach(n, (e, n) => {
                const o = new Yr(n),
                  s = $c.de(this.serializer, o),
                  a = i.getIndexManager(o),
                  u = El.de(o, this.serializer, a, i.referenceDelegate);
                return new Yl(r, u, s, a).recalculateAndSaveOverlaysForDocumentKeys(new Do(t, no.ct), e).next();
              })
            );
          });
        }
      }
      function ch(e) {
        e.createObjectStore('targetDocuments', { keyPath: wo }).createIndex('documentTargetsIndex', bo, { unique: !0 }),
          e.createObjectStore('targets', { keyPath: 'targetId' }).createIndex('queryTargetsIndex', yo, { unique: !0 }),
          e.createObjectStore('targetGlobal');
      }
      const lh =
        'Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.';
      class hh {
        constructor(e, t, n, r, i, o, s, a, u, c, l = 15) {
          if (
            ((this.allowTabSynchronization = e),
            (this.persistenceKey = t),
            (this.clientId = n),
            (this.ii = i),
            (this.window = o),
            (this.document = s),
            (this.ri = u),
            (this.oi = c),
            (this.ui = l),
            (this.Os = null),
            (this.Fs = !1),
            (this.isPrimary = !1),
            (this.networkEnabled = !0),
            (this.ci = null),
            (this.inForeground = !1),
            (this.ai = null),
            (this.hi = null),
            (this.li = Number.NEGATIVE_INFINITY),
            (this.fi = e => Promise.resolve()),
            !hh.D())
          )
            throw new li(
              ci.UNIMPLEMENTED,
              'This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.'
            );
          (this.referenceDelegate = new Fl(this, r)),
            (this.di = t + 'main'),
            (this.serializer = new Ac(a)),
            (this.wi = new Wi(this.di, this.ui, new uh(this.serializer))),
            (this.Bs = new kl(this.referenceDelegate, this.serializer)),
            (this.remoteDocumentCache = $l(this.serializer)),
            (this.qs = new Uc()),
            this.window && this.window.localStorage
              ? (this._i = this.window.localStorage)
              : ((this._i = null),
                !1 === c &&
                  ni(
                    'IndexedDbPersistence',
                    'LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.'
                  ));
        }
        start() {
          return this.mi()
            .then(() => {
              if (!this.isPrimary && !this.allowTabSynchronization) throw new li(ci.FAILED_PRECONDITION, lh);
              return (
                this.gi(),
                this.yi(),
                this.pi(),
                this.runTransaction('getHighestListenSequenceNumber', 'readonly', e => this.Bs.getHighestSequenceNumber(e))
              );
            })
            .then(e => {
              this.Os = new no(e, this.ri);
            })
            .then(() => {
              this.Fs = !0;
            })
            .catch(e => (this.wi && this.wi.close(), Promise.reject(e)));
        }
        Ii(e) {
          return (
            (this.fi = async t => {
              if (this.started) return e(t);
            }),
            e(this.isPrimary)
          );
        }
        setDatabaseDeletedListener(e) {
          this.wi.B(async t => {
            null === t.newVersion && (await e());
          });
        }
        setNetworkEnabled(e) {
          this.networkEnabled !== e &&
            ((this.networkEnabled = e),
            this.ii.enqueueAndForget(async () => {
              this.started && (await this.mi());
            }));
        }
        mi() {
          return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', e =>
            dh(e)
              .put({ clientId: this.clientId, updateTimeMs: Date.now(), networkEnabled: this.networkEnabled, inForeground: this.inForeground })
              .next(() => {
                if (this.isPrimary)
                  return this.Ti(e).next(e => {
                    e || ((this.isPrimary = !1), this.ii.enqueueRetryable(() => this.fi(!1)));
                  });
              })
              .next(() => this.Ei(e))
              .next(t => (this.isPrimary && !t ? this.Ai(e).next(() => !1) : !!t && this.vi(e).next(() => !0)))
          )
            .catch(e => {
              if (Qi(e)) return ti('IndexedDbPersistence', 'Failed to extend owner lease: ', e), this.isPrimary;
              if (!this.allowTabSynchronization) throw e;
              return ti('IndexedDbPersistence', 'Releasing owner lease after error during lease refresh', e), !1;
            })
            .then(e => {
              this.isPrimary !== e && this.ii.enqueueRetryable(() => this.fi(e)), (this.isPrimary = e);
            });
        }
        Ti(e) {
          return fh(e)
            .get('owner')
            .next(e => zi.resolve(this.Ri(e)));
        }
        Pi(e) {
          return dh(e).delete(this.clientId);
        }
        async bi() {
          if (this.isPrimary && !this.Vi(this.li, 18e5)) {
            this.li = Date.now();
            const e = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', e => {
              const t = Lo(e, 'clientMetadata');
              return t.j().next(e => {
                const n = this.Si(e, 18e5),
                  r = e.filter(e => -1 === n.indexOf(e));
                return zi.forEach(r, e => t.delete(e.clientId)).next(() => r);
              });
            }).catch(() => []);
            if (this._i) for (const t of e) this._i.removeItem(this.Di(t.clientId));
          }
        }
        pi() {
