          remove firebase code from this and fix the code. NO NEED TO EXPLAIN OR TO SHOW A BEFORE. JUST DIRECTLY CARRY OUT THE TASK TO REMOVE FIREBASE ELEMENTS FROM THE GIVEN SNIPPET WITHOUT BREAKING THE PROJECT-
            this.task.then(() => {
              (this.observers = void 0), (this.onNoObservers = void 0);
            }));
        }
      }
      function W(e, t) {
        if ('object' !== typeof e || null === e) return !1;
        for (const n of t) if (n in e && 'function' === typeof e[n]) return !0;
        return !1;
      }
      function H() {}
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const K = 1e3,
        Q = 2,
        Y = 144e5,
        X = 0.5;
      function J(e, t = K, n = Q) {
        const r = t * Math.pow(n, e),
          i = Math.round(X * r * (Math.random() - 0.5) * 2);
        return Math.min(Y, r + i);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function Z(e) {
        return e && e._delegate ? e._delegate : e;
      }
    },
    1001: (e, t, n) => {
      'use strict';
      function r(e, t, n, r, i, o, s, a) {
        var u,
          c = 'function' === typeof e ? e.options : e;
        if (
          (t && ((c.render = t), (c.staticRenderFns = n), (c._compiled = !0)),
          r && (c.functional = !0),
          o && (c._scopeId = 'data-v-' + o),
          s
            ? ((u = function (e) {
                (e = e || (this.$vnode && this.$vnode.ssrContext) || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext)),
                  e || 'undefined' === typeof __VUE_SSR_CONTEXT__ || (e = __VUE_SSR_CONTEXT__),
                  i && i.call(this, e),
                  e && e._registeredComponents && e._registeredComponents.add(s);
              }),
              (c._ssrRegister = u))
            : i &&
              (u = a
                ? function () {
                    i.call(this, (c.functional ? this.parent : this).$root.$options.shadowRoot);
                  }
                : i),
          u)
        )
          if (c.functional) {
            c._injectStyles = u;
            var l = c.render;
            c.render = function (e, t) {
              return u.call(t), l(e, t);
            };
          } else {
            var h = c.beforeCreate;
            c.beforeCreate = h ? [].concat(h, u) : [u];
          }
        return { exports: e, options: c };
      }
      n.d(t, { Z: () => r });
    },
    64429: (e, t, n) => {
      'use strict';
      n.d(t, { Z: () => ln });
      var r = {};
      function i() {
        return 'object' === typeof window && void 0 !== (null === window || void 0 === window ? void 0 : window.document);
      }
      n.r(r),
        n.d(r, { exclude: () => L, extract: () => k, parse: () => O, parseUrl: () => R, pick: () => D, stringify: () => N, stringifyUrl: () => P });
      var o = function () {
          var e;
          if (i()) {
            var t = window,
              n = Array;
            if (void 0 !== t.Prototype && void 0 !== (null === (e = n.prototype) || void 0 === e ? void 0 : e.toJSON))
              return delete n.prototype.toJSON, !0;
          }
          return !1;
        },
        s = n(99560),
        a = n.n(s);
      const u = '%[a-f0-9]{2}',
        c = new RegExp('(' + u + ')|([^%]+?)', 'gi'),
        l = new RegExp('(' + u + ')+', 'gi');
      function h(e, t) {
        try {
          return [decodeURIComponent(e.join(''))];
        } catch {}
        if (1 === e.length) return e;
        t = t || 1;
        const n = e.slice(0, t),
          r = e.slice(t);
        return Array.prototype.concat.call([], h(n), h(r));
      }
      function f(e) {
        try {
          return decodeURIComponent(e);
        } catch {
          let t = e.match(c) || [];
          for (let n = 1; n < t.length; n++) (e = h(t, n).join('')), (t = e.match(c) || []);
          return e;
        }
      }
      function d(e) {
        const t = { '%FE%FF': '��', '%FF%FE': '��' };
        let n = l.exec(e);
        while (n) {
          try {
            t[n[0]] = decodeURIComponent(n[0]);
          } catch {
            const e = f(n[0]);
            e !== n[0] && (t[n[0]] = e);
          }
          n = l.exec(e);
        }
        t['%C2'] = '�';
        const r = Object.keys(t);
        for (const i of r) e = e.replace(new RegExp(i, 'g'), t[i]);
        return e;
      }
      function p(e) {
        if ('string' !== typeof e) throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof e + '`');
        try {
          return decodeURIComponent(e);
        } catch {
          return d(e);
        }
      }
      function g(e, t) {
        if ('string' !== typeof e || 'string' !== typeof t) throw new TypeError('Expected the arguments to be of type `string`');
        if ('' === e || '' === t) return [];
        const n = e.indexOf(t);
        return -1 === n ? [] : [e.slice(0, n), e.slice(n + t.length)];
      }
      function m(e, t) {
        const n = {};
        if (Array.isArray(t))
          for (const r of t) {
            const t = Object.getOwnPropertyDescriptor(e, r);
            t?.enumerable && Object.defineProperty(n, r, t);
          }
        else
          for (const r of Reflect.ownKeys(e)) {
            const i = Object.getOwnPropertyDescriptor(e, r);
            if (i.enumerable) {
              const o = e[r];
              t(r, o, e) && Object.defineProperty(n, r, i);
            }
          }
        return n;
      }
      const v = e => null === e || void 0 === e,
        y = e => encodeURIComponent(e).replace(/[!'()*]/g, e => `%${e.charCodeAt(0).toString(16).toUpperCase()}`),
        w = Symbol('encodeFragmentIdentifier');
      function b(e) {
        switch (e.arrayFormat) {
          case 'index':
            return t => (n, r) => {
              const i = n.length;
              return void 0 === r || (e.skipNull && null === r) || (e.skipEmptyString && '' === r)
                ? n
                : null === r
                  ? [...n, [E(t, e), '[', i, ']'].join('')]
                  : [...n, [E(t, e), '[', E(i, e), ']=', E(r, e)].join('')];
            };
          case 'bracket':
            return t => (n, r) =>
              void 0 === r || (e.skipNull && null === r) || (e.skipEmptyString && '' === r)
                ? n
                : null === r
                  ? [...n, [E(t, e), '[]'].join('')]
                  : [...n, [E(t, e), '[]=', E(r, e)].join('')];
          case 'colon-list-separator':
            return t => (n, r) =>
              void 0 === r || (e.skipNull && null === r) || (e.skipEmptyString && '' === r)
                ? n
                : null === r
                  ? [...n, [E(t, e), ':list='].join('')]
                  : [...n, [E(t, e), ':list=', E(r, e)].join('')];
          case 'comma':
          case 'separator':
          case 'bracket-separator': {
            const t = 'bracket-separator' === e.arrayFormat ? '[]=' : '=';
            return n => (r, i) =>
              void 0 === i || (e.skipNull && null === i) || (e.skipEmptyString && '' === i)
                ? r
                : ((i = null === i ? '' : i), 0 === r.length ? [[E(n, e), t, E(i, e)].join('')] : [[r, E(i, e)].join(e.arrayFormatSeparator)]);
          }
          default:
            return t => (n, r) =>
              void 0 === r || (e.skipNull && null === r) || (e.skipEmptyString && '' === r)
                ? n
                : null === r
                  ? [...n, E(t, e)]
                  : [...n, [E(t, e), '=', E(r, e)].join('')];
        }
      }
      function _(e) {
        let t;
        switch (e.arrayFormat) {
          case 'index':
            return (e, n, r) => {
              (t = /\[(\d*)]$/.exec(e)), (e = e.replace(/\[\d*]$/, '')), t ? (void 0 === r[e] && (r[e] = {}), (r[e][t[1]] = n)) : (r[e] = n);
            };
          case 'bracket':
            return (e, n, r) => {
              (t = /(\[])$/.exec(e)), (e = e.replace(/\[]$/, '')), t ? (void 0 !== r[e] ? (r[e] = [...r[e], n]) : (r[e] = [n])) : (r[e] = n);
            };
          case 'colon-list-separator':
            return (e, n, r) => {
              (t = /(:list)$/.exec(e)), (e = e.replace(/:list$/, '')), t ? (void 0 !== r[e] ? (r[e] = [...r[e], n]) : (r[e] = [n])) : (r[e] = n);
            };
          case 'comma':
          case 'separator':
            return (t, n, r) => {
              const i = 'string' === typeof n && n.includes(e.arrayFormatSeparator),
                o = 'string' === typeof n && !i && S(n, e).includes(e.arrayFormatSeparator);
              n = o ? S(n, e) : n;
              const s = i || o ? n.split(e.arrayFormatSeparator).map(t => S(t, e)) : null === n ? n : S(n, e);
              r[t] = s;
            };
          case 'bracket-separator':
            return (t, n, r) => {
              const i = /(\[])$/.test(t);
              if (((t = t.replace(/\[]$/, '')), !i)) return void (r[t] = n ? S(n, e) : n);
              const o = null === n ? [] : n.split(e.arrayFormatSeparator).map(t => S(t, e));
              void 0 !== r[t] ? (r[t] = [...r[t], ...o]) : (r[t] = o);
            };
          default:
            return (e, t, n) => {
              void 0 !== n[e] ? (n[e] = [...[n[e]].flat(), t]) : (n[e] = t);
            };
        }
      }
      function I(e) {
        if ('string' !== typeof e || 1 !== e.length) throw new TypeError('arrayFormatSeparator must be single character string');
      }
      function E(e, t) {
        return t.encode ? (t.strict ? y(e) : encodeURIComponent(e)) : e;
      }
      function S(e, t) {
        return t.decode ? p(e) : e;
      }
      function T(e) {
        return Array.isArray(e)
          ? e.sort()
          : 'object' === typeof e
            ? T(Object.keys(e))
                .sort((e, t) => Number(e) - Number(t))
                .map(t => e[t])
            : e;
      }
      function A(e) {
        const t = e.indexOf('#');
        return -1 !== t && (e = e.slice(0, t)), e;
      }
      function x(e) {
        let t = '';
        const n = e.indexOf('#');
        return -1 !== n && (t = e.slice(n)), t;
      }
      function C(e, t) {
        return (
          t.parseNumbers && !Number.isNaN(Number(e)) && 'string' === typeof e && '' !== e.trim()
            ? (e = Number(e))
            : !t.parseBooleans || null === e || ('true' !== e.toLowerCase() && 'false' !== e.toLowerCase()) || (e = 'true' === e.toLowerCase()),
          e
        );
      }
      function k(e) {
        e = A(e);
        const t = e.indexOf('?');
        return -1 === t ? '' : e.slice(t + 1);
      }
      function O(e, t) {
        (t = { decode: !0, sort: !0, arrayFormat: 'none', arrayFormatSeparator: ',', parseNumbers: !1, parseBooleans: !1, ...t }),
          I(t.arrayFormatSeparator);
        const n = _(t),
          r = Object.create(null);
        if ('string' !== typeof e) return r;
        if (((e = e.trim().replace(/^[?#&]/, '')), !e)) return r;
        for (const i of e.split('&')) {
          if ('' === i) continue;
          const e = t.decode ? i.replace(/\+/g, ' ') : i;
          let [o, s] = g(e, '=');
          void 0 === o && (o = e),
            (s = void 0 === s ? null : ['comma', 'separator', 'bracket-separator'].includes(t.arrayFormat) ? s : S(s, t)),
            n(S(o, t), s, r);
        }
        for (const [i, o] of Object.entries(r))
          if ('object' === typeof o && null !== o) for (const [e, n] of Object.entries(o)) o[e] = C(n, t);
          else r[i] = C(o, t);
        return !1 === t.sort
          ? r
          : (!0 === t.sort ? Object.keys(r).sort() : Object.keys(r).sort(t.sort)).reduce((e, t) => {
              const n = r[t];
              return Boolean(n) && 'object' === typeof n && !Array.isArray(n) ? (e[t] = T(n)) : (e[t] = n), e;
            }, Object.create(null));
      }
      function N(e, t) {
        if (!e) return '';
        (t = { encode: !0, strict: !0, arrayFormat: 'none', arrayFormatSeparator: ',', ...t }), I(t.arrayFormatSeparator);
        const n = n => (t.skipNull && v(e[n])) || (t.skipEmptyString && '' === e[n]),
          r = b(t),
          i = {};
        for (const [s, a] of Object.entries(e)) n(s) || (i[s] = a);
        const o = Object.keys(i);
        return (
          !1 !== t.sort && o.sort(t.sort),
          o
            .map(n => {
              const i = e[n];
              return void 0 === i
                ? ''
                : null === i
                  ? E(n, t)
                  : Array.isArray(i)
                    ? 0 === i.length && 'bracket-separator' === t.arrayFormat
                      ? E(n, t) + '[]'
                      : i.reduce(r(n), []).join('&')
                    : E(n, t) + '=' + E(i, t);
            })
            .filter(e => e.length > 0)
            .join('&')
        );
      }
      function R(e, t) {
        t = { decode: !0, ...t };
        let [n, r] = g(e, '#');
        return (
          void 0 === n && (n = e),
          { url: n?.split('?')?.[0] ?? '', query: O(k(e), t), ...(t && t.parseFragmentIdentifier && r ? { fragmentIdentifier: S(r, t) } : {}) }
        );
