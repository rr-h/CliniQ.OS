       */ class fi {
        constructor(e, t) {
          (this.user = t), (this.type = 'OAuth'), (this.headers = new Map()), this.headers.set('Authorization', `Bearer ${e}`);
        }
      }
      class di {
        getToken() {
          return Promise.resolve(null);
        }
        invalidateToken() {}
        start(e, t) {
          e.enqueueRetryable(() => t(Yr.UNAUTHENTICATED));
        }
        shutdown() {}
      }
      class pi {
        constructor(e) {
          (this.token = e), (this.changeListener = null);
        }
        getToken() {
          return Promise.resolve(this.token);
        }
        invalidateToken() {}
        start(e, t) {
          (this.changeListener = t), e.enqueueRetryable(() => t(this.token.user));
        }
        shutdown() {
          this.changeListener = null;
        }
      }
      class gi {
        constructor(e) {
          (this.t = e), (this.currentUser = Yr.UNAUTHENTICATED), (this.i = 0), (this.forceRefresh = !1), (this.auth = null);
        }
        start(e, t) {
          let n = this.i;
          const r = e => (this.i !== n ? ((n = this.i), t(e)) : Promise.resolve());
          let i = new hi();
          this.o = () => {
            this.i++, (this.currentUser = this.u()), i.resolve(), (i = new hi()), e.enqueueRetryable(() => r(this.currentUser));
          };
          const o = () => {
              const t = i;
              e.enqueueRetryable(async () => {
                await t.promise, await r(this.currentUser);
              });
            },
            s = e => {
              ti('FirebaseAuthCredentialsProvider', 'Auth detected'), (this.auth = e), this.auth.addAuthTokenListener(this.o), o();
            };
          this.t.onInit(e => s(e)),
            setTimeout(() => {
              if (!this.auth) {
                const e = this.t.getImmediate({ optional: !0 });
                e ? s(e) : (ti('FirebaseAuthCredentialsProvider', 'Auth not yet detected'), i.resolve(), (i = new hi()));
              }
            }, 0),
            o();
        }
        getToken() {
          const e = this.i,
            t = this.forceRefresh;
          return (
            (this.forceRefresh = !1),
            this.auth
              ? this.auth
                  .getToken(t)
                  .then(t =>
                    this.i !== e
                      ? (ti('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.'), this.getToken())
                      : t
                        ? (si('string' == typeof t.accessToken), new fi(t.accessToken, this.currentUser))
                        : null
                  )
              : Promise.resolve(null)
          );
        }
        invalidateToken() {
          this.forceRefresh = !0;
        }
        shutdown() {
          this.auth && this.auth.removeAuthTokenListener(this.o);
        }
        u() {
          const e = this.auth && this.auth.getUid();
          return si(null === e || 'string' == typeof e), new Yr(e);
        }
      }
      class mi {
        constructor(e, t, n) {
          (this.h = e), (this.l = t), (this.m = n), (this.type = 'FirstParty'), (this.user = Yr.FIRST_PARTY), (this.g = new Map());
        }
        p() {
          return this.m ? this.m() : null;
        }
        get headers() {
          this.g.set('X-Goog-AuthUser', this.h);
          const e = this.p();
          return e && this.g.set('Authorization', e), this.l && this.g.set('X-Goog-Iam-Authorization-Token', this.l), this.g;
        }
      }
      class vi {
        constructor(e, t, n) {
          (this.h = e), (this.l = t), (this.m = n);
        }
        getToken() {
          return Promise.resolve(new mi(this.h, this.l, this.m));
        }
        start(e, t) {
          e.enqueueRetryable(() => t(Yr.FIRST_PARTY));
        }
        shutdown() {}
        invalidateToken() {}
      }
      class yi {
        constructor(e) {
          (this.value = e),
            (this.type = 'AppCheck'),
            (this.headers = new Map()),
            e && e.length > 0 && this.headers.set('x-firebase-appcheck', this.value);
        }
      }
      class wi {
        constructor(e) {
          (this.I = e), (this.forceRefresh = !1), (this.appCheck = null), (this.T = null);
        }
        start(e, t) {
          const n = e => {
            null != e.error &&
              ti('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`);
            const n = e.token !== this.T;
            return (
              (this.T = e.token), ti('FirebaseAppCheckTokenProvider', `Received ${n ? 'new' : 'existing'} token.`), n ? t(e.token) : Promise.resolve()
            );
          };
          this.o = t => {
            e.enqueueRetryable(() => n(t));
          };
          const r = e => {
            ti('FirebaseAppCheckTokenProvider', 'AppCheck detected'), (this.appCheck = e), this.appCheck.addTokenListener(this.o);
          };
          this.I.onInit(e => r(e)),
            setTimeout(() => {
              if (!this.appCheck) {
                const e = this.I.getImmediate({ optional: !0 });
                e ? r(e) : ti('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');
              }
            }, 0);
        }
        getToken() {
          const e = this.forceRefresh;
          return (
            (this.forceRefresh = !1),
            this.appCheck
              ? this.appCheck.getToken(e).then(e => (e ? (si('string' == typeof e.token), (this.T = e.token), new yi(e.token)) : null))
              : Promise.resolve(null)
          );
        }
        invalidateToken() {
          this.forceRefresh = !0;
        }
        shutdown() {
          this.appCheck && this.appCheck.removeTokenListener(this.o);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function bi(e) {
        const t = 'undefined' != typeof self && (self.crypto || self.msCrypto),
          n = new Uint8Array(e);
        if (t && 'function' == typeof t.getRandomValues) t.getRandomValues(n);
        else for (let r = 0; r < e; r++) n[r] = Math.floor(256 * Math.random());
        return n;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class _i {
        static A() {
          const e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
            t = Math.floor(256 / e.length) * e.length;
          let n = '';
          for (; n.length < 20; ) {
            const r = bi(40);
            for (let i = 0; i < r.length; ++i) n.length < 20 && r[i] < t && (n += e.charAt(r[i] % e.length));
          }
          return n;
        }
      }
      function Ii(e, t) {
        return e < t ? -1 : e > t ? 1 : 0;
      }
      function Ei(e, t, n) {
        return e.length === t.length && e.every((e, r) => n(e, t[r]));
      }
      function Si(e) {
        return e + '\0';
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ti {
        constructor(e, t) {
          if (((this.seconds = e), (this.nanoseconds = t), t < 0)) throw new li(ci.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + t);
          if (t >= 1e9) throw new li(ci.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + t);
          if (e < -62135596800) throw new li(ci.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + e);
          if (e >= 253402300800) throw new li(ci.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + e);
        }
        static now() {
          return Ti.fromMillis(Date.now());
        }
        static fromDate(e) {
          return Ti.fromMillis(e.getTime());
        }
        static fromMillis(e) {
          const t = Math.floor(e / 1e3),
            n = Math.floor(1e6 * (e - 1e3 * t));
          return new Ti(t, n);
        }
        toDate() {
          return new Date(this.toMillis());
        }
        toMillis() {
          return 1e3 * this.seconds + this.nanoseconds / 1e6;
        }
        _compareTo(e) {
          return this.seconds === e.seconds ? Ii(this.nanoseconds, e.nanoseconds) : Ii(this.seconds, e.seconds);
        }
        isEqual(e) {
          return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
        }
        toString() {
          return 'Timestamp(seconds=' + this.seconds + ', nanoseconds=' + this.nanoseconds + ')';
        }
        toJSON() {
          return { seconds: this.seconds, nanoseconds: this.nanoseconds };
        }
        valueOf() {
          const e = this.seconds - -62135596800;
          return String(e).padStart(12, '0') + '.' + String(this.nanoseconds).padStart(9, '0');
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ai {
        constructor(e) {
          this.timestamp = e;
        }
        static fromTimestamp(e) {
          return new Ai(e);
        }
        static min() {
          return new Ai(new Ti(0, 0));
        }
        static max() {
          return new Ai(new Ti(253402300799, 999999999));
        }
        compareTo(e) {
          return this.timestamp._compareTo(e.timestamp);
        }
        isEqual(e) {
          return this.timestamp.isEqual(e.timestamp);
        }
        toMicroseconds() {
          return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
        }
        toString() {
          return 'SnapshotVersion(' + this.timestamp.toString() + ')';
        }
        toTimestamp() {
          return this.timestamp;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class xi {
        constructor(e, t, n) {
          void 0 === t ? (t = 0) : t > e.length && oi(),
            void 0 === n ? (n = e.length - t) : n > e.length - t && oi(),
            (this.segments = e),
            (this.offset = t),
            (this.len = n);
        }
        get length() {
          return this.len;
        }
        isEqual(e) {
          return 0 === xi.comparator(this, e);
        }
        child(e) {
          const t = this.segments.slice(this.offset, this.limit());
          return (
            e instanceof xi
              ? e.forEach(e => {
                  t.push(e);
                })
              : t.push(e),
            this.construct(t)
          );
        }
        limit() {
          return this.offset + this.length;
        }
        popFirst(e) {
          return (e = void 0 === e ? 1 : e), this.construct(this.segments, this.offset + e, this.length - e);
        }
        popLast() {
          return this.construct(this.segments, this.offset, this.length - 1);
        }
        firstSegment() {
          return this.segments[this.offset];
        }
        lastSegment() {
          return this.get(this.length - 1);
        }
        get(e) {
          return this.segments[this.offset + e];
        }
        isEmpty() {
          return 0 === this.length;
        }
        isPrefixOf(e) {
          if (e.length < this.length) return !1;
          for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return !1;
          return !0;
        }
        isImmediateParentOf(e) {
          if (this.length + 1 !== e.length) return !1;
          for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return !1;
          return !0;
        }
        forEach(e) {
          for (let t = this.offset, n = this.limit(); t < n; t++) e(this.segments[t]);
        }
        toArray() {
          return this.segments.slice(this.offset, this.limit());
