      }
      class vi {
        constructor(e, t, n) {
          (this.h = e), (this.l = t), (this.m = n);
        }
        getToken() {
          return Promise.resolve(new mi(this.h, this.l, this.m));
        }
        start(e, t) {
          e.enqueueRetryable(() => t(Yr.FIRST_PARTY));
        }
        shutdown() {}
        invalidateToken() {}
      }
      class yi {
        constructor(e) {
          (this.value = e),
            (this.type = 'AppCheck'),
            (this.headers = new Map()),
            e && e.length > 0 && this.headers.set('x-firebase-appcheck', this.value);
        }
      }
      class wi {
        constructor(e) {
          (this.I = e), (this.forceRefresh = !1), (this.appCheck = null), (this.T = null);
        }
        start(e, t) {
          const n = e => {
            null != e.error &&
              ti('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`);
            const n = e.token !== this.T;
            return (
              (this.T = e.token), ti('FirebaseAppCheckTokenProvider', `Received ${n ? 'new' : 'existing'} token.`), n ? t(e.token) : Promise.resolve()
            );
          };
          this.o = t => {
            e.enqueueRetryable(() => n(t));
          };
          const r = e => {
            ti('FirebaseAppCheckTokenProvider', 'AppCheck detected'), (this.appCheck = e), this.appCheck.addTokenListener(this.o);
          };
          this.I.onInit(e => r(e)),
            setTimeout(() => {
              if (!this.appCheck) {
                const e = this.I.getImmediate({ optional: !0 });
                e ? r(e) : ti('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');
              }
            }, 0);
        }
        getToken() {
          const e = this.forceRefresh;
          return (
            (this.forceRefresh = !1),
            this.appCheck
              ? this.appCheck.getToken(e).then(e => (e ? (si('string' == typeof e.token), (this.T = e.token), new yi(e.token)) : null))
              : Promise.resolve(null)
          );
        }
        invalidateToken() {
          this.forceRefresh = !0;
        }
        shutdown() {
          this.appCheck && this.appCheck.removeTokenListener(this.o);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function bi(e) {
        const t = 'undefined' != typeof self && (self.crypto || self.msCrypto),
          n = new Uint8Array(e);
        if (t && 'function' == typeof t.getRandomValues) t.getRandomValues(n);
        else for (let r = 0; r < e; r++) n[r] = Math.floor(256 * Math.random());
        return n;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class _i {
        static A() {
          const e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
            t = Math.floor(256 / e.length) * e.length;
          let n = '';
          for (; n.length < 20; ) {
            const r = bi(40);
            for (let i = 0; i < r.length; ++i) n.length < 20 && r[i] < t && (n += e.charAt(r[i] % e.length));
          }
          return n;
        }
      }
      function Ii(e, t) {
        return e < t ? -1 : e > t ? 1 : 0;
      }
      function Ei(e, t, n) {
        return e.length === t.length && e.every((e, r) => n(e, t[r]));
      }
      function Si(e) {
        return e + '\0';
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ti {
        constructor(e, t) {
          if (((this.seconds = e), (this.nanoseconds = t), t < 0)) throw new li(ci.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + t);
          if (t >= 1e9) throw new li(ci.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + t);
          if (e < -62135596800) throw new li(ci.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + e);
          if (e >= 253402300800) throw new li(ci.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + e);
        }
        static now() {
          return Ti.fromMillis(Date.now());
        }
        static fromDate(e) {
          return Ti.fromMillis(e.getTime());
        }
        static fromMillis(e) {
          const t = Math.floor(e / 1e3),
            n = Math.floor(1e6 * (e - 1e3 * t));
          return new Ti(t, n);
        }
        toDate() {
          return new Date(this.toMillis());
        }
        toMillis() {
          return 1e3 * this.seconds + this.nanoseconds / 1e6;
        }
        _compareTo(e) {
          return this.seconds === e.seconds ? Ii(this.nanoseconds, e.nanoseconds) : Ii(this.seconds, e.seconds);
        }
        isEqual(e) {
          return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
        }
        toString() {
          return 'Timestamp(seconds=' + this.seconds + ', nanoseconds=' + this.nanoseconds + ')';
        }
        toJSON() {
          return { seconds: this.seconds, nanoseconds: this.nanoseconds };
        }
        valueOf() {
          const e = this.seconds - -62135596800;
          return String(e).padStart(12, '0') + '.' + String(this.nanoseconds).padStart(9, '0');
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ai {
        constructor(e) {
          this.timestamp = e;
        }
        static fromTimestamp(e) {
          return new Ai(e);
        }
        static min() {
          return new Ai(new Ti(0, 0));
        }
        static max() {
          return new Ai(new Ti(253402300799, 999999999));
        }
        compareTo(e) {
          return this.timestamp._compareTo(e.timestamp);
        }
        isEqual(e) {
          return this.timestamp.isEqual(e.timestamp);
        }
        toMicroseconds() {
          return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
        }
        toString() {
          return 'SnapshotVersion(' + this.timestamp.toString() + ')';
        }
        toTimestamp() {
          return this.timestamp;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class xi {
        constructor(e, t, n) {
          void 0 === t ? (t = 0) : t > e.length && oi(),
            void 0 === n ? (n = e.length - t) : n > e.length - t && oi(),
            (this.segments = e),
            (this.offset = t),
            (this.len = n);
        }
        get length() {
          return this.len;
        }
        isEqual(e) {
          return 0 === xi.comparator(this, e);
        }
        child(e) {
          const t = this.segments.slice(this.offset, this.limit());
          return (
            e instanceof xi
              ? e.forEach(e => {
                  t.push(e);
                })
              : t.push(e),
            this.construct(t)
          );
        }
        limit() {
          return this.offset + this.length;
        }
        popFirst(e) {
          return (e = void 0 === e ? 1 : e), this.construct(this.segments, this.offset + e, this.length - e);
        }
        popLast() {
          return this.construct(this.segments, this.offset, this.length - 1);
        }
        firstSegment() {
          return this.segments[this.offset];
        }
        lastSegment() {
          return this.get(this.length - 1);
        }
        get(e) {
          return this.segments[this.offset + e];
        }
        isEmpty() {
          return 0 === this.length;
        }
        isPrefixOf(e) {
          if (e.length < this.length) return !1;
          for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return !1;
          return !0;
        }
        isImmediateParentOf(e) {
          if (this.length + 1 !== e.length) return !1;
          for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return !1;
          return !0;
        }
        forEach(e) {
          for (let t = this.offset, n = this.limit(); t < n; t++) e(this.segments[t]);
        }
        toArray() {
          return this.segments.slice(this.offset, this.limit());
        }
        static comparator(e, t) {
          const n = Math.min(e.length, t.length);
          for (let r = 0; r < n; r++) {
            const n = e.get(r),
              i = t.get(r);
            if (n < i) return -1;
            if (n > i) return 1;
          }
          return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
        }
      }
      class Ci extends xi {
        construct(e, t, n) {
          return new Ci(e, t, n);
        }
        canonicalString() {
          return this.toArray().join('/');
        }
        toString() {
          return this.canonicalString();
        }
        static fromString(...e) {
          const t = [];
          for (const n of e) {
            if (n.indexOf('//') >= 0) throw new li(ci.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
            t.push(...n.split('/').filter(e => e.length > 0));
          }
          return new Ci(t);
        }
        static emptyPath() {
          return new Ci([]);
        }
      }
      const ki = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
      class Oi extends xi {
        construct(e, t, n) {
          return new Oi(e, t, n);
        }
        static isValidIdentifier(e) {
          return ki.test(e);
        }
        canonicalString() {
          return this.toArray()
            .map(e => ((e = e.replace(/\\/g, '\\\\').replace(/`/g, '\\`')), Oi.isValidIdentifier(e) || (e = '`' + e + '`'), e))
            .join('.');
        }
        toString() {
          return this.canonicalString();
        }
        isKeyField() {
          return 1 === this.length && '__name__' === this.get(0);
        }
        static keyField() {
          return new Oi(['__name__']);
        }
        static fromServerFormat(e) {
          const t = [];
          let n = '',
            r = 0;
          const i = () => {
            if (0 === n.length)
              throw new li(ci.INVALID_ARGUMENT, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
            t.push(n), (n = '');
          };
          let o = !1;
          for (; r < e.length; ) {
            const t = e[r];
            if ('\\' === t) {
              if (r + 1 === e.length) throw new li(ci.INVALID_ARGUMENT, 'Path has trailing escape character: ' + e);
              const t = e[r + 1];
              if ('\\' !== t && '.' !== t && '`' !== t) throw new li(ci.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + e);
              (n += t), (r += 2);
            } else '`' === t ? ((o = !o), r++) : '.' !== t || o ? ((n += t), r++) : (i(), r++);
          }
          if ((i(), o)) throw new li(ci.INVALID_ARGUMENT, 'Unterminated ` in path: ' + e);
          return new Oi(t);
        }
        static emptyPath() {
          return new Oi([]);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ni {
        constructor(e) {
          this.path = e;
        }
        static fromPath(e) {
          return new Ni(Ci.fromString(e));
        }
        static fromName(e) {
          return new Ni(Ci.fromString(e).popFirst(5));
        }
        static empty() {
          return new Ni(Ci.emptyPath());
        }
        get collectionGroup() {
          return this.path.popLast().lastSegment();
        }
        hasCollectionId(e) {
          return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
        }
        getCollectionGroup() {
          return this.path.get(this.path.length - 2);
        }
        getCollectionPath() {
          return this.path.popLast();
        }
        isEqual(e) {
          return null !== e && 0 === Ci.comparator(this.path, e.path);
        }
        toString() {
          return this.path.toString();
        }
        static comparator(e, t) {
          return Ci.comparator(e.path, t.path);
        }
        static isDocumentKey(e) {
          return e.length % 2 == 0;
        }
        static fromSegments(e) {
          return new Ni(new Ci(e.slice()));
        }
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ri {
        constructor(e, t, n, r) {
          (this.indexId = e), (this.collectionGroup = t), (this.fields = n), (this.indexState = r);
        }
      }
      function Pi(e) {
        return e.fields.find(e => 2 === e.kind);
      }
      function Di(e) {
        return e.fields.filter(e => 2 !== e.kind);
      }
      Ri.UNKNOWN_ID = -1;
      class Li {
        constructor(e, t) {
          (this.fieldPath = e), (this.kind = t);
        }
      }
      class ji {
        constructor(e, t) {
          (this.sequenceNumber = e), (this.offset = t);
        }
        static empty() {
          return new ji(0, Ui.min());
        }
      }
      function Mi(e, t) {
        const n = e.toTimestamp().seconds,
          r = e.toTimestamp().nanoseconds + 1,
          i = Ai.fromTimestamp(1e9 === r ? new Ti(n + 1, 0) : new Ti(n, r));
        return new Ui(i, Ni.empty(), t);
      }
      function Fi(e) {
        return new Ui(e.readTime, e.key, -1);
      }
      class Ui {
        constructor(e, t, n) {
          (this.readTime = e), (this.documentKey = t), (this.largestBatchId = n);
        }
        static min() {
          return new Ui(Ai.min(), Ni.empty(), -1);
        }
        static max() {
          return new Ui(Ai.max(), Ni.empty(), -1);
        }
      }
      function Vi(e, t) {
        let n = e.readTime.compareTo(t.readTime);
