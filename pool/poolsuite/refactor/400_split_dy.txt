        return '__max__' === (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue;
      }
      function _s(e) {
        return 'nullValue' in e
          ? os
          : 'booleanValue' in e
            ? { booleanValue: !1 }
            : 'integerValue' in e || 'doubleValue' in e
              ? { doubleValue: NaN }
              : 'timestampValue' in e
                ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } }
                : 'stringValue' in e
                  ? { stringValue: '' }
                  : 'bytesValue' in e
                    ? { bytesValue: '' }
                    : 'referenceValue' in e
                      ? ds(rs.empty(), Ni.empty())
                      : 'geoPointValue' in e
                        ? { geoPointValue: { latitude: -90, longitude: -180 } }
                        : 'arrayValue' in e
                          ? { arrayValue: {} }
                          : 'mapValue' in e
                            ? { mapValue: {} }
                            : oi();
      }
      function Is(e) {
        return 'nullValue' in e
          ? { booleanValue: !1 }
          : 'booleanValue' in e
            ? { doubleValue: NaN }
            : 'integerValue' in e || 'doubleValue' in e
              ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } }
              : 'timestampValue' in e
                ? { stringValue: '' }
                : 'stringValue' in e
                  ? { bytesValue: '' }
                  : 'bytesValue' in e
                    ? ds(rs.empty(), Ni.empty())
                    : 'referenceValue' in e
                      ? { geoPointValue: { latitude: -90, longitude: -180 } }
                      : 'geoPointValue' in e
                        ? { arrayValue: {} }
                        : 'arrayValue' in e
                          ? { mapValue: {} }
                          : 'mapValue' in e
                            ? is
                            : oi();
      }
      function Es(e, t) {
        const n = cs(e.value, t.value);
        return 0 !== n ? n : e.inclusive && !t.inclusive ? -1 : !e.inclusive && t.inclusive ? 1 : 0;
      }
      function Ss(e, t) {
        const n = cs(e.value, t.value);
        return 0 !== n ? n : e.inclusive && !t.inclusive ? 1 : !e.inclusive && t.inclusive ? -1 : 0;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ts {
        constructor(e) {
          this.value = e;
        }
        static empty() {
          return new Ts({ mapValue: {} });
        }
        field(e) {
          if (e.isEmpty()) return this.value;
          {
            let t = this.value;
            for (let n = 0; n < e.length - 1; ++n) if (((t = (t.mapValue.fields || {})[e.get(n)]), !ys(t))) return null;
            return (t = (t.mapValue.fields || {})[e.lastSegment()]), t || null;
          }
        }
        set(e, t) {
          this.getFieldsMap(e.popLast())[e.lastSegment()] = ws(t);
        }
        setAll(e) {
          let t = Oi.emptyPath(),
            n = {},
            r = [];
          e.forEach((e, i) => {
            if (!t.isImmediateParentOf(i)) {
              const e = this.getFieldsMap(t);
              this.applyChanges(e, n, r), (n = {}), (r = []), (t = i.popLast());
            }
            e ? (n[i.lastSegment()] = ws(e)) : r.push(i.lastSegment());
          });
          const i = this.getFieldsMap(t);
          this.applyChanges(i, n, r);
        }
        delete(e) {
          const t = this.field(e.popLast());
          ys(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
        }
        isEqual(e) {
          return as(this.value, e.value);
        }
        getFieldsMap(e) {
          let t = this.value;
          t.mapValue.fields || (t.mapValue = { fields: {} });
          for (let n = 0; n < e.length; ++n) {
            let r = t.mapValue.fields[e.get(n)];
            (ys(r) && r.mapValue.fields) || ((r = { mapValue: { fields: {} } }), (t.mapValue.fields[e.get(n)] = r)), (t = r);
          }
          return t.mapValue.fields;
        }
        applyChanges(e, t, n) {
          Mo(t, (t, n) => (e[t] = n));
          for (const r of n) delete e[r];
        }
        clone() {
          return new Ts(ws(this.value));
        }
      }
      function As(e) {
        const t = [];
        return (
          Mo(e.fields, (e, n) => {
            const r = new Oi([e]);
            if (ys(n)) {
              const e = As(n.mapValue).fields;
              if (0 === e.length) t.push(r);
              else for (const n of e) t.push(r.child(n));
            } else t.push(r);
          }),
          new Go(t)
        );
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class xs {
        constructor(e, t, n, r, i, o, s) {
          (this.key = e),
            (this.documentType = t),
            (this.version = n),
            (this.readTime = r),
            (this.createTime = i),
            (this.data = o),
            (this.documentState = s);
        }
        static newInvalidDocument(e) {
          return new xs(e, 0, Ai.min(), Ai.min(), Ai.min(), Ts.empty(), 0);
        }
        static newFoundDocument(e, t, n, r) {
          return new xs(e, 1, t, Ai.min(), n, r, 0);
        }
        static newNoDocument(e, t) {
          return new xs(e, 2, t, Ai.min(), Ai.min(), Ts.empty(), 0);
        }
        static newUnknownDocument(e, t) {
          return new xs(e, 3, t, Ai.min(), Ai.min(), Ts.empty(), 2);
        }
        convertToFoundDocument(e, t) {
          return (
            !this.createTime.isEqual(Ai.min()) || (2 !== this.documentType && 0 !== this.documentType) || (this.createTime = e),
            (this.version = e),
            (this.documentType = 1),
            (this.data = t),
            (this.documentState = 0),
            this
          );
        }
        convertToNoDocument(e) {
          return (this.version = e), (this.documentType = 2), (this.data = Ts.empty()), (this.documentState = 0), this;
        }
        convertToUnknownDocument(e) {
          return (this.version = e), (this.documentType = 3), (this.data = Ts.empty()), (this.documentState = 2), this;
        }
        setHasCommittedMutations() {
          return (this.documentState = 2), this;
        }
        setHasLocalMutations() {
          return (this.documentState = 1), (this.version = Ai.min()), this;
        }
        setReadTime(e) {
          return (this.readTime = e), this;
        }
        get hasLocalMutations() {
          return 1 === this.documentState;
        }
        get hasCommittedMutations() {
          return 2 === this.documentState;
        }
        get hasPendingWrites() {
          return this.hasLocalMutations || this.hasCommittedMutations;
        }
        isValidDocument() {
          return 0 !== this.documentType;
        }
        isFoundDocument() {
          return 1 === this.documentType;
        }
        isNoDocument() {
          return 2 === this.documentType;
        }
        isUnknownDocument() {
          return 3 === this.documentType;
        }
        isEqual(e) {
          return (
            e instanceof xs &&
            this.key.isEqual(e.key) &&
            this.version.isEqual(e.version) &&
            this.documentType === e.documentType &&
            this.documentState === e.documentState &&
            this.data.isEqual(e.data)
          );
        }
        mutableCopy() {
          return new xs(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
        }
        toString() {
          return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Cs {
        constructor(e, t) {
          (this.position = e), (this.inclusive = t);
        }
      }
      function ks(e, t, n) {
        let r = 0;
        for (let i = 0; i < e.position.length; i++) {
          const o = t[i],
            s = e.position[i];
          if (
            ((r = o.field.isKeyField() ? Ni.comparator(Ni.fromName(s.referenceValue), n.key) : cs(s, n.data.field(o.field))),
            'desc' === o.dir && (r *= -1),
            0 !== r)
          )
            break;
        }
        return r;
      }
      function Os(e, t) {
        if (null === e) return null === t;
        if (null === t) return !1;
        if (e.inclusive !== t.inclusive || e.position.length !== t.position.length) return !1;
        for (let n = 0; n < e.position.length; n++) if (!as(e.position[n], t.position[n])) return !1;
        return !0;
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ns {
        constructor(e, t = 'asc') {
          (this.field = e), (this.dir = t);
        }
      }
      function Rs(e, t) {
        return e.dir === t.dir && e.field.isEqual(t.field);
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ps {}
      class Ds extends Ps {
        constructor(e, t, n) {
          super(), (this.field = e), (this.op = t), (this.value = n);
        }
        static create(e, t, n) {
          return e.isKeyField()
            ? 'in' === t || 'not-in' === t
              ? this.createKeyFieldInFilter(e, t, n)
              : new zs(e, t, n)
            : 'array-contains' === t
              ? new Ks(e, n)
              : 'in' === t
                ? new Qs(e, n)
                : 'not-in' === t
                  ? new Ys(e, n)
                  : 'array-contains-any' === t
                    ? new Xs(e, n)
                    : new Ds(e, t, n);
        }
        static createKeyFieldInFilter(e, t, n) {
          return 'in' === t ? new Gs(e, n) : new Ws(e, n);
        }
        matches(e) {
          const t = e.data.field(this.field);
          return '!=' === this.op
            ? null !== t && this.matchesComparison(cs(t, this.value))
            : null !== t && ss(this.value) === ss(t) && this.matchesComparison(cs(t, this.value));
        }
        matchesComparison(e) {
          switch (this.op) {
            case '<':
              return e < 0;
            case '<=':
              return e <= 0;
            case '==':
              return 0 === e;
            case '!=':
              return 0 !== e;
            case '>':
              return e > 0;
            case '>=':
              return e >= 0;
            default:
              return oi();
          }
        }
        isInequality() {
          return ['<', '<=', '>', '>=', '!=', 'not-in'].indexOf(this.op) >= 0;
        }
        getFlattenedFilters() {
          return [this];
        }
        getFilters() {
          return [this];
        }
        getFirstInequalityField() {
          return this.isInequality() ? this.field : null;
        }
      }
      class Ls extends Ps {
        constructor(e, t) {
          super(), (this.filters = e), (this.op = t), (this.lt = null);
        }
        static create(e, t) {
          return new Ls(e, t);
        }
        matches(e) {
          return js(this) ? void 0 === this.filters.find(t => !t.matches(e)) : void 0 !== this.filters.find(t => t.matches(e));
        }
        getFlattenedFilters() {
          return null !== this.lt || (this.lt = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.lt;
        }
        getFilters() {
          return Object.assign([], this.filters);
        }
        getFirstInequalityField() {
          const e = this.ft(e => e.isInequality());
          return null !== e ? e.field : null;
