            ? (function (e) {
                return Ds.create(
                  _c(e.fieldFilter.field),
                  (function (e) {
                    switch (e) {
                      case 'EQUAL':
                        return '==';
                      case 'NOT_EQUAL':
                        return '!=';
                      case 'GREATER_THAN':
                        return '>';
                      case 'GREATER_THAN_OR_EQUAL':
                        return '>=';
                      case 'LESS_THAN':
                        return '<';
                      case 'LESS_THAN_OR_EQUAL':
                        return '<=';
                      case 'ARRAY_CONTAINS':
                        return 'array-contains';
                      case 'IN':
                        return 'in';
                      case 'NOT_IN':
                        return 'not-in';
                      case 'ARRAY_CONTAINS_ANY':
                        return 'array-contains-any';
                      default:
                        return oi();
                    }
                  })(e.fieldFilter.op),
                  e.fieldFilter.value
                );
              })(e)
            : void 0 !== e.compositeFilter
              ? (function (e) {
                  return Ls.create(
                    e.compositeFilter.filters.map(e => mc(e)),
                    (function (e) {
                      switch (e) {
                        case 'AND':
                          return 'and';
                        case 'OR':
                          return 'or';
                        default:
                          return oi();
                      }
                    })(e.compositeFilter.op)
                  );
                })(e)
              : oi();
      }
      function vc(e) {
        return $u[e];
      }
      function yc(e) {
        return qu[e];
      }
      function wc(e) {
        return zu[e];
      }
      function bc(e) {
        return { fieldPath: e.canonicalString() };
      }
      function _c(e) {
        return Oi.fromServerFormat(e.fieldPath);
      }
      function Ic(e) {
        return e instanceof Ds
          ? (function (e) {
              if ('==' === e.op) {
                if (vs(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NAN' } };
                if (ms(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NULL' } };
              } else if ('!=' === e.op) {
                if (vs(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NOT_NAN' } };
                if (ms(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NOT_NULL' } };
              }
              return { fieldFilter: { field: bc(e.field), op: yc(e.op), value: e.value } };
            })(e)
          : e instanceof Ls
            ? (function (e) {
                const t = e.getFilters().map(e => Ic(e));
                return 1 === t.length ? t[0] : { compositeFilter: { op: wc(e.op), filters: t } };
              })(e)
            : oi();
      }
      function Ec(e) {
        const t = [];
        return e.fields.forEach(e => t.push(e.canonicalString())), { fieldPaths: t };
      }
      function Sc(e) {
        return e.length >= 4 && 'projects' === e.get(0) && 'databases' === e.get(2);
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tc {
        constructor(e, t, n, r, i = Ai.min(), o = Ai.min(), s = Ko.EMPTY_BYTE_STRING, a = null) {
          (this.target = e),
            (this.targetId = t),
            (this.purpose = n),
            (this.sequenceNumber = r),
            (this.snapshotVersion = i),
            (this.lastLimboFreeSnapshotVersion = o),
            (this.resumeToken = s),
            (this.expectedCount = a);
        }
        withSequenceNumber(e) {
          return new Tc(
            this.target,
            this.targetId,
            this.purpose,
            e,
            this.snapshotVersion,
            this.lastLimboFreeSnapshotVersion,
            this.resumeToken,
            this.expectedCount
          );
        }
        withResumeToken(e, t) {
          return new Tc(this.target, this.targetId, this.purpose, this.sequenceNumber, t, this.lastLimboFreeSnapshotVersion, e, null);
        }
        withExpectedCount(e) {
          return new Tc(
            this.target,
            this.targetId,
            this.purpose,
            this.sequenceNumber,
            this.snapshotVersion,
            this.lastLimboFreeSnapshotVersion,
            this.resumeToken,
            e
          );
        }
        withLastLimboFreeSnapshotVersion(e) {
          return new Tc(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ac {
        constructor(e) {
          this.fe = e;
        }
      }
      function xc(e, t) {
        let n;
        if (t.document) n = sc(e.fe, t.document, !!t.hasCommittedMutations);
        else if (t.noDocument) {
          const e = Ni.fromSegments(t.noDocument.path),
            r = Nc(t.noDocument.readTime);
          (n = xs.newNoDocument(e, r)), t.hasCommittedMutations && n.setHasCommittedMutations();
        } else {
          if (!t.unknownDocument) return oi();
          {
            const e = Ni.fromSegments(t.unknownDocument.path),
              r = Nc(t.unknownDocument.version);
            n = xs.newUnknownDocument(e, r);
          }
        }
        return (
          t.readTime &&
            n.setReadTime(
              (function (e) {
                const t = new Ti(e[0], e[1]);
                return Ai.fromTimestamp(t);
              })(t.readTime)
            ),
          n
        );
      }
      function Cc(e, t) {
        const n = t.key,
          r = {
            prefixPath: n.getCollectionPath().popLast().toArray(),
            collectionGroup: n.collectionGroup,
            documentId: n.path.lastSegment(),
            readTime: kc(t.readTime),
            hasCommittedMutations: t.hasCommittedMutations
          };
        if (t.isFoundDocument())
          r.document = (function (e, t) {
            return {
              name: Zu(e, t.key),
              fields: t.data.value.mapValue.fields,
              updateTime: Hu(e, t.version.toTimestamp()),
              createTime: Hu(e, t.createTime.toTimestamp())
            };
          })(e.fe, t);
        else if (t.isNoDocument()) r.noDocument = { path: n.path.toArray(), readTime: Oc(t.version) };
        else {
          if (!t.isUnknownDocument()) return oi();
          r.unknownDocument = { path: n.path.toArray(), version: Oc(t.version) };
        }
        return r;
      }
      function kc(e) {
        const t = e.toTimestamp();
        return [t.seconds, t.nanoseconds];
      }
      function Oc(e) {
        const t = e.toTimestamp();
        return { seconds: t.seconds, nanoseconds: t.nanoseconds };
      }
      function Nc(e) {
        const t = new Ti(e.seconds, e.nanoseconds);
        return Ai.fromTimestamp(t);
      }
      function Rc(e, t) {
        const n = (t.baseMutations || []).map(t => lc(e.fe, t));
        for (let o = 0; o < t.mutations.length - 1; ++o) {
          const e = t.mutations[o];
          if (o + 1 < t.mutations.length && void 0 !== t.mutations[o + 1].transform) {
            const n = t.mutations[o + 1];
            (e.updateTransforms = n.transform.fieldTransforms), t.mutations.splice(o + 1, 1), ++o;
          }
        }
        const r = t.mutations.map(t => lc(e.fe, t)),
          i = Ti.fromMillis(t.localWriteTimeMs);
        return new vu(t.batchId, i, n, r);
      }
      function Pc(e) {
        const t = Nc(e.readTime),
          n = void 0 !== e.lastLimboFreeSnapshotVersion ? Nc(e.lastLimboFreeSnapshotVersion) : Ai.min();
        let r;
        var i;
        return (
          void 0 !== e.query.documents
            ? (si(1 === (i = e.query).documents.length), (r = pa(ua(nc(i.documents[0])))))
            : (r = (function (e) {
                return pa(pc(e));
              })(e.query)),
          new Tc(r, e.targetId, 'TargetPurposeListen', e.lastListenSequenceNumber, t, n, Ko.fromBase64String(e.resumeToken))
        );
      }
      function Dc(e, t) {
        const n = Oc(t.snapshotVersion),
          r = Oc(t.lastLimboFreeSnapshotVersion);
        let i;
        i = na(t.target) ? fc(e.fe, t.target) : dc(e.fe, t.target);
        const o = t.resumeToken.toBase64();
        return {
          targetId: t.targetId,
          canonicalId: ea(t.target),
          readTime: n,
          resumeToken: o,
          lastListenSequenceNumber: t.sequenceNumber,
          lastLimboFreeSnapshotVersion: r,
          query: i
        };
      }
      function Lc(e) {
        const t = pc({ parent: e.parent, structuredQuery: e.structuredQuery });
        return 'LAST' === e.limitType ? ma(t, t.limit, 'L') : t;
      }
      function jc(e, t) {
        return new wu(t.largestBatchId, lc(e.fe, t.overlayMutation));
      }
      function Mc(e, t) {
        const n = t.path.lastSegment();
        return [e, so(t.path.popLast()), n];
      }
      function Fc(e, t, n, r) {
        return {
          indexId: e,
          uid: t.uid || '',
          sequenceNumber: n,
          readTime: Oc(r.readTime),
          documentKey: so(r.documentKey.path),
          largestBatchId: r.largestBatchId
        };
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Uc {
        getBundleMetadata(e, t) {
          return Vc(e)
            .get(t)
            .next(e => {
              if (e) return { id: (t = e).bundleId, createTime: Nc(t.createTime), version: t.version };
              var t;
            });
        }
        saveBundleMetadata(e, t) {
          return Vc(e).put({ bundleId: (n = t).id, createTime: Oc(Yu(n.createTime)), version: n.version });
          var n;
        }
        getNamedQuery(e, t) {
          return Bc(e)
            .get(t)
            .next(e => {
              if (e) return { name: (t = e).name, query: Lc(t.bundledQuery), readTime: Nc(t.readTime) };
              var t;
            });
        }
        saveNamedQuery(e, t) {
          return Bc(e).put(
            (function (e) {
              return { name: e.name, readTime: Oc(Yu(e.readTime)), bundledQuery: e.bundledQuery };
            })(t)
          );
        }
      }
      function Vc(e) {
        return Lo(e, 'bundles');
      }
      function Bc(e) {
        return Lo(e, 'namedQueries');
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class $c {
        constructor(e, t) {
          (this.serializer = e), (this.userId = t);
        }
        static de(e, t) {
          const n = t.uid || '';
          return new $c(e, n);
        }
        getOverlay(e, t) {
          return qc(e)
            .get(Mc(this.userId, t))
            .next(e => (e ? jc(this.serializer, e) : null));
        }
        getOverlays(e, t) {
          const n = Oa();
          return zi
            .forEach(t, t =>
              this.getOverlay(e, t).next(e => {
                null !== e && n.set(t, e);
              })
            )
            .next(() => n);
        }
        saveOverlays(e, t, n) {
          const r = [];
          return (
            n.forEach((n, i) => {
              const o = new wu(t, i);
              r.push(this.we(e, o));
            }),
            zi.waitFor(r)
          );
        }
        removeOverlaysForBatchId(e, t, n) {
          const r = new Set();
          t.forEach(e => r.add(so(e.getCollectionPath())));
          const i = [];
          return (
            r.forEach(t => {
              const r = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, n + 1], !1, !0);
