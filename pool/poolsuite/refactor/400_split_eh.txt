                        let t = new $o(Oi.comparator),
                          n = !1;
                        for (const r of e.filters)
                          for (const e of r.getFlattenedFilters())
                            e.field.isKeyField() || ('array-contains' === e.op || 'array-contains-any' === e.op ? (n = !0) : (t = t.add(e.field)));
                        for (const r of e.orderBy) r.field.isKeyField() || (t = t.add(r.field));
                        return t.size + (n ? 1 : 0);
                      })(t) &&
                    (n = 1)
                  : (n = 0);
              })
            )
            .next(() =>
              (function (e) {
                return null !== e.limit;
              })(t) &&
              r.length > 1 &&
              2 === n
                ? 1
                : n
            );
        }
        mn(e, t) {
          const n = new Yc();
          for (const r of Di(e)) {
            const e = t.data.field(r.fieldPath);
            if (null == e) return null;
            const i = n.He(r.kind);
            zc.Ve._e(e, i);
          }
          return n.Qe();
        }
        dn(e) {
          const t = new Yc();
          return zc.Ve._e(e, t.He(0)), t.Qe();
        }
        gn(e, t) {
          const n = new Yc();
          return (
            zc.Ve._e(
              ds(this.databaseId, t),
              n.He(
                (function (e) {
                  const t = Di(e);
                  return 0 === t.length ? 0 : t[t.length - 1].kind;
                })(e)
              )
            ),
            n.Qe()
          );
        }
        ln(e, t, n) {
          if (null === n) return [];
          let r = [];
          r.push(new Yc());
          let i = 0;
          for (const o of Di(e)) {
            const e = n[i++];
            for (const n of r)
              if (this.yn(t, o.fieldPath) && gs(e)) r = this.pn(r, o, e);
              else {
                const t = n.He(o.kind);
                zc.Ve._e(e, t);
              }
          }
          return this.In(r);
        }
        hn(e, t, n) {
          return this.ln(e, t, n.position);
        }
        In(e) {
          const t = [];
          for (let n = 0; n < e.length; ++n) t[n] = e[n].Qe();
          return t;
        }
        pn(e, t, n) {
          const r = [...e],
            i = [];
          for (const o of n.arrayValue.values || [])
            for (const e of r) {
              const n = new Yc();
              n.seed(e.Qe()), zc.Ve._e(o, n.He(t.kind)), i.push(n);
            }
          return i;
        }
        yn(e, t) {
          return !!e.filters.find(e => e instanceof Ds && e.field.isEqual(t) && ('in' === e.op || 'not-in' === e.op));
        }
        getFieldIndexes(e, t) {
          const n = ml(e),
            r = vl(e);
          return (t ? n.j('collectionGroupIndex', IDBKeyRange.bound(t, t)) : n.j()).next(e => {
            const t = [];
            return zi
              .forEach(e, e =>
                r.get([e.indexId, this.uid]).next(n => {
                  t.push(
                    (function (e, t) {
                      const n = t ? new ji(t.sequenceNumber, new Ui(Nc(t.readTime), new Ni(co(t.documentKey)), t.largestBatchId)) : ji.empty(),
                        r = e.fields.map(([e, t]) => new Li(Oi.fromServerFormat(e), t));
                      return new Ri(e.indexId, e.collectionGroup, r, n);
                    })(e, n)
                  );
                })
              )
              .next(() => t);
          });
        }
        getNextCollectionGroupToUpdate(e) {
          return this.getFieldIndexes(e).next(e =>
            0 === e.length
              ? null
              : (e.sort((e, t) => {
                  const n = e.indexState.sequenceNumber - t.indexState.sequenceNumber;
                  return 0 !== n ? n : Ii(e.collectionGroup, t.collectionGroup);
                }),
                e[0].collectionGroup)
          );
        }
        updateCollectionGroup(e, t, n) {
          const r = ml(e),
            i = vl(e);
          return this.Tn(e).next(e =>
            r.j('collectionGroupIndex', IDBKeyRange.bound(t, t)).next(t => zi.forEach(t, t => i.put(Fc(t.indexId, this.user, e, n))))
          );
        }
        updateIndexEntries(e, t) {
          const n = new Map();
          return zi.forEach(t, (t, r) => {
            const i = n.get(t.collectionGroup);
            return (i ? zi.resolve(i) : this.getFieldIndexes(e, t.collectionGroup)).next(
              i => (
                n.set(t.collectionGroup, i),
                zi.forEach(i, n =>
                  this.En(e, t, n).next(t => {
                    const i = this.An(r, n);
                    return t.isEqual(i) ? zi.resolve() : this.vn(e, r, n, t, i);
                  })
                )
              )
            );
          });
        }
        Rn(e, t, n, r) {
          return gl(e).put({
            indexId: r.indexId,
            uid: this.uid,
            arrayValue: r.arrayValue,
            directionalValue: r.directionalValue,
            orderedDocumentKey: this.gn(n, t.key),
            documentKey: t.key.path.toArray()
          });
        }
        Pn(e, t, n, r) {
          return gl(e).delete([r.indexId, this.uid, r.arrayValue, r.directionalValue, this.gn(n, t.key), t.key.path.toArray()]);
        }
        En(e, t, n) {
          const r = gl(e);
          let i = new $o(Jc);
          return r
            .X({ index: 'documentKeyIndex', range: IDBKeyRange.only([n.indexId, this.uid, this.gn(n, t)]) }, (e, r) => {
              i = i.add(new Xc(n.indexId, t, r.arrayValue, r.directionalValue));
            })
            .next(() => i);
        }
        An(e, t) {
          let n = new $o(Jc);
          const r = this.mn(t, e);
          if (null == r) return n;
          const i = Pi(t);
          if (null != i) {
            const o = e.data.field(i.fieldPath);
            if (gs(o)) for (const i of o.arrayValue.values || []) n = n.add(new Xc(t.indexId, e.key, this.dn(i), r));
          } else n = n.add(new Xc(t.indexId, e.key, fl, r));
          return n;
        }
        vn(e, t, n, r, i) {
          ti('IndexedDbIndexManager', "Updating index entries for document '%s'", t.key);
          const o = [];
          return (
            (function (e, t, n, r, i) {
              const o = e.getIterator(),
                s = t.getIterator();
              let a = zo(o),
                u = zo(s);
              for (; a || u; ) {
                let e = !1,
                  t = !1;
                if (a && u) {
                  const r = n(a, u);
                  r < 0 ? (t = !0) : r > 0 && (e = !0);
                } else null != a ? (t = !0) : (e = !0);
                e ? (r(u), (u = zo(s))) : t ? (i(a), (a = zo(o))) : ((a = zo(o)), (u = zo(s)));
              }
            })(
              r,
              i,
              Jc,
              r => {
                o.push(this.Rn(e, t, n, r));
              },
              r => {
                o.push(this.Pn(e, t, n, r));
              }
            ),
            zi.waitFor(o)
          );
        }
        Tn(e) {
          let t = 1;
          return vl(e)
            .X({ index: 'sequenceNumberIndex', reverse: !0, range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER]) }, (e, n, r) => {
              r.done(), (t = n.sequenceNumber + 1);
            })
            .next(() => t);
        }
        createRange(e, t, n) {
          n = n.sort((e, t) => Jc(e, t)).filter((e, t, n) => !t || 0 !== Jc(e, n[t - 1]));
          const r = [];
          r.push(e);
          for (const o of n) {
            const n = Jc(o, e),
              i = Jc(o, t);
            if (0 === n) r[0] = e.Je();
            else if (n > 0 && i < 0) r.push(o), r.push(o.Je());
            else if (i > 0) break;
          }
          r.push(t);
          const i = [];
          for (let o = 0; o < r.length; o += 2) {
            if (this.bn(r[o], r[o + 1])) return [];
            const e = [r[o].indexId, this.uid, r[o].arrayValue, r[o].directionalValue, fl, []],
              t = [r[o + 1].indexId, this.uid, r[o + 1].arrayValue, r[o + 1].directionalValue, fl, []];
            i.push(IDBKeyRange.bound(e, t));
          }
          return i;
        }
        bn(e, t) {
          return Jc(e, t) > 0;
        }
        getMinOffsetFromCollectionGroup(e, t) {
          return this.getFieldIndexes(e, t).next(yl);
        }
        getMinOffset(e, t) {
          return zi.mapArray(this.cn(t), t => this.an(e, t).next(e => e || oi())).next(yl);
        }
      }
      function pl(e) {
        return Lo(e, 'collectionParents');
      }
      function gl(e) {
        return Lo(e, 'indexEntries');
      }
      function ml(e) {
        return Lo(e, 'indexConfiguration');
      }
      function vl(e) {
        return Lo(e, 'indexState');
      }
      function yl(e) {
        si(0 !== e.length);
        let t = e[0].indexState.offset,
          n = t.largestBatchId;
        for (let r = 1; r < e.length; r++) {
          const i = e[r].indexState.offset;
          Vi(i, t) < 0 && (t = i), n < i.largestBatchId && (n = i.largestBatchId);
        }
        return new Ui(t.readTime, t.documentKey, n);
      }
      /**
       * @license
       * Copyright 2018 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const wl = { didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0 };
      class bl {
        constructor(e, t, n) {
          (this.cacheSizeCollectionThreshold = e), (this.percentileToCollect = t), (this.maximumSequenceNumbersToCollect = n);
        }
        static withCacheSize(e) {
          return new bl(e, bl.DEFAULT_COLLECTION_PERCENTILE, bl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function _l(e, t, n) {
        const r = e.store('mutations'),
          i = e.store('documentMutations'),
          o = [],
          s = IDBKeyRange.only(n.batchId);
        let a = 0;
        const u = r.X({ range: s }, (e, t, n) => (a++, n.delete()));
        o.push(
          u.next(() => {
            si(1 === a);
          })
        );
        const c = [];
        for (const l of n.mutations) {
          const e = fo(t, l.key.path, n.batchId);
          o.push(i.delete(e)), c.push(l.key);
        }
        return zi.waitFor(o).next(() => c);
      }
      function Il(e) {
        if (!e) return 0;
        let t;
        if (e.document) t = e.document;
        else if (e.unknownDocument) t = e.unknownDocument;
        else {
          if (!e.noDocument) throw oi();
          t = e.noDocument;
        }
        return JSON.stringify(t).length;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ (bl.DEFAULT_COLLECTION_PERCENTILE = 10),
        (bl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3),
        (bl.DEFAULT = new bl(41943040, bl.DEFAULT_COLLECTION_PERCENTILE, bl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)),
        (bl.DISABLED = new bl(-1, 0, 0));
      class El {
        constructor(e, t, n, r) {
          (this.userId = e), (this.serializer = t), (this.indexManager = n), (this.referenceDelegate = r), (this.Vn = {});
        }
        static de(e, t, n, r) {
          si('' !== e.uid);
          const i = e.isAuthenticated() ? e.uid : '';
          return new El(i, t, n, r);
        }
        checkEmpty(e) {
          let t = !0;
          const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
          return Tl(e)
            .X({ index: 'userMutationsIndex', range: n }, (e, n, r) => {
              (t = !1), r.done();
            })
            .next(() => t);
        }
        addMutationBatch(e, t, n, r) {
          const i = Al(e),
            o = Tl(e);
          return o.add({}).next(s => {
            si('number' == typeof s);
            const a = new vu(s, t, n, r),
              u = (function (e, t, n) {
                const r = n.baseMutations.map(t => cc(e.fe, t)),
                  i = n.mutations.map(t => cc(e.fe, t));
                return { userId: t, batchId: n.batchId, localWriteTimeMs: n.localWriteTime.toMillis(), baseMutations: r, mutations: i };
              })(this.serializer, this.userId, a),
              c = [];
            let l = new $o((e, t) => Ii(e.canonicalString(), t.canonicalString()));
            for (const e of r) {
              const t = fo(this.userId, e.key.path, s);
              (l = l.add(e.key.path.popLast())), c.push(o.put(u)), c.push(i.put(t, po));
            }
            return (
              l.forEach(t => {
                c.push(this.indexManager.addToCollectionParentIndex(e, t));
              }),
              e.addOnCommittedListener(() => {
                this.Vn[s] = a.keys();
              }),
              zi.waitFor(c).next(() => a)
