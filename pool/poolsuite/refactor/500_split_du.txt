      }
      function Df(e) {
        return (
          e.Su ||
            ((e.Su = (function (e, t, n) {
              const r = ui(e);
              return r.fu(), new nf(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n);
              /**
               * @license
               * Copyright 2018 Google LLC
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *   http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */
            })(e.datastore, e.asyncQueue, { uo: yf.bind(null, e), ao: wf.bind(null, e), nu: bf.bind(null, e) })),
            e.Ru.push(async t => {
              t ? (e.Su.Qo(), gf(e) ? pf(e) : e.bu.set('Unknown')) : (await e.Su.stop(), vf(e));
            })),
          e.Su
        );
      }
      function Lf(e) {
        return (
          e.Du ||
            ((e.Du = (function (e, t, n) {
              const r = ui(e);
              return r.fu(), new rf(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n);
            })(e.datastore, e.asyncQueue, { uo: Cf.bind(null, e), ao: Nf.bind(null, e), au: kf.bind(null, e), cu: Of.bind(null, e) })),
            e.Ru.push(async t => {
              t
                ? (e.Du.Qo(), await Ef(e))
                : (await e.Du.stop(),
                  e.Eu.length > 0 && (ti('RemoteStore', `Stopping write stream with ${e.Eu.length} pending writes`), (e.Eu = [])));
            })),
          e.Du
        );
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class jf {
        constructor(e, t, n, r, i) {
          (this.asyncQueue = e),
            (this.timerId = t),
            (this.targetTimeMs = n),
            (this.op = r),
            (this.removalCallback = i),
            (this.deferred = new hi()),
            (this.then = this.deferred.promise.then.bind(this.deferred.promise)),
            this.deferred.promise.catch(e => {});
        }
        static createAndSchedule(e, t, n, r, i) {
          const o = Date.now() + n,
            s = new jf(e, t, o, r, i);
          return s.start(n), s;
        }
        start(e) {
          this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e);
        }
        skipDelay() {
          return this.handleDelayElapsed();
        }
        cancel(e) {
          null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new li(ci.CANCELLED, 'Operation cancelled' + (e ? ': ' + e : ''))));
        }
        handleDelayElapsed() {
          this.asyncQueue.enqueueAndForget(() =>
            null !== this.timerHandle ? (this.clearTimeout(), this.op().then(e => this.deferred.resolve(e))) : Promise.resolve()
          );
        }
        clearTimeout() {
          null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), (this.timerHandle = null));
        }
      }
      function Mf(e, t) {
        if ((ni('AsyncQueue', `${t}: ${e}`), Qi(e))) return new li(ci.UNAVAILABLE, `${t}: ${e}`);
        throw e;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ff {
        constructor(e) {
          (this.comparator = e ? (t, n) => e(t, n) || Ni.comparator(t.key, n.key) : (e, t) => Ni.comparator(e.key, t.key)),
            (this.keyedMap = Ca()),
            (this.sortedSet = new Uo(this.comparator));
        }
        static emptySet(e) {
          return new Ff(e.comparator);
        }
        has(e) {
          return null != this.keyedMap.get(e);
        }
        get(e) {
          return this.keyedMap.get(e);
        }
        first() {
          return this.sortedSet.minKey();
        }
        last() {
          return this.sortedSet.maxKey();
        }
        isEmpty() {
          return this.sortedSet.isEmpty();
        }
        indexOf(e) {
          const t = this.keyedMap.get(e);
          return t ? this.sortedSet.indexOf(t) : -1;
        }
        get size() {
          return this.sortedSet.size;
        }
        forEach(e) {
          this.sortedSet.inorderTraversal((t, n) => (e(t), !1));
        }
        add(e) {
          const t = this.delete(e.key);
          return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null));
        }
        delete(e) {
          const t = this.get(e);
          return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this;
        }
        isEqual(e) {
          if (!(e instanceof Ff)) return !1;
          if (this.size !== e.size) return !1;
          const t = this.sortedSet.getIterator(),
            n = e.sortedSet.getIterator();
          for (; t.hasNext(); ) {
            const e = t.getNext().key,
              r = n.getNext().key;
            if (!e.isEqual(r)) return !1;
          }
          return !0;
        }
        toString() {
          const e = [];
          return (
            this.forEach(t => {
              e.push(t.toString());
            }),
            0 === e.length ? 'DocumentSet ()' : 'DocumentSet (\n  ' + e.join('  \n') + '\n)'
          );
        }
        copy(e, t) {
          const n = new Ff();
          return (n.comparator = this.comparator), (n.keyedMap = e), (n.sortedSet = t), n;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Uf {
        constructor() {
          this.Cu = new Uo(Ni.comparator);
        }
        track(e) {
          const t = e.doc.key,
            n = this.Cu.get(t);
          n
            ? 0 !== e.type && 3 === n.type
              ? (this.Cu = this.Cu.insert(t, e))
              : 3 === e.type && 1 !== n.type
                ? (this.Cu = this.Cu.insert(t, { type: n.type, doc: e.doc }))
                : 2 === e.type && 2 === n.type
                  ? (this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }))
                  : 2 === e.type && 0 === n.type
                    ? (this.Cu = this.Cu.insert(t, { type: 0, doc: e.doc }))
                    : 1 === e.type && 0 === n.type
                      ? (this.Cu = this.Cu.remove(t))
                      : 1 === e.type && 2 === n.type
                        ? (this.Cu = this.Cu.insert(t, { type: 1, doc: n.doc }))
                        : 0 === e.type && 1 === n.type
                          ? (this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }))
                          : oi()
            : (this.Cu = this.Cu.insert(t, e));
        }
        xu() {
          const e = [];
          return (
            this.Cu.inorderTraversal((t, n) => {
              e.push(n);
            }),
            e
          );
        }
      }
      class Vf {
        constructor(e, t, n, r, i, o, s, a, u) {
          (this.query = e),
            (this.docs = t),
            (this.oldDocs = n),
            (this.docChanges = r),
            (this.mutatedKeys = i),
            (this.fromCache = o),
            (this.syncStateChanged = s),
            (this.excludesMetadataChanges = a),
            (this.hasCachedResults = u);
        }
        static fromInitialDocuments(e, t, n, r, i) {
          const o = [];
          return (
            t.forEach(e => {
              o.push({ type: 0, doc: e });
            }),
            new Vf(e, t, Ff.emptySet(t), o, n, r, !0, !1, i)
          );
        }
        get hasPendingWrites() {
          return !this.mutatedKeys.isEmpty();
        }
        isEqual(e) {
          if (
            !(
              this.fromCache === e.fromCache &&
              this.hasCachedResults === e.hasCachedResults &&
              this.syncStateChanged === e.syncStateChanged &&
              this.mutatedKeys.isEqual(e.mutatedKeys) &&
              va(this.query, e.query) &&
              this.docs.isEqual(e.docs) &&
              this.oldDocs.isEqual(e.oldDocs)
            )
          )
            return !1;
          const t = this.docChanges,
            n = e.docChanges;
          if (t.length !== n.length) return !1;
          for (let r = 0; r < t.length; r++) if (t[r].type !== n[r].type || !t[r].doc.isEqual(n[r].doc)) return !1;
          return !0;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Bf {
        constructor() {
          (this.Nu = void 0), (this.listeners = []);
        }
      }
      class $f {
        constructor() {
          (this.queries = new Sa(e => ya(e), va)), (this.onlineState = 'Unknown'), (this.ku = new Set());
        }
      }
      async function qf(e, t) {
        const n = ui(e),
          r = t.query;
        let i = !1,
          o = n.queries.get(r);
        if ((o || ((i = !0), (o = new Bf())), i))
          try {
            o.Nu = await n.onListen(r);
          } catch (e) {
            const n = Mf(e, `Initialization of query '${wa(t.query)}' failed`);
            return void t.onError(n);
          }
        n.queries.set(r, o), o.listeners.push(t), t.Mu(n.onlineState), o.Nu && t.$u(o.Nu) && Hf(n);
      }
      async function zf(e, t) {
        const n = ui(e),
          r = t.query;
        let i = !1;
        const o = n.queries.get(r);
        if (o) {
          const e = o.listeners.indexOf(t);
          e >= 0 && (o.listeners.splice(e, 1), (i = 0 === o.listeners.length));
        }
        if (i) return n.queries.delete(r), n.onUnlisten(r);
      }
      function Gf(e, t) {
        const n = ui(e);
        let r = !1;
        for (const i of t) {
          const e = i.query,
            t = n.queries.get(e);
          if (t) {
            for (const e of t.listeners) e.$u(i) && (r = !0);
            t.Nu = i;
          }
        }
        r && Hf(n);
      }
      function Wf(e, t, n) {
        const r = ui(e),
          i = r.queries.get(t);
        if (i) for (const o of i.listeners) o.onError(n);
        r.queries.delete(t);
      }
      function Hf(e) {
        e.ku.forEach(e => {
          e.next();
        });
      }
      class Kf {
        constructor(e, t, n) {
          (this.query = e), (this.Ou = t), (this.Fu = !1), (this.Bu = null), (this.onlineState = 'Unknown'), (this.options = n || {});
        }
        $u(e) {
          if (!this.options.includeMetadataChanges) {
            const t = [];
            for (const n of e.docChanges) 3 !== n.type && t.push(n);
            e = new Vf(e.query, e.docs, e.oldDocs, t, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults);
          }
          let t = !1;
          return this.Fu ? this.Lu(e) && (this.Ou.next(e), (t = !0)) : this.qu(e, this.onlineState) && (this.Uu(e), (t = !0)), (this.Bu = e), t;
        }
        onError(e) {
          this.Ou.error(e);
        }
        Mu(e) {
          this.onlineState = e;
          let t = !1;
          return this.Bu && !this.Fu && this.qu(this.Bu, e) && (this.Uu(this.Bu), (t = !0)), t;
        }
        qu(e, t) {
          if (!e.fromCache) return !0;
          const n = 'Offline' !== t;
          return (!this.options.Ku || !n) && (!e.docs.isEmpty() || e.hasCachedResults || 'Offline' === t);
        }
        Lu(e) {
          if (e.docChanges.length > 0) return !0;
          const t = this.Bu && this.Bu.hasPendingWrites !== e.hasPendingWrites;
          return !(!e.syncStateChanged && !t) && !0 === this.options.includeMetadataChanges;
        }
        Uu(e) {
          (e = Vf.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults)), (this.Fu = !0), this.Ou.next(e);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Qf {
        constructor(e, t) {
          (this.Gu = e), (this.byteLength = t);
        }
        Qu() {
          return 'metadata' in this.Gu;
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Yf {
        constructor(e) {
          this.serializer = e;
        }
        rr(e) {
          return ec(this.serializer, e);
        }
        ur(e) {
          return e.metadata.exists ? sc(this.serializer, e.document, !1) : xs.newNoDocument(this.rr(e.metadata.name), this.cr(e.metadata.readTime));
        }
        cr(e) {
          return Yu(e);
        }
      }
      class Xf {
        constructor(e, t, n) {
          (this.ju = e),
            (this.localStore = t),
            (this.serializer = n),
            (this.queries = []),
            (this.documents = []),
            (this.collectionGroups = new Set()),
            (this.progress = Jf(e));
        }
        zu(e) {
          this.progress.bytesLoaded += e.byteLength;
          let t = this.progress.documentsLoaded;
          if (e.Gu.namedQuery) this.queries.push(e.Gu.namedQuery);
          else if (e.Gu.documentMetadata) {
            this.documents.push({ metadata: e.Gu.documentMetadata }), e.Gu.documentMetadata.exists || ++t;
            const n = Ci.fromString(e.Gu.documentMetadata.name);
            this.collectionGroups.add(n.get(n.length - 2));
          } else e.Gu.document && ((this.documents[this.documents.length - 1].document = e.Gu.document), ++t);
          return t !== this.progress.documentsLoaded ? ((this.progress.documentsLoaded = t), Object.assign({}, this.progress)) : null;
        }
        Wu(e) {
          const t = new Map(),
            n = new Yf(this.serializer);
          for (const r of e)
            if (r.metadata.queries) {
              const e = n.rr(r.metadata.name);
              for (const n of r.metadata.queries) {
                const r = (t.get(n) || La()).add(e);
                t.set(n, r);
              }
            }
          return t;
        }
        async complete() {
          const e = await Nh(this.localStore, new Yf(this.serializer), this.documents, this.ju.id),
            t = this.Wu(this.documents);
          for (const n of this.queries) await Rh(this.localStore, n, t.get(n.name));
          return (this.progress.taskState = 'Success'), { progress: this.progress, Hu: this.collectionGroups, Ju: e };
        }
      }
      function Jf(e) {
        return { taskState: 'Running', documentsLoaded: 0, bytesLoaded: 0, totalDocuments: e.totalDocuments, totalBytes: e.totalBytes };
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Zf {
        constructor(e) {
          this.key = e;
