       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ async function J(e, t, n = !1) {
        if (n) return t;
        try {
          return await t;
        } catch (r) {
          throw (r instanceof i.ZR && Z(r) && e.auth.currentUser === e && (await e.auth.signOut()), r);
        }
      }
      function Z({ code: e }) {
        return 'auth/user-disabled' === e || 'auth/user-token-expired' === e;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ee {
        constructor(e) {
          (this.user = e), (this.isRunning = !1), (this.timerId = null), (this.errorBackoff = 3e4);
        }
        _start() {
          this.isRunning || ((this.isRunning = !0), this.schedule());
        }
        _stop() {
          this.isRunning && ((this.isRunning = !1), null !== this.timerId && clearTimeout(this.timerId));
        }
        getInterval(e) {
          var t;
          if (e) {
            const e = this.errorBackoff;
            return (this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4)), e;
          }
          {
            this.errorBackoff = 3e4;
            const e = null !== (t = this.user.stsTokenManager.expirationTime) && void 0 !== t ? t : 0,
              n = e - Date.now() - 3e5;
            return Math.max(0, n);
          }
        }
        schedule(e = !1) {
          if (!this.isRunning) return;
          const t = this.getInterval(e);
          this.timerId = setTimeout(async () => {
            await this.iteration();
          }, t);
        }
        async iteration() {
          try {
            await this.user.getIdToken(!0);
          } catch (e) {
            return void ('auth/network-request-failed' === (null === e || void 0 === e ? void 0 : e.code) && this.schedule(!0));
          }
          this.schedule();
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class te {
        constructor(e, t) {
          (this.createdAt = e), (this.lastLoginAt = t), this._initializeTime();
        }
        _initializeTime() {
          (this.lastSignInTime = H(this.lastLoginAt)), (this.creationTime = H(this.createdAt));
        }
        _copy(e) {
          (this.createdAt = e.createdAt), (this.lastLoginAt = e.lastLoginAt), this._initializeTime();
        }
        toJSON() {
          return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt };
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ async function ne(e) {
        var t;
        const n = e.auth,
          r = await e.getIdToken(),
          i = await J(e, W(n, { idToken: r }));
        S(null === i || void 0 === i ? void 0 : i.users.length, n, 'internal-error');
        const o = i.users[0];
        e._notifyReloadListener(o);
        const s = (null === (t = o.providerUserInfo) || void 0 === t ? void 0 : t.length) ? oe(o.providerUserInfo) : [],
          a = ie(e.providerData, s),
          u = e.isAnonymous,
          c = !(e.email && o.passwordHash) && !(null === a || void 0 === a ? void 0 : a.length),
          l = !!u && c,
          h = {
            uid: o.localId,
            displayName: o.displayName || null,
            photoURL: o.photoUrl || null,
            email: o.email || null,
            emailVerified: o.emailVerified || !1,
            phoneNumber: o.phoneNumber || null,
            tenantId: o.tenantId || null,
            providerData: a,
            metadata: new te(o.createdAt, o.lastLoginAt),
            isAnonymous: l
          };
        Object.assign(e, h);
      }
      async function re(e) {
        const t = (0, i.m9)(e);
        await ne(t), await t.auth._persistUserIfCurrent(t), t.auth._notifyListenersIfCurrent(t);
      }
      function ie(e, t) {
        const n = e.filter(e => !t.some(t => t.providerId === e.providerId));
        return [...n, ...t];
      }
      function oe(e) {
        return e.map(e => {
          var { providerId: t } = e,
            n = s(e, ['providerId']);
          return {
            providerId: t,
            uid: n.rawId || '',
            displayName: n.displayName || null,
            email: n.email || null,
            phoneNumber: n.phoneNumber || null,
            photoURL: n.photoUrl || null
          };
        });
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ async function se(e, t) {
        const n = await U(e, {}, async () => {
          const n = (0, i.xO)({ grant_type: 'refresh_token', refresh_token: t }).slice(1),
            { tokenApiHost: r, apiKey: o } = e.config,
            s = B(e, r, '/v1/token', `key=${o}`),
            a = await e._getAdditionalHeaders();
          return (a['Content-Type'] = 'application/x-www-form-urlencoded'), D.fetch()(s, { method: 'POST', headers: a, body: n });
        });
        return { accessToken: n.access_token, expiresIn: n.expires_in, refreshToken: n.refresh_token };
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ae {
        constructor() {
          (this.refreshToken = null), (this.accessToken = null), (this.expirationTime = null);
        }
        get isExpired() {
          return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
        }
        updateFromServerResponse(e) {
          S(e.idToken, 'internal-error'),
            S('undefined' !== typeof e.idToken, 'internal-error'),
            S('undefined' !== typeof e.refreshToken, 'internal-error');
          const t = 'expiresIn' in e && 'undefined' !== typeof e.expiresIn ? Number(e.expiresIn) : X(e.idToken);
          this.updateTokensAndExpiration(e.idToken, e.refreshToken, t);
        }
        async getToken(e, t = !1) {
          return (
            S(!this.accessToken || this.refreshToken, e, 'user-token-expired'),
            t || !this.accessToken || this.isExpired
              ? this.refreshToken
                ? (await this.refresh(e, this.refreshToken), this.accessToken)
                : null
              : this.accessToken
          );
        }
        clearRefreshToken() {
          this.refreshToken = null;
        }
        async refresh(e, t) {
          const { accessToken: n, refreshToken: r, expiresIn: i } = await se(e, t);
          this.updateTokensAndExpiration(n, r, Number(i));
        }
        updateTokensAndExpiration(e, t, n) {
          (this.refreshToken = t || null), (this.accessToken = e || null), (this.expirationTime = Date.now() + 1e3 * n);
        }
        static fromJSON(e, t) {
          const { refreshToken: n, accessToken: r, expirationTime: i } = t,
            o = new ae();
          return (
            n && (S('string' === typeof n, 'internal-error', { appName: e }), (o.refreshToken = n)),
            r && (S('string' === typeof r, 'internal-error', { appName: e }), (o.accessToken = r)),
            i && (S('number' === typeof i, 'internal-error', { appName: e }), (o.expirationTime = i)),
            o
          );
        }
        toJSON() {
          return { refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime };
        }
        _assign(e) {
          (this.accessToken = e.accessToken), (this.refreshToken = e.refreshToken), (this.expirationTime = e.expirationTime);
        }
        _clone() {
          return Object.assign(new ae(), this.toJSON());
        }
        _performRefresh() {
          return T('not implemented');
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function ue(e, t) {
        S('string' === typeof e || 'undefined' === typeof e, 'internal-error', { appName: t });
      }
      class ce {
        constructor(e) {
          var { uid: t, auth: n, stsTokenManager: r } = e,
            i = s(e, ['uid', 'auth', 'stsTokenManager']);
          (this.providerId = 'firebase'),
            (this.proactiveRefresh = new ee(this)),
            (this.reloadUserInfo = null),
            (this.reloadListener = null),
            (this.uid = t),
            (this.auth = n),
            (this.stsTokenManager = r),
            (this.accessToken = r.accessToken),
            (this.displayName = i.displayName || null),
            (this.email = i.email || null),
            (this.emailVerified = i.emailVerified || !1),
            (this.phoneNumber = i.phoneNumber || null),
            (this.photoURL = i.photoURL || null),
            (this.isAnonymous = i.isAnonymous || !1),
            (this.tenantId = i.tenantId || null),
            (this.providerData = i.providerData ? [...i.providerData] : []),
            (this.metadata = new te(i.createdAt || void 0, i.lastLoginAt || void 0));
        }
        async getIdToken(e) {
          const t = await J(this, this.stsTokenManager.getToken(this.auth, e));
          return (
            S(t, this.auth, 'internal-error'),
            this.accessToken !== t &&
              ((this.accessToken = t), await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)),
            t
          );
        }
        getIdTokenResult(e) {
          return K(this, e);
        }
        reload() {
          return re(this);
        }
        _assign(e) {
          this !== e &&
            (S(this.uid === e.uid, this.auth, 'internal-error'),
            (this.displayName = e.displayName),
            (this.photoURL = e.photoURL),
            (this.email = e.email),
            (this.emailVerified = e.emailVerified),
            (this.phoneNumber = e.phoneNumber),
            (this.isAnonymous = e.isAnonymous),
            (this.tenantId = e.tenantId),
            (this.providerData = e.providerData.map(e => Object.assign({}, e))),
            this.metadata._copy(e.metadata),
            this.stsTokenManager._assign(e.stsTokenManager));
        }
        _clone(e) {
          const t = new ce(Object.assign(Object.assign({}, this), { auth: e, stsTokenManager: this.stsTokenManager._clone() }));
          return t.metadata._copy(this.metadata), t;
        }
        _onReload(e) {
          S(!this.reloadListener, this.auth, 'internal-error'),
            (this.reloadListener = e),
            this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), (this.reloadUserInfo = null));
        }
        _notifyReloadListener(e) {
          this.reloadListener ? this.reloadListener(e) : (this.reloadUserInfo = e);
        }
        _startProactiveRefresh() {
          this.proactiveRefresh._start();
        }
        _stopProactiveRefresh() {
          this.proactiveRefresh._stop();
        }
        async _updateTokensIfNecessary(e, t = !1) {
          let n = !1;
          e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), (n = !0)),
            t && (await ne(this)),
            await this.auth._persistUserIfCurrent(this),
            n && this.auth._notifyListenersIfCurrent(this);
        }
        async delete() {
          const e = await this.getIdToken();
          return await J(this, z(this.auth, { idToken: e })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut();
        }
        toJSON() {
          return Object.assign(
            Object.assign(
              {
                uid: this.uid,
                email: this.email || void 0,
                emailVerified: this.emailVerified,
                displayName: this.displayName || void 0,
                isAnonymous: this.isAnonymous,
                photoURL: this.photoURL || void 0,
                phoneNumber: this.phoneNumber || void 0,
                tenantId: this.tenantId || void 0,
                providerData: this.providerData.map(e => Object.assign({}, e)),
                stsTokenManager: this.stsTokenManager.toJSON(),
                _redirectEventId: this._redirectEventId
              },
              this.metadata.toJSON()
            ),
            { apiKey: this.auth.config.apiKey, appName: this.auth.name }
          );
        }
        get refreshToken() {
          return this.stsTokenManager.refreshToken || '';
        }
        static _fromJSON(e, t) {
          var n, r, i, o, s, a, u, c;
          const l = null !== (n = t.displayName) && void 0 !== n ? n : void 0,
            h = null !== (r = t.email) && void 0 !== r ? r : void 0,
            f = null !== (i = t.phoneNumber) && void 0 !== i ? i : void 0,
            d = null !== (o = t.photoURL) && void 0 !== o ? o : void 0,
            p = null !== (s = t.tenantId) && void 0 !== s ? s : void 0,
            g = null !== (a = t._redirectEventId) && void 0 !== a ? a : void 0,
            m = null !== (u = t.createdAt) && void 0 !== u ? u : void 0,
            v = null !== (c = t.lastLoginAt) && void 0 !== c ? c : void 0,
