              e._key.isEqual(t._key) &&
              (null === e._document ? null === t._document : e._document.isEqual(t._document)) &&
              e._converter === t._converter
          : e instanceof im &&
              t instanceof im &&
              e._firestore === t._firestore &&
              Rp(e.query, t.query) &&
              e.metadata.isEqual(t.metadata) &&
              e._snapshot.isEqual(t._snapshot);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function am(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp);
        return ap(Fp(t), e._key).then(n => _m(t, e, n));
      }
      class um extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Yp(e);
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return new Tp(this.firestore, null, t);
        }
      }
      function cm(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return sp(n, e._key).then(n => new nm(t, r, e._key, n, new tm(null !== n && n.hasLocalMutations, !0), e.converter));
      }
      function lm(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp);
        return ap(Fp(t), e._key, { source: 'server' }).then(n => _m(t, e, n));
      }
      function hm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return kg(e._query), cp(n, e._query).then(n => new im(t, r, e, n));
      }
      function fm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return up(n, e._query).then(n => new im(t, r, e, n));
      }
      function dm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return cp(n, e._query, { source: 'server' }).then(n => new im(t, r, e, n));
      }
      function pm(e, t, n) {
        e = bp(e, Tp);
        const r = bp(e.firestore, Mp),
          i = Zg(e.converter, t, n);
        return bm(r, [ag(sg(r), 'setDoc', e._key, i, null !== e.converter, n).toMutation(e._key, nu.none())]);
      }
      function gm(e, t, n, ...r) {
        e = bp(e, Tp);
        const i = bp(e.firestore, Mp),
          o = sg(i);
        let s;
        return (
          (s = 'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp ? gg(o, 'updateDoc', e._key, t, n, r) : pg(o, 'updateDoc', e._key, t)),
          bm(i, [s.toMutation(e._key, nu.exists(!0))])
        );
      }
      function mm(e) {
        return bm(bp(e.firestore, Mp), [new gu(e._key, nu.none())]);
      }
      function vm(e, t) {
        const n = bp(e.firestore, Mp),
          r = Op(e),
          i = Zg(e.converter, t);
        return bm(n, [ag(sg(e.firestore), 'addDoc', r._key, i, null !== e.converter, {}).toMutation(r._key, nu.exists(!1))]).then(() => r);
      }
      function ym(e, ...t) {
        var n, r, i;
        e = (0, u.m9)(e);
        let o = { includeMetadataChanges: !1 },
          s = 0;
        'object' != typeof t[s] || Dp(t[s]) || ((o = t[s]), s++);
        const a = { includeMetadataChanges: o.includeMetadataChanges };
        if (Dp(t[s])) {
          const e = t[s];
          (t[s] = null === (n = e.next) || void 0 === n ? void 0 : n.bind(e)),
            (t[s + 1] = null === (r = e.error) || void 0 === r ? void 0 : r.bind(e)),
            (t[s + 2] = null === (i = e.complete) || void 0 === i ? void 0 : i.bind(e));
        }
        let c, l, h;
        if (e instanceof Tp)
          (l = bp(e.firestore, Mp)),
            (h = ua(e._key.path)),
            (c = {
              next: n => {
                t[s] && t[s](_m(l, e, n));
              },
              error: t[s + 1],
              complete: t[s + 2]
            });
        else {
          const n = bp(e, Ap);
          (l = bp(n.firestore, Mp)), (h = n._query);
          const r = new um(l);
          (c = {
            next: e => {
              t[s] && t[s](new im(l, r, n, e));
            },
            error: t[s + 1],
            complete: t[s + 2]
          }),
            kg(e._query);
        }
        return (function (e, t, n, r) {
          const i = new $d(r),
            o = new Kf(t, i, n);
          return (
            e.asyncQueue.enqueueAndForget(async () => qf(await rp(e), o)),
            () => {
              i.Dc(), e.asyncQueue.enqueueAndForget(async () => zf(await rp(e), o));
            }
          );
        })(Fp(l), h, a, c);
      }
      function wm(e, t) {
        return lp(Fp((e = bp(e, Mp))), Dp(t) ? t : { next: t });
      }
      function bm(e, t) {
        return (function (e, t) {
          const n = new hi();
          return e.asyncQueue.enqueueAndForget(async () => ud(await tp(e), t, n)), n.promise;
        })(Fp(e), t);
      }
      function _m(e, t, n) {
        const r = n.docs.get(t._key),
          i = new um(e);
        return new nm(e, i, t._key, r, new tm(n.hasPendingWrites, n.fromCache), t.converter);
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const Im = { maxAttempts: 5 };
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Em {
        constructor(e, t) {
          (this._firestore = e), (this._commitHandler = t), (this._mutations = []), (this._committed = !1), (this._dataReader = sg(e));
        }
        set(e, t, n) {
          this._verifyNotCommitted();
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'WriteBatch.set', r._key, i, null !== r.converter, n);
          return this._mutations.push(o.toMutation(r._key, nu.none())), this;
        }
        update(e, t, n, ...r) {
          this._verifyNotCommitted();
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'WriteBatch.update', i._key, t, n, r)
                : pg(this._dataReader, 'WriteBatch.update', i._key, t)),
            this._mutations.push(o.toMutation(i._key, nu.exists(!0))),
            this
          );
        }
        delete(e) {
          this._verifyNotCommitted();
          const t = Sm(e, this._firestore);
          return (this._mutations = this._mutations.concat(new gu(t._key, nu.none()))), this;
        }
        commit() {
          return (
            this._verifyNotCommitted(), (this._committed = !0), this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
          );
        }
        _verifyNotCommitted() {
          if (this._committed) throw new li(ci.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() has been called.');
        }
      }
      function Sm(e, t) {
        if ((e = (0, u.m9)(e)).firestore !== t)
          throw new li(ci.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');
        return e;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tm extends class {
        constructor(e, t) {
          (this._firestore = e), (this._transaction = t), (this._dataReader = sg(e));
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new em(this._firestore);
          return this._transaction.lookup([t._key]).then(e => {
            if (!e || 1 !== e.length) return oi();
            const r = e[0];
            if (r.isFoundDocument()) return new Ag(this._firestore, n, r.key, r, t.converter);
            if (r.isNoDocument()) return new Ag(this._firestore, n, t._key, null, t.converter);
            throw oi();
          });
        }
        set(e, t, n) {
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'Transaction.set', r._key, i, null !== r.converter, n);
          return this._transaction.set(r._key, o), this;
        }
        update(e, t, n, ...r) {
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'Transaction.update', i._key, t, n, r)
                : pg(this._dataReader, 'Transaction.update', i._key, t)),
            this._transaction.update(i._key, o),
            this
          );
        }
        delete(e) {
          const t = Sm(e, this._firestore);
          return this._transaction.delete(t._key), this;
        }
      } {
        constructor(e, t) {
          super(e, t), (this._firestore = e);
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new um(this._firestore);
          return super.get(e).then(e => new nm(this._firestore, n, t._key, e._document, new tm(!1, !1), t.converter));
        }
      }
      function Am(e, t, n) {
        e = bp(e, Mp);
        const r = Object.assign(Object.assign({}, Im), n);
        return (
          (function (e) {
            if (e.maxAttempts < 1) throw new li(ci.INVALID_ARGUMENT, 'Max attempts must be at least 1');
          })(r),
          (function (e, t, n) {
            const r = new hi();
            return (
              e.asyncQueue.enqueueAndForget(async () => {
                const i = await np(e);
                new Gd(e.asyncQueue, i, n, t, r).run();
              }),
              r.promise
            );
          })(Fp(e), n => t(new Tm(e, n)), r)
        );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function xm() {
        return new ug('deleteField');
      }
      function Cm() {
        return new lg('serverTimestamp');
      }
      function km(...e) {
        return new hg('arrayUnion', e);
      }
      function Om(...e) {
        return new fg('arrayRemove', e);
      }
      function Nm(e) {
        return new dg('increment', e);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ !(function (e, t = !0) {
        !(function (e) {
          Xr = e;
        })(o.SDK_VERSION),
          (0, o._registerComponent)(
            new s.wA(
              'firestore',
              (e, { instanceIdentifier: n, options: r }) => {
                const i = e.getProvider('app').getImmediate(),
                  o = new Mp(
                    new gi(e.getProvider('auth-internal')),
                    new wi(e.getProvider('app-check-internal')),
                    (function (e, t) {
                      if (!Object.prototype.hasOwnProperty.apply(e.options, ['projectId']))
                        throw new li(ci.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
                      return new rs(e.options.projectId, t);
                    })(i, n),
                    i
                  );
                return (r = Object.assign({ useFetchStreams: t }, r)), o._setSettings(r), o;
              },
              'PUBLIC'
            ).setMultipleInstances(!0)
          ),
          (0, o.registerVersion)(Qr, '3.13.0', e),
          (0, o.registerVersion)(Qr, '3.13.0', 'esm2017');
      })();
      const Rm = '@firebase/firestore-compat',
        Pm = '0.3.12';
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function Dm(e, t) {
        if (void 0 === t) return { merge: !1 };
        if (void 0 !== t.mergeFields && void 0 !== t.merge)
          throw new li('invalid-argument', `Invalid options passed to function ${e}(): You cannot specify both "merge" and "mergeFields".`);
        return t;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Lm() {
        if ('undefined' === typeof Uint8Array) throw new li('unimplemented', 'Uint8Arrays are not available in this environment.');
      }
      function jm() {
        if (!Ho()) throw new li('unimplemented', 'Blobs are unavailable in Firestore in this environment.');
      }
      class Mm {
        constructor(e) {
          this._delegate = e;
        }
        static fromBase64String(e) {
          return jm(), new Mm(Yp.fromBase64String(e));
        }
        static fromUint8Array(e) {
          return Lm(), new Mm(Yp.fromUint8Array(e));
        }
        toBase64() {
          return jm(), this._delegate.toBase64();
        }
        toUint8Array() {
          return Lm(), this._delegate.toUint8Array();
        }
        isEqual(e) {
          return this._delegate.isEqual(e._delegate);
        }
        toString() {
          return 'Blob(base64: ' + this.toBase64() + ')';
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
