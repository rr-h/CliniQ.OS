            (this.localCache = {}),
            (this.pollTimer = null),
            (this.pendingWrites = 0),
            (this.receiver = null),
            (this.sender = null),
            (this.serviceWorkerReceiverAvailable = !1),
            (this.activeServiceWorker = null),
            (this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(
              () => {},
              () => {}
            ));
        }
        async _openDb() {
          return this.db || (this.db = await gr()), this.db;
        }
        async _withRetries(e) {
          let t = 0;
          while (1)
            try {
              const t = await this._openDb();
              return await e(t);
            } catch (n) {
              if (t++ > br) throw n;
              this.db && (this.db.close(), (this.db = void 0));
            }
        }
        async initializeServiceWorkerMessaging() {
          return ir() ? this.initializeReceiver() : this.initializeSender();
        }
        async initializeReceiver() {
          (this.receiver = Zn._getInstance(ar())),
            this.receiver._subscribe('keyChanged', async (e, t) => {
              const n = await this._poll();
              return { keyProcessed: n.includes(t.key) };
            }),
            this.receiver._subscribe('ping', async (e, t) => ['keyChanged']);
        }
        async initializeSender() {
          var e, t;
          if (((this.activeServiceWorker = await or()), !this.activeServiceWorker)) return;
          this.sender = new tr(this.activeServiceWorker);
          const n = await this.sender._send('ping', {}, 800);
          n &&
            (null === (e = n[0]) || void 0 === e ? void 0 : e.fulfilled) &&
            (null === (t = n[0]) || void 0 === t ? void 0 : t.value.includes('keyChanged')) &&
            (this.serviceWorkerReceiverAvailable = !0);
        }
        async notifyServiceWorker(e) {
          if (this.sender && this.activeServiceWorker && sr() === this.activeServiceWorker)
            try {
              await this.sender._send('keyChanged', { key: e }, this.serviceWorkerReceiverAvailable ? 800 : 50);
            } catch (t) {}
        }
        async _isAvailable() {
          try {
            if (!indexedDB) return !1;
            const e = await gr();
            return await mr(e, qn, '1'), await yr(e, qn), !0;
          } catch (e) {}
          return !1;
        }
        async _withPendingWrite(e) {
          this.pendingWrites++;
          try {
            await e();
          } finally {
            this.pendingWrites--;
          }
        }
        async _set(e, t) {
          return this._withPendingWrite(
            async () => (await this._withRetries(n => mr(n, e, t)), (this.localCache[e] = t), this.notifyServiceWorker(e))
          );
        }
        async _get(e) {
          const t = await this._withRetries(t => vr(t, e));
          return (this.localCache[e] = t), t;
        }
        async _remove(e) {
          return this._withPendingWrite(async () => (await this._withRetries(t => yr(t, e)), delete this.localCache[e], this.notifyServiceWorker(e)));
        }
        async _poll() {
          const e = await this._withRetries(e => {
            const t = dr(e, !1).getAll();
            return new fr(t).toPromise();
          });
          if (!e) return [];
          if (0 !== this.pendingWrites) return [];
          const t = [],
            n = new Set();
          for (const { fbase_key: r, value: i } of e)
            n.add(r), JSON.stringify(this.localCache[r]) !== JSON.stringify(i) && (this.notifyListeners(r, i), t.push(r));
          for (const r of Object.keys(this.localCache)) this.localCache[r] && !n.has(r) && (this.notifyListeners(r, null), t.push(r));
          return t;
        }
        notifyListeners(e, t) {
          this.localCache[e] = t;
          const n = this.listeners[e];
          if (n) for (const r of Array.from(n)) r(t);
        }
        startPolling() {
          this.stopPolling(), (this.pollTimer = setInterval(async () => this._poll(), wr));
        }
        stopPolling() {
          this.pollTimer && (clearInterval(this.pollTimer), (this.pollTimer = null));
        }
        _addListener(e, t) {
          0 === Object.keys(this.listeners).length && this.startPolling(),
            this.listeners[e] || ((this.listeners[e] = new Set()), this._get(e)),
            this.listeners[e].add(t);
        }
        _removeListener(e, t) {
          this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]),
            0 === Object.keys(this.listeners).length && this.stopPolling();
        }
      }
      _r.type = 'LOCAL';
      const Ir = _r;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Er(e, t) {
        return F(e, 'POST', '/v2/accounts/mfaSignIn:start', M(e, t));
      }
      function Sr(e, t) {
        return F(e, 'POST', '/v2/accounts/mfaSignIn:finalize', M(e, t));
      }
      function Tr(e, t) {
        return F(e, 'POST', '/v2/accounts/mfaSignIn:finalize', M(e, t));
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Ar = 500,
        xr = 6e4,
        Cr = 1e12;
      class kr {
        constructor(e) {
          (this.auth = e), (this.counter = Cr), (this._widgets = new Map());
        }
        render(e, t) {
          const n = this.counter;
          return this._widgets.set(n, new Or(e, this.auth.name, t || {})), this.counter++, n;
        }
        reset(e) {
          var t;
          const n = e || Cr;
          null === (t = this._widgets.get(n)) || void 0 === t || t.delete(), this._widgets.delete(n);
        }
        getResponse(e) {
          var t;
          const n = e || Cr;
          return (null === (t = this._widgets.get(n)) || void 0 === t ? void 0 : t.getResponse()) || '';
        }
        async execute(e) {
          var t;
          const n = e || Cr;
          return null === (t = this._widgets.get(n)) || void 0 === t || t.execute(), '';
        }
      }
      class Or {
        constructor(e, t, n) {
          (this.params = n),
            (this.timerId = null),
            (this.deleted = !1),
            (this.responseToken = null),
            (this.clickHandler = () => {
              this.execute();
            });
          const r = 'string' === typeof e ? document.getElementById(e) : e;
          S(r, 'argument-error', { appName: t }),
            (this.container = r),
            (this.isVisible = 'invisible' !== this.params.size),
            this.isVisible ? this.execute() : this.container.addEventListener('click', this.clickHandler);
        }
        getResponse() {
          return this.checkIfDeleted(), this.responseToken;
        }
        delete() {
          this.checkIfDeleted(),
            (this.deleted = !0),
            this.timerId && (clearTimeout(this.timerId), (this.timerId = null)),
            this.container.removeEventListener('click', this.clickHandler);
        }
        execute() {
          this.checkIfDeleted(),
            this.timerId ||
              (this.timerId = window.setTimeout(() => {
                this.responseToken = Nr(50);
                const { callback: e, 'expired-callback': t } = this.params;
                if (e)
                  try {
                    e(this.responseToken);
                  } catch (n) {}
                this.timerId = window.setTimeout(() => {
                  if (((this.timerId = null), (this.responseToken = null), t))
                    try {
                      t();
                    } catch (n) {}
                  this.isVisible && this.execute();
                }, xr);
              }, Ar));
        }
        checkIfDeleted() {
          if (this.deleted) throw new Error('reCAPTCHA mock was already deleted!');
        }
      }
      function Nr(e) {
        const t = [],
          n = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        for (let r = 0; r < e; r++) t.push(n.charAt(Math.floor(Math.random() * n.length)));
        return t.join('');
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Rr = Fe('rcb'),
        Pr = new R(3e4, 6e4),
        Dr = 'https://www.google.com/recaptcha/api.js?';
      class Lr {
        constructor() {
          var e;
          (this.hostLanguage = ''),
            (this.counter = 0),
            (this.librarySeparatelyLoaded = !!(null === (e = nr().grecaptcha) || void 0 === e ? void 0 : e.render));
        }
        load(e, t = '') {
          return (
            S(jr(t), e, 'argument-error'),
            this.shouldResolveImmediately(t) && Pe(nr().grecaptcha)
              ? Promise.resolve(nr().grecaptcha)
              : new Promise((n, r) => {
                  const o = nr().setTimeout(() => {
                    r(b(e, 'network-request-failed'));
                  }, Pr.get());
                  nr()[Rr] = () => {
                    nr().clearTimeout(o), delete nr()[Rr];
                    const i = nr().grecaptcha;
                    if (!i || !Pe(i)) return void r(b(e, 'internal-error'));
                    const s = i.render;
                    (i.render = (e, t) => {
                      const n = s(e, t);
                      return this.counter++, n;
                    }),
                      (this.hostLanguage = t),
                      n(i);
                  };
                  const s = `${Dr}?${(0, i.xO)({ onload: Rr, render: 'explicit', hl: t })}`;
                  Me(s).catch(() => {
                    clearTimeout(o), r(b(e, 'internal-error'));
                  });
                })
          );
        }
        clearedOneInstance() {
          this.counter--;
        }
        shouldResolveImmediately(e) {
          var t;
          return (
            !!(null === (t = nr().grecaptcha) || void 0 === t ? void 0 : t.render) &&
            (e === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded)
          );
        }
      }
      function jr(e) {
        return e.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(e);
      }
      class Mr {
        async load(e) {
          return new kr(e);
        }
        clearedOneInstance() {}
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Fr = 'recaptcha',
        Ur = { theme: 'light', type: 'image' };
      class Vr {
        constructor(e, t = Object.assign({}, Ur), n) {
          (this.parameters = t),
            (this.type = Fr),
            (this.destroyed = !1),
            (this.widgetId = null),
            (this.tokenChangeListeners = new Set()),
            (this.renderPromise = null),
            (this.recaptcha = null),
            (this.auth = We(n)),
            (this.isInvisible = 'invisible' === this.parameters.size),
            S('undefined' !== typeof document, this.auth, 'operation-not-supported-in-this-environment');
          const r = 'string' === typeof e ? document.getElementById(e) : e;
          S(r, this.auth, 'argument-error'),
            (this.container = r),
            (this.parameters.callback = this.makeTokenCallback(this.parameters.callback)),
            (this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new Mr() : new Lr()),
            this.validateStartingState();
        }
        async verify() {
          this.assertNotDestroyed();
          const e = await this.render(),
            t = this.getAssertedRecaptcha(),
            n = t.getResponse(e);
          return (
            n ||
            new Promise(n => {
              const r = e => {
                e && (this.tokenChangeListeners.delete(r), n(e));
              };
              this.tokenChangeListeners.add(r), this.isInvisible && t.execute(e);
            })
          );
        }
        render() {
          try {
            this.assertNotDestroyed();
          } catch (e) {
            return Promise.reject(e);
          }
          return (
            this.renderPromise ||
              (this.renderPromise = this.makeRenderPromise().catch(e => {
                throw ((this.renderPromise = null), e);
              })),
            this.renderPromise
          );
        }
        _reset() {
          this.assertNotDestroyed(), null !== this.widgetId && this.getAssertedRecaptcha().reset(this.widgetId);
        }
        clear() {
          this.assertNotDestroyed(),
            (this.destroyed = !0),
            this._recaptchaLoader.clearedOneInstance(),
            this.isInvisible ||
              this.container.childNodes.forEach(e => {
                this.container.removeChild(e);
              });
        }
        validateStartingState() {
          S(!this.parameters.sitekey, this.auth, 'argument-error'),
            S(this.isInvisible || !this.container.hasChildNodes(), this.auth, 'argument-error'),
            S('undefined' !== typeof document, this.auth, 'operation-not-supported-in-this-environment');
        }
        makeTokenCallback(e) {
          return t => {
            if ((this.tokenChangeListeners.forEach(e => e(t)), 'function' === typeof e)) e(t);
            else if ('string' === typeof e) {
              const n = nr()[e];
              'function' === typeof n && n(t);
            }
          };
        }
        assertNotDestroyed() {
          S(!this.destroyed, this.auth, 'internal-error');
        }
        async makeRenderPromise() {
          if ((await this.init(), !this.widgetId)) {
            let e = this.container;
            if (!this.isInvisible) {
              const t = document.createElement('div');
              e.appendChild(t), (e = t);
            }
            this.widgetId = this.getAssertedRecaptcha().render(e, this.parameters);
          }
          return this.widgetId;
        }
        async init() {
          S(C() && !ir(), this.auth, 'internal-error'),
            await Br(),
            (this.recaptcha = await this._recaptchaLoader.load(this.auth, this.auth.languageCode || void 0));
          const e = await Ne(this.auth);
          S(e, this.auth, 'internal-error'), (this.parameters.sitekey = e);
        }
        getAssertedRecaptcha() {
          return S(this.recaptcha, this.auth, 'internal-error'), this.recaptcha;
        }
      }
      function Br() {
        let e = null;
        return new Promise(t => {
          'complete' !== document.readyState ? ((e = () => t()), window.addEventListener('load', e)) : t();
        }).catch(t => {
          throw (e && window.removeEventListener('load', e), t);
        });
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class $r {
        constructor(e, t) {
          (this.verificationId = e), (this.onConfirmation = t);
        }
        confirm(e) {
          const t = _t._fromVerification(this.verificationId, e);
          return this.onConfirmation(t);
        }
      }
      async function qr(e, t, n) {
        const r = We(e),
          o = await Wr(r, t, (0, i.m9)(n));
        return new $r(o, e => Qt(r, e));
      }
      async function zr(e, t, n) {
        const r = (0, i.m9)(e);
        await Wt(!1, r, 'phone');
        const o = await Wr(r.auth, t, (0, i.m9)(n));
        return new $r(o, e => Yt(r, e));
      }
      async function Gr(e, t, n) {
        const r = (0, i.m9)(e),
          o = await Wr(r.auth, t, (0, i.m9)(n));
        return new $r(o, e => Xt(r, e));
      }
      async function Wr(e, t, n) {
        var r;
        const i = await n.verify();
        try {
          let o;
          if (
            (S('string' === typeof i, e, 'argument-error'),
            S(n.type === Fr, e, 'argument-error'),
            (o = 'string' === typeof t ? { phoneNumber: t } : t),
            'session' in o)
          ) {
            const t = o.session;
            if ('phoneNumber' in o) {
              S('enroll' === t.type, e, 'internal-error');
              const n = await Ln(e, { idToken: t.credential, phoneEnrollmentInfo: { phoneNumber: o.phoneNumber, recaptchaToken: i } });
              return n.phoneSessionInfo.sessionInfo;
            }
            {
              S('signin' === t.type, e, 'internal-error');
              const n = (null === (r = o.multiFactorHint) || void 0 === r ? void 0 : r.uid) || o.multiFactorUid;
              S(n, e, 'missing-multi-factor-info');
              const s = await Er(e, { mfaPendingCredential: t.credential, mfaEnrollmentId: n, phoneSignInInfo: { recaptchaToken: i } });
              return s.phoneResponseInfo.sessionInfo;
            }
          }
          {
