       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ns {
        constructor(e, t, n, r, i, o, s, a, u) {
          (this.databaseId = e),
            (this.appId = t),
            (this.persistenceKey = n),
            (this.host = r),
            (this.ssl = i),
            (this.forceLongPolling = o),
            (this.autoDetectLongPolling = s),
            (this.longPollingOptions = a),
            (this.useFetchStreams = u);
        }
      }
      class rs {
        constructor(e, t) {
          (this.projectId = e), (this.database = t || '(default)');
        }
        static empty() {
          return new rs('', '');
        }
        get isDefaultDatabase() {
          return '(default)' === this.database;
        }
        isEqual(e) {
          return e instanceof rs && e.projectId === this.projectId && e.database === this.database;
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const is = { mapValue: { fields: { __type__: { stringValue: '__max__' } } } },
        os = { nullValue: 'NULL_VALUE' };
      function ss(e) {
        return 'nullValue' in e
          ? 0
          : 'booleanValue' in e
            ? 1
            : 'integerValue' in e || 'doubleValue' in e
              ? 2
              : 'timestampValue' in e
                ? 3
                : 'stringValue' in e
                  ? 5
                  : 'bytesValue' in e
                    ? 6
                    : 'referenceValue' in e
                      ? 7
                      : 'geoPointValue' in e
                        ? 8
                        : 'arrayValue' in e
                          ? 9
                          : 'mapValue' in e
                            ? Zo(e)
                              ? 4
                              : bs(e)
                                ? 9007199254740991
                                : 10
                            : oi();
      }
      function as(e, t) {
        if (e === t) return !0;
        const n = ss(e);
        if (n !== ss(t)) return !1;
        switch (n) {
          case 0:
          case 9007199254740991:
            return !0;
          case 1:
            return e.booleanValue === t.booleanValue;
          case 4:
            return ts(e).isEqual(ts(t));
          case 3:
            return (function (e, t) {
              if ('string' == typeof e.timestampValue && 'string' == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length)
                return e.timestampValue === t.timestampValue;
              const n = Yo(e.timestampValue),
                r = Yo(t.timestampValue);
              return n.seconds === r.seconds && n.nanos === r.nanos;
            })(e, t);
          case 5:
            return e.stringValue === t.stringValue;
          case 6:
            return (function (e, t) {
              return Jo(e.bytesValue).isEqual(Jo(t.bytesValue));
            })(e, t);
          case 7:
            return e.referenceValue === t.referenceValue;
          case 8:
            return (function (e, t) {
              return Xo(e.geoPointValue.latitude) === Xo(t.geoPointValue.latitude) && Xo(e.geoPointValue.longitude) === Xo(t.geoPointValue.longitude);
            })(e, t);
          case 2:
            return (function (e, t) {
              if ('integerValue' in e && 'integerValue' in t) return Xo(e.integerValue) === Xo(t.integerValue);
              if ('doubleValue' in e && 'doubleValue' in t) {
                const n = Xo(e.doubleValue),
                  r = Xo(t.doubleValue);
                return n === r ? io(n) === io(r) : isNaN(n) && isNaN(r);
              }
              return !1;
            })(e, t);
          case 9:
            return Ei(e.arrayValue.values || [], t.arrayValue.values || [], as);
          case 10:
            return (function (e, t) {
              const n = e.mapValue.fields || {},
                r = t.mapValue.fields || {};
              if (jo(n) !== jo(r)) return !1;
              for (const i in n) if (n.hasOwnProperty(i) && (void 0 === r[i] || !as(n[i], r[i]))) return !1;
              return !0;
            })(e, t);
          default:
            return oi();
        }
      }
      function us(e, t) {
        return void 0 !== (e.values || []).find(e => as(e, t));
      }
      function cs(e, t) {
        if (e === t) return 0;
        const n = ss(e),
          r = ss(t);
        if (n !== r) return Ii(n, r);
        switch (n) {
          case 0:
          case 9007199254740991:
            return 0;
          case 1:
            return Ii(e.booleanValue, t.booleanValue);
          case 2:
            return (function (e, t) {
              const n = Xo(e.integerValue || e.doubleValue),
                r = Xo(t.integerValue || t.doubleValue);
              return n < r ? -1 : n > r ? 1 : n === r ? 0 : isNaN(n) ? (isNaN(r) ? 0 : -1) : 1;
            })(e, t);
          case 3:
            return ls(e.timestampValue, t.timestampValue);
          case 4:
            return ls(ts(e), ts(t));
          case 5:
            return Ii(e.stringValue, t.stringValue);
          case 6:
            return (function (e, t) {
              const n = Jo(e),
                r = Jo(t);
              return n.compareTo(r);
            })(e.bytesValue, t.bytesValue);
          case 7:
            return (function (e, t) {
              const n = e.split('/'),
                r = t.split('/');
              for (let i = 0; i < n.length && i < r.length; i++) {
                const e = Ii(n[i], r[i]);
                if (0 !== e) return e;
              }
              return Ii(n.length, r.length);
            })(e.referenceValue, t.referenceValue);
          case 8:
            return (function (e, t) {
              const n = Ii(Xo(e.latitude), Xo(t.latitude));
              return 0 !== n ? n : Ii(Xo(e.longitude), Xo(t.longitude));
            })(e.geoPointValue, t.geoPointValue);
          case 9:
            return (function (e, t) {
              const n = e.values || [],
                r = t.values || [];
              for (let i = 0; i < n.length && i < r.length; ++i) {
                const e = cs(n[i], r[i]);
                if (e) return e;
              }
              return Ii(n.length, r.length);
            })(e.arrayValue, t.arrayValue);
          case 10:
            return (function (e, t) {
              if (e === is.mapValue && t === is.mapValue) return 0;
              if (e === is.mapValue) return 1;
              if (t === is.mapValue) return -1;
              const n = e.fields || {},
                r = Object.keys(n),
                i = t.fields || {},
                o = Object.keys(i);
              r.sort(), o.sort();
              for (let s = 0; s < r.length && s < o.length; ++s) {
                const e = Ii(r[s], o[s]);
                if (0 !== e) return e;
                const t = cs(n[r[s]], i[o[s]]);
                if (0 !== t) return t;
              }
              return Ii(r.length, o.length);
            })(e.mapValue, t.mapValue);
          default:
            throw oi();
        }
      }
      function ls(e, t) {
        if ('string' == typeof e && 'string' == typeof t && e.length === t.length) return Ii(e, t);
        const n = Yo(e),
          r = Yo(t),
          i = Ii(n.seconds, r.seconds);
        return 0 !== i ? i : Ii(n.nanos, r.nanos);
      }
      function hs(e) {
        return fs(e);
      }
      function fs(e) {
        return 'nullValue' in e
          ? 'null'
          : 'booleanValue' in e
            ? '' + e.booleanValue
            : 'integerValue' in e
              ? '' + e.integerValue
              : 'doubleValue' in e
                ? '' + e.doubleValue
                : 'timestampValue' in e
                  ? (function (e) {
                      const t = Yo(e);
                      return `time(${t.seconds},${t.nanos})`;
                    })(e.timestampValue)
                  : 'stringValue' in e
                    ? e.stringValue
                    : 'bytesValue' in e
                      ? Jo(e.bytesValue).toBase64()
                      : 'referenceValue' in e
                        ? ((n = e.referenceValue), Ni.fromName(n).toString())
                        : 'geoPointValue' in e
                          ? `geo(${(t = e.geoPointValue).latitude},${t.longitude})`
                          : 'arrayValue' in e
                            ? (function (e) {
                                let t = '[',
                                  n = !0;
                                for (const r of e.values || []) n ? (n = !1) : (t += ','), (t += fs(r));
                                return t + ']';
                              })(e.arrayValue)
                            : 'mapValue' in e
                              ? (function (e) {
                                  const t = Object.keys(e.fields || {}).sort();
                                  let n = '{',
                                    r = !0;
                                  for (const i of t) r ? (r = !1) : (n += ','), (n += `${i}:${fs(e.fields[i])}`);
                                  return n + '}';
                                })(e.mapValue)
                              : oi();
        var t, n;
      }
      function ds(e, t) {
        return { referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}` };
      }
      function ps(e) {
        return !!e && 'integerValue' in e;
      }
      function gs(e) {
        return !!e && 'arrayValue' in e;
      }
      function ms(e) {
        return !!e && 'nullValue' in e;
      }
      function vs(e) {
        return !!e && 'doubleValue' in e && isNaN(Number(e.doubleValue));
      }
      function ys(e) {
        return !!e && 'mapValue' in e;
      }
      function ws(e) {
        if (e.geoPointValue) return { geoPointValue: Object.assign({}, e.geoPointValue) };
        if (e.timestampValue && 'object' == typeof e.timestampValue) return { timestampValue: Object.assign({}, e.timestampValue) };
        if (e.mapValue) {
          const t = { mapValue: { fields: {} } };
          return Mo(e.mapValue.fields, (e, n) => (t.mapValue.fields[e] = ws(n))), t;
        }
        if (e.arrayValue) {
          const t = { arrayValue: { values: [] } };
          for (let n = 0; n < (e.arrayValue.values || []).length; ++n) t.arrayValue.values[n] = ws(e.arrayValue.values[n]);
          return t;
        }
        return Object.assign({}, e);
      }
      function bs(e) {
        return '__max__' === (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue;
      }
      function _s(e) {
        return 'nullValue' in e
          ? os
          : 'booleanValue' in e
            ? { booleanValue: !1 }
            : 'integerValue' in e || 'doubleValue' in e
              ? { doubleValue: NaN }
              : 'timestampValue' in e
                ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } }
                : 'stringValue' in e
                  ? { stringValue: '' }
                  : 'bytesValue' in e
                    ? { bytesValue: '' }
                    : 'referenceValue' in e
                      ? ds(rs.empty(), Ni.empty())
                      : 'geoPointValue' in e
                        ? { geoPointValue: { latitude: -90, longitude: -180 } }
                        : 'arrayValue' in e
                          ? { arrayValue: {} }
                          : 'mapValue' in e
                            ? { mapValue: {} }
                            : oi();
      }
      function Is(e) {
        return 'nullValue' in e
          ? { booleanValue: !1 }
          : 'booleanValue' in e
            ? { doubleValue: NaN }
            : 'integerValue' in e || 'doubleValue' in e
              ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } }
              : 'timestampValue' in e
                ? { stringValue: '' }
                : 'stringValue' in e
                  ? { bytesValue: '' }
                  : 'bytesValue' in e
                    ? ds(rs.empty(), Ni.empty())
                    : 'referenceValue' in e
                      ? { geoPointValue: { latitude: -90, longitude: -180 } }
                      : 'geoPointValue' in e
                        ? { arrayValue: {} }
                        : 'arrayValue' in e
                          ? { mapValue: {} }
                          : 'mapValue' in e
                            ? is
                            : oi();
      }
      function Es(e, t) {
        const n = cs(e.value, t.value);
        return 0 !== n ? n : e.inclusive && !t.inclusive ? -1 : !e.inclusive && t.inclusive ? 1 : 0;
      }
      function Ss(e, t) {
        const n = cs(e.value, t.value);
        return 0 !== n ? n : e.inclusive && !t.inclusive ? 1 : !e.inclusive && t.inclusive ? -1 : 0;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ts {
        constructor(e) {
          this.value = e;
        }
        static empty() {
          return new Ts({ mapValue: {} });
        }
        field(e) {
          if (e.isEmpty()) return this.value;
          {
            let t = this.value;
            for (let n = 0; n < e.length - 1; ++n) if (((t = (t.mapValue.fields || {})[e.get(n)]), !ys(t))) return null;
            return (t = (t.mapValue.fields || {})[e.lastSegment()]), t || null;
          }
        }
        set(e, t) {
          this.getFieldsMap(e.popLast())[e.lastSegment()] = ws(t);
        }
        setAll(e) {
          let t = Oi.emptyPath(),
            n = {},
            r = [];
          e.forEach((e, i) => {
            if (!t.isImmediateParentOf(i)) {
              const e = this.getFieldsMap(t);
              this.applyChanges(e, n, r), (n = {}), (r = []), (t = i.popLast());
            }
            e ? (n[i.lastSegment()] = ws(e)) : r.push(i.lastSegment());
          });
          const i = this.getFieldsMap(t);
          this.applyChanges(i, n, r);
        }
        delete(e) {
          const t = this.field(e.popLast());
          ys(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
        }
        isEqual(e) {
          return as(this.value, e.value);
        }
        getFieldsMap(e) {
          let t = this.value;
          t.mapValue.fields || (t.mapValue = { fields: {} });
          for (let n = 0; n < e.length; ++n) {
            let r = t.mapValue.fields[e.get(n)];
            (ys(r) && r.mapValue.fields) || ((r = { mapValue: { fields: {} } }), (t.mapValue.fields[e.get(n)] = r)), (t = r);
          }
          return t.mapValue.fields;
        }
        applyChanges(e, t, n) {
          Mo(t, (t, n) => (e[t] = n));
          for (const r of n) delete e[r];
        }
        clone() {
          return new Ts(ws(this.value));
        }
      }
      function As(e) {
        const t = [];
        return (
          Mo(e.fields, (e, n) => {
            const r = new Oi([e]);
            if (ys(n)) {
              const e = As(n.mapValue).fields;
              if (0 === e.length) t.push(r);
              else for (const n of e) t.push(r.child(n));
            } else t.push(r);
          }),
          new Go(t)
        );
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class xs {
        constructor(e, t, n, r, i, o, s) {
          (this.key = e),
            (this.documentType = t),
            (this.version = n),
            (this.readTime = r),
            (this.createTime = i),
            (this.data = o),
            (this.documentState = s);
        }
        static newInvalidDocument(e) {
          return new xs(e, 0, Ai.min(), Ai.min(), Ai.min(), Ts.empty(), 0);
        }
        static newFoundDocument(e, t, n, r) {
          return new xs(e, 1, t, Ai.min(), n, r, 0);
        }
        static newNoDocument(e, t) {
          return new xs(e, 2, t, Ai.min(), Ai.min(), Ts.empty(), 0);
        }
        static newUnknownDocument(e, t) {
          return new xs(e, 3, t, Ai.min(), Ai.min(), Ts.empty(), 2);
        }
        convertToFoundDocument(e, t) {
          return (
            !this.createTime.isEqual(Ai.min()) || (2 !== this.documentType && 0 !== this.documentType) || (this.createTime = e),
            (this.version = e),
            (this.documentType = 1),
            (this.data = t),
            (this.documentState = 0),
            this
          );
        }
        convertToNoDocument(e) {
          return (this.version = e), (this.documentType = 2), (this.data = Ts.empty()), (this.documentState = 0), this;
        }
        convertToUnknownDocument(e) {
          return (this.version = e), (this.documentType = 3), (this.data = Ts.empty()), (this.documentState = 2), this;
        }
        setHasCommittedMutations() {
          return (this.documentState = 2), this;
        }
        setHasLocalMutations() {
          return (this.documentState = 1), (this.version = Ai.min()), this;
