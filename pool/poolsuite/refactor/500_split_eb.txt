                  const n = ha(e);
                  null !== n && Xg(e, n, t.field);
                }
              })(e, r),
              r
            );
          })(e._query, this._field, this._direction);
          return new Ap(
            e.firestore,
            e.converter,
            (function (e, t) {
              const n = e.explicitOrderBy.concat([t]);
              return new sa(e.path, e.collectionGroup, n, e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt);
            })(e._query, t)
          );
        }
      }
      function Mg(e, t = 'asc') {
        const n = t,
          r = Cg('orderBy', e);
        return jg._create(r, n);
      }
      class Fg extends Ng {
        constructor(e, t, n) {
          super(), (this.type = e), (this._limit = t), (this._limitType = n);
        }
        static _create(e, t, n) {
          return new Fg(e, t, n);
        }
        _apply(e) {
          return new Ap(e.firestore, e.converter, ma(e._query, this._limit, this._limitType));
        }
      }
      function Ug(e) {
        return _p('limit', e), Fg._create('limit', e, 'F');
      }
      function Vg(e) {
        return _p('limitToLast', e), Fg._create('limitToLast', e, 'L');
      }
      class Bg extends Ng {
        constructor(e, t, n) {
          super(), (this.type = e), (this._docOrFields = t), (this._inclusive = n);
        }
        static _create(e, t, n) {
          return new Bg(e, t, n);
        }
        _apply(e) {
          const t = Hg(e, this.type, this._docOrFields, this._inclusive);
          return new Ap(
            e.firestore,
            e.converter,
            (function (e, t) {
              return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, t, e.endAt);
            })(e._query, t)
          );
        }
      }
      function $g(...e) {
        return Bg._create('startAt', e, !0);
      }
      function qg(...e) {
        return Bg._create('startAfter', e, !1);
      }
      class zg extends Ng {
        constructor(e, t, n) {
          super(), (this.type = e), (this._docOrFields = t), (this._inclusive = n);
        }
        static _create(e, t, n) {
          return new zg(e, t, n);
        }
        _apply(e) {
          const t = Hg(e, this.type, this._docOrFields, this._inclusive);
          return new Ap(
            e.firestore,
            e.converter,
            (function (e, t) {
              return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, t);
            })(e._query, t)
          );
        }
      }
      function Gg(...e) {
        return zg._create('endBefore', e, !1);
      }
      function Wg(...e) {
        return zg._create('endAt', e, !0);
      }
      function Hg(e, t, n, r) {
        if (((n[0] = (0, u.m9)(n[0])), n[0] instanceof Ag))
          return (function (e, t, n, r, i) {
            if (!r) throw new li(ci.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n}().`);
            const o = [];
            for (const s of da(e))
              if (s.field.isKeyField()) o.push(ds(t, r.key));
              else {
                const e = r.data.field(s.field);
                if (Zo(e))
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    'Invalid query. You are trying to start or end a query using a document for which the field "' +
                      s.field +
                      '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)'
                  );
                if (null === e) {
                  const e = s.field.canonicalString();
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    `Invalid query. You are trying to start or end a query using a document for which the field '${e}' (used as the orderBy) does not exist.`
                  );
                }
                o.push(e);
              }
            return new Cs(o, i);
          })(e._query, e.firestore._databaseId, t, n[0]._document, r);
        {
          const i = sg(e.firestore);
          return (function (e, t, n, r, i, o) {
            const s = e.explicitOrderBy;
            if (i.length > s.length)
              throw new li(
                ci.INVALID_ARGUMENT,
                `Too many arguments provided to ${r}(). The number of arguments must be less than or equal to the number of orderBy() clauses`
              );
            const a = [];
            for (let u = 0; u < i.length; u++) {
              const o = i[u];
              if (s[u].field.isKeyField()) {
                if ('string' != typeof o)
                  throw new li(ci.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${r}(), but got a ${typeof o}`);
                if (!fa(e) && -1 !== o.indexOf('/'))
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${r}() must be a plain document ID, but '${o}' contains a slash.`
                  );
                const n = e.path.child(Ci.fromString(o));
                if (!Ni.isDocumentKey(n))
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${r}() must result in a valid document path, but '${n}' is not because it contains an odd number of segments.`
                  );
                const i = new Ni(n);
                a.push(ds(t, i));
              } else {
                const e = mg(n, r, o);
                a.push(e);
              }
            }
            return new Cs(a, o);
          })(e._query, e.firestore._databaseId, i, t, n, r);
        }
      }
      function Kg(e, t, n) {
        if ('string' == typeof (n = (0, u.m9)(n))) {
          if ('' === n)
            throw new li(
              ci.INVALID_ARGUMENT,
              'Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.'
            );
          if (!fa(t) && -1 !== n.indexOf('/'))
            throw new li(
              ci.INVALID_ARGUMENT,
              `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`
            );
          const r = t.path.child(Ci.fromString(n));
          if (!Ni.isDocumentKey(r))
            throw new li(
              ci.INVALID_ARGUMENT,
              `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`
            );
          return ds(e, new Ni(r));
        }
        if (n instanceof Tp) return ds(e, n._key);
        throw new li(
          ci.INVALID_ARGUMENT,
          `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${wp(n)}.`
        );
      }
      function Qg(e, t) {
        if (!Array.isArray(e) || 0 === e.length)
          throw new li(ci.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${t.toString()}' filters.`);
      }
      function Yg(e, t) {
        if (t.isInequality()) {
          const n = ha(e),
            r = t.field;
          if (null !== n && !n.isEqual(r))
            throw new li(
              ci.INVALID_ARGUMENT,
              `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n.toString()}' and '${r.toString()}'`
            );
          const i = la(e);
          null !== i && Xg(e, r, i);
        }
        const n = (function (e, t) {
          for (const n of e) for (const e of n.getFlattenedFilters()) if (t.indexOf(e.op) >= 0) return e.op;
          return null;
        })(
          e.filters,
          (function (e) {
            switch (e) {
              case '!=':
                return ['!=', 'not-in'];
              case 'array-contains-any':
              case 'in':
                return ['not-in'];
              case 'not-in':
                return ['array-contains-any', 'in', 'not-in', '!='];
              default:
                return [];
            }
          })(t.op)
        );
        if (null !== n)
          throw n === t.op
            ? new li(ci.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${t.op.toString()}' filter.`)
            : new li(ci.INVALID_ARGUMENT, `Invalid query. You cannot use '${t.op.toString()}' filters with '${n.toString()}' filters.`);
      }
      function Xg(e, t, n) {
        if (!n.isEqual(t))
          throw new li(
            ci.INVALID_ARGUMENT,
            `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${t.toString()}' and so you must also use '${t.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`
          );
      }
      class Jg {
        convertValue(e, t = 'none') {
          switch (ss(e)) {
            case 0:
              return null;
            case 1:
              return e.booleanValue;
            case 2:
              return Xo(e.integerValue || e.doubleValue);
            case 3:
              return this.convertTimestamp(e.timestampValue);
            case 4:
              return this.convertServerTimestamp(e, t);
            case 5:
              return e.stringValue;
            case 6:
              return this.convertBytes(Jo(e.bytesValue));
            case 7:
              return this.convertReference(e.referenceValue);
            case 8:
              return this.convertGeoPoint(e.geoPointValue);
            case 9:
              return this.convertArray(e.arrayValue, t);
            case 10:
              return this.convertObject(e.mapValue, t);
            default:
              throw oi();
          }
        }
        convertObject(e, t) {
          return this.convertObjectMap(e.fields, t);
        }
        convertObjectMap(e, t = 'none') {
          const n = {};
          return (
            Mo(e, (e, r) => {
              n[e] = this.convertValue(r, t);
            }),
            n
          );
        }
        convertGeoPoint(e) {
          return new Zp(Xo(e.latitude), Xo(e.longitude));
        }
        convertArray(e, t) {
          return (e.values || []).map(e => this.convertValue(e, t));
        }
        convertServerTimestamp(e, t) {
          switch (t) {
            case 'previous':
              const n = es(e);
              return null == n ? null : this.convertValue(n, t);
            case 'estimate':
              return this.convertTimestamp(ts(e));
            default:
              return null;
          }
        }
        convertTimestamp(e) {
          const t = Yo(e);
          return new Ti(t.seconds, t.nanos);
        }
        convertDocumentKey(e, t) {
          const n = Ci.fromString(e);
          si(Sc(n));
          const r = new rs(n.get(1), n.get(3)),
            i = new Ni(n.popFirst(5));
          return (
            r.isEqual(t) ||
              ni(
                `Document ${i} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`
              ),
            i
          );
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Zg(e, t, n) {
        let r;
        return (r = e ? (n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t)) : t), r;
      }
      class em extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Yp(e);
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return new Tp(this.firestore, null, t);
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class tm {
        constructor(e, t) {
          (this.hasPendingWrites = e), (this.fromCache = t);
        }
        isEqual(e) {
          return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache;
        }
      }
      class nm extends Ag {
        constructor(e, t, n, r, i, o) {
          super(e, t, n, r, o), (this._firestore = e), (this._firestoreImpl = e), (this.metadata = i);
        }
        exists() {
          return super.exists();
        }
        data(e = {}) {
          if (this._document) {
            if (this._converter) {
              const t = new rm(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
              return this._converter.fromFirestore(t, e);
            }
            return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps);
          }
        }
        get(e, t = {}) {
          if (this._document) {
            const n = this._document.data.field(Cg('DocumentSnapshot.get', e));
            if (null !== n) return this._userDataWriter.convertValue(n, t.serverTimestamps);
          }
        }
      }
      class rm extends nm {
        data(e = {}) {
          return super.data(e);
        }
      }
      class im {
        constructor(e, t, n, r) {
          (this._firestore = e),
            (this._userDataWriter = t),
            (this._snapshot = r),
            (this.metadata = new tm(r.hasPendingWrites, r.fromCache)),
            (this.query = n);
        }
        get docs() {
          const e = [];
          return this.forEach(t => e.push(t)), e;
        }
        get size() {
          return this._snapshot.docs.size;
        }
        get empty() {
          return 0 === this.size;
        }
        forEach(e, t) {
          this._snapshot.docs.forEach(n => {
            e.call(
              t,
              new rm(
                this._firestore,
                this._userDataWriter,
                n.key,
                n,
                new tm(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache),
                this.query.converter
              )
            );
          });
        }
        docChanges(e = {}) {
          const t = !!e.includeMetadataChanges;
          if (t && this._snapshot.excludesMetadataChanges)
            throw new li(
              ci.INVALID_ARGUMENT,
              'To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().'
            );
          return (
            (this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t) ||
              ((this._cachedChanges = (function (e, t) {
                if (e._snapshot.oldDocs.isEmpty()) {
                  let t = 0;
                  return e._snapshot.docChanges.map(n => {
                    const r = new rm(
                      e._firestore,
                      e._userDataWriter,
                      n.doc.key,
                      n.doc,
                      new tm(e._snapshot.mutatedKeys.has(n.doc.key), e._snapshot.fromCache),
                      e.query.converter
                    );
                    return n.doc, { type: 'added', doc: r, oldIndex: -1, newIndex: t++ };
                  });
                }
                {
                  let n = e._snapshot.oldDocs;
                  return e._snapshot.docChanges
                    .filter(e => t || 3 !== e.type)
                    .map(t => {
                      const r = new rm(
                        e._firestore,
                        e._userDataWriter,
                        t.doc.key,
                        t.doc,
                        new tm(e._snapshot.mutatedKeys.has(t.doc.key), e._snapshot.fromCache),
                        e.query.converter
                      );
                      let i = -1,
                        o = -1;
                      return (
                        0 !== t.type && ((i = n.indexOf(t.doc.key)), (n = n.delete(t.doc.key))),
                        1 !== t.type && ((n = n.add(t.doc)), (o = n.indexOf(t.doc.key))),
                        { type: om(t.type), doc: r, oldIndex: i, newIndex: o }
                      );
                    });
                }
              })(this, t)),
              (this._cachedChangesIncludeMetadataChanges = t)),
            this._cachedChanges
          );
        }
      }
      function om(e) {
        switch (e) {
          case 0:
            return 'added';
          case 2:
          case 3:
            return 'modified';
          case 1:
            return 'removed';
          default:
            return oi();
        }
      }
      function sm(e, t) {
        return e instanceof nm && t instanceof nm
          ? e._firestore === t._firestore &&
