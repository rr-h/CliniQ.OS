      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const Ae = 'firebase-heartbeat-database',
        xe = 1,
        Ce = 'firebase-heartbeat-store';
      let ke = null;
      function Oe() {
        return (
          ke ||
            (ke = S(Ae, xe, {
              upgrade: (e, t) => {
                switch (t) {
                  case 0:
                    e.createObjectStore(Ce);
                }
              }
            }).catch(e => {
              throw me.create('idb-open', { originalErrorMessage: e.message });
            })),
          ke
        );
      }
      async function Ne(e) {
        try {
          const t = await Oe(),
            n = await t.transaction(Ce).objectStore(Ce).get(Pe(e));
          return n;
        } catch (t) {
          if (t instanceof o.ZR) P.warn(t.message);
          else {
            const e = me.create('idb-get', { originalErrorMessage: null === t || void 0 === t ? void 0 : t.message });
            P.warn(e.message);
          }
        }
      }
      async function Re(e, t) {
        try {
          const n = await Oe(),
            r = n.transaction(Ce, 'readwrite'),
            i = r.objectStore(Ce);
          await i.put(t, Pe(e)), await r.done;
        } catch (n) {
          if (n instanceof o.ZR) P.warn(n.message);
          else {
            const e = me.create('idb-set', { originalErrorMessage: null === n || void 0 === n ? void 0 : n.message });
            P.warn(e.message);
          }
        }
      }
      function Pe(e) {
        return `${e.name}!${e.options.appId}`;
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const De = 1024,
        Le = 2592e6;
      class je {
        constructor(e) {
          (this.container = e), (this._heartbeatsCache = null);
          const t = this.container.getProvider('app').getImmediate();
          (this._storage = new Ue(t)), (this._heartbeatsCachePromise = this._storage.read().then(e => ((this._heartbeatsCache = e), e)));
        }
        async triggerHeartbeat() {
          const e = this.container.getProvider('platform-logger').getImmediate(),
            t = e.getPlatformInfoString(),
            n = Me();
          if (
            (null === this._heartbeatsCache && (this._heartbeatsCache = await this._heartbeatsCachePromise),
            this._heartbeatsCache.lastSentHeartbeatDate !== n && !this._heartbeatsCache.heartbeats.some(e => e.date === n))
          )
            return (
              this._heartbeatsCache.heartbeats.push({ date: n, agent: t }),
              (this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(e => {
                const t = new Date(e.date).valueOf(),
                  n = Date.now();
                return n - t <= Le;
              })),
              this._storage.overwrite(this._heartbeatsCache)
            );
        }
        async getHeartbeatsHeader() {
          if (
            (null === this._heartbeatsCache && (await this._heartbeatsCachePromise),
            null === this._heartbeatsCache || 0 === this._heartbeatsCache.heartbeats.length)
          )
            return '';
          const e = Me(),
            { heartbeatsToSend: t, unsentEntries: n } = Fe(this._heartbeatsCache.heartbeats),
            r = (0, o.L)(JSON.stringify({ version: 2, heartbeats: t }));
          return (
            (this._heartbeatsCache.lastSentHeartbeatDate = e),
            n.length > 0
              ? ((this._heartbeatsCache.heartbeats = n), await this._storage.overwrite(this._heartbeatsCache))
              : ((this._heartbeatsCache.heartbeats = []), this._storage.overwrite(this._heartbeatsCache)),
            r
          );
        }
      }
      function Me() {
        const e = new Date();
        return e.toISOString().substring(0, 10);
      }
      function Fe(e, t = De) {
        const n = [];
        let r = e.slice();
        for (const i of e) {
          const e = n.find(e => e.agent === i.agent);
          if (e) {
            if ((e.dates.push(i.date), Ve(n) > t)) {
              e.dates.pop();
              break;
            }
          } else if ((n.push({ agent: i.agent, dates: [i.date] }), Ve(n) > t)) {
            n.pop();
            break;
          }
          r = r.slice(1);
        }
        return { heartbeatsToSend: n, unsentEntries: r };
      }
      class Ue {
        constructor(e) {
          (this.app = e), (this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck());
        }
        async runIndexedDBEnvironmentCheck() {
          return (
            !!(0, o.hl)() &&
            (0, o.eu)()
              .then(() => !0)
              .catch(() => !1)
          );
        }
        async read() {
          const e = await this._canUseIndexedDBPromise;
          if (e) {
            const e = await Ne(this.app);
            return e || { heartbeats: [] };
          }
          return { heartbeats: [] };
        }
        async overwrite(e) {
          var t;
          const n = await this._canUseIndexedDBPromise;
          if (n) {
            const n = await this.read();
            return Re(this.app, {
              lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate,
              heartbeats: e.heartbeats
            });
          }
        }
        async add(e) {
          var t;
          const n = await this._canUseIndexedDBPromise;
          if (n) {
            const n = await this.read();
            return Re(this.app, {
              lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate,
              heartbeats: [...n.heartbeats, ...e.heartbeats]
            });
          }
        }
      }
      function Ve(e) {
        return (0, o.L)(JSON.stringify({ version: 2, heartbeats: e })).length;
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Be(e) {
        he(new r.wA('platform-logger', e => new k(e), 'PRIVATE')),
          he(new r.wA('heartbeat', e => new je(e), 'PRIVATE')),
          Ee(N, R, e),
          Ee(N, R, 'esm2017'),
          Ee('fire-js', '');
      }
      Be('');
    },
    8463: (e, t, n) => {
      'use strict';
      n.d(t, { H0: () => c, wA: () => i });
      var r = n(74444);
      class i {
        constructor(e, t, n) {
          (this.name = e),
            (this.instanceFactory = t),
            (this.type = n),
            (this.multipleInstances = !1),
            (this.serviceProps = {}),
            (this.instantiationMode = 'LAZY'),
            (this.onInstanceCreated = null);
        }
        setInstantiationMode(e) {
          return (this.instantiationMode = e), this;
        }
        setMultipleInstances(e) {
          return (this.multipleInstances = e), this;
        }
        setServiceProps(e) {
          return (this.serviceProps = e), this;
        }
        setInstanceCreatedCallback(e) {
          return (this.onInstanceCreated = e), this;
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const o = '[DEFAULT]';
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class s {
        constructor(e, t) {
          (this.name = e),
            (this.container = t),
            (this.component = null),
            (this.instances = new Map()),
            (this.instancesDeferred = new Map()),
            (this.instancesOptions = new Map()),
            (this.onInitCallbacks = new Map());
        }
        get(e) {
          const t = this.normalizeInstanceIdentifier(e);
          if (!this.instancesDeferred.has(t)) {
            const e = new r.BH();
            if ((this.instancesDeferred.set(t, e), this.isInitialized(t) || this.shouldAutoInitialize()))
              try {
                const n = this.getOrInitializeService({ instanceIdentifier: t });
                n && e.resolve(n);
              } catch (n) {}
          }
          return this.instancesDeferred.get(t).promise;
        }
        getImmediate(e) {
          var t;
          const n = this.normalizeInstanceIdentifier(null === e || void 0 === e ? void 0 : e.identifier),
            r = null !== (t = null === e || void 0 === e ? void 0 : e.optional) && void 0 !== t && t;
          if (!this.isInitialized(n) && !this.shouldAutoInitialize()) {
            if (r) return null;
            throw Error(`Service ${this.name} is not available`);
          }
          try {
            return this.getOrInitializeService({ instanceIdentifier: n });
          } catch (i) {
            if (r) return null;
            throw i;
          }
        }
        getComponent() {
          return this.component;
        }
        setComponent(e) {
          if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
          if (this.component) throw Error(`Component for ${this.name} has already been provided`);
          if (((this.component = e), this.shouldAutoInitialize())) {
            if (u(e))
              try {
                this.getOrInitializeService({ instanceIdentifier: o });
              } catch (t) {}
            for (const [e, n] of this.instancesDeferred.entries()) {
              const r = this.normalizeInstanceIdentifier(e);
              try {
                const e = this.getOrInitializeService({ instanceIdentifier: r });
                n.resolve(e);
              } catch (t) {}
            }
          }
        }
        clearInstance(e = o) {
          this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
        }
        async delete() {
          const e = Array.from(this.instances.values());
          await Promise.all([
            ...e.filter(e => 'INTERNAL' in e).map(e => e.INTERNAL.delete()),
            ...e.filter(e => '_delete' in e).map(e => e._delete())
          ]);
        }
        isComponentSet() {
          return null != this.component;
        }
        isInitialized(e = o) {
          return this.instances.has(e);
        }
        getOptions(e = o) {
          return this.instancesOptions.get(e) || {};
        }
        initialize(e = {}) {
          const { options: t = {} } = e,
            n = this.normalizeInstanceIdentifier(e.instanceIdentifier);
          if (this.isInitialized(n)) throw Error(`${this.name}(${n}) has already been initialized`);
          if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
          const r = this.getOrInitializeService({ instanceIdentifier: n, options: t });
          for (const [i, o] of this.instancesDeferred.entries()) {
            const e = this.normalizeInstanceIdentifier(i);
            n === e && o.resolve(r);
          }
          return r;
        }
        onInit(e, t) {
          var n;
          const r = this.normalizeInstanceIdentifier(t),
            i = null !== (n = this.onInitCallbacks.get(r)) && void 0 !== n ? n : new Set();
          i.add(e), this.onInitCallbacks.set(r, i);
          const o = this.instances.get(r);
          return (
            o && e(o, r),
            () => {
              i.delete(e);
            }
          );
        }
        invokeOnInitCallbacks(e, t) {
          const n = this.onInitCallbacks.get(t);
          if (n)
            for (const i of n)
              try {
                i(e, t);
              } catch (r) {}
        }
        getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
          let n = this.instances.get(e);
          if (
            !n &&
            this.component &&
            ((n = this.component.instanceFactory(this.container, { instanceIdentifier: a(e), options: t })),
            this.instances.set(e, n),
            this.instancesOptions.set(e, t),
            this.invokeOnInitCallbacks(n, e),
            this.component.onInstanceCreated)
          )
            try {
              this.component.onInstanceCreated(this.container, e, n);
            } catch (r) {}
          return n || null;
        }
        normalizeInstanceIdentifier(e = o) {
          return this.component ? (this.component.multipleInstances ? e : o) : e;
        }
        shouldAutoInitialize() {
          return !!this.component && 'EXPLICIT' !== this.component.instantiationMode;
        }
      }
      function a(e) {
        return e === o ? void 0 : e;
      }
      function u(e) {
        return 'EAGER' === e.instantiationMode;
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class c {
        constructor(e) {
          (this.name = e), (this.providers = new Map());
        }
        addComponent(e) {
          const t = this.getProvider(e.name);
          if (t.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
          t.setComponent(e);
        }
        addOrOverwriteComponent(e) {
          const t = this.getProvider(e.name);
          t.isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
        }
        getProvider(e) {
          if (this.providers.has(e)) return this.providers.get(e);
          const t = new s(e, this);
          return this.providers.set(e, t), t;
        }
        getProviders() {
          return Array.from(this.providers.values());
        }
      }
    },
    53333: (e, t, n) => {
      'use strict';
      n.d(t, { Am: () => h, Ub: () => l, Yd: () => c, in: () => i });
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const r = [];
      var i;
      (function (e) {
        (e[(e['DEBUG'] = 0)] = 'DEBUG'),
          (e[(e['VERBOSE'] = 1)] = 'VERBOSE'),
          (e[(e['INFO'] = 2)] = 'INFO'),
          (e[(e['WARN'] = 3)] = 'WARN'),
          (e[(e['ERROR'] = 4)] = 'ERROR'),
          (e[(e['SILENT'] = 5)] = 'SILENT');
      })(i || (i = {}));
      const o = { debug: i.DEBUG, verbose: i.VERBOSE, info: i.INFO, warn: i.WARN, error: i.ERROR, silent: i.SILENT },
        s = i.INFO,
        a = { [i.DEBUG]: 'log', [i.VERBOSE]: 'log', [i.INFO]: 'info', [i.WARN]: 'warn', [i.ERROR]: 'error' },
        u = (e, t, ...n) => {
          if (t < e.logLevel) return;
          const r = new Date().toISOString(),
            i = a[t];
          if (!i) throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
          console[i](`[${r}]  ${e.name}:`, ...n);
        };
      class c {
        constructor(e) {
          (this.name = e), (this._logLevel = s), (this._logHandler = u), (this._userLogHandler = null), r.push(this);
        }
        get logLevel() {
          return this._logLevel;
        }
        set logLevel(e) {
          if (!(e in i)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
          this._logLevel = e;
