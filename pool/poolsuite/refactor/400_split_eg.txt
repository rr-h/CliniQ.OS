        sn(e, t) {
          return !!e.field.isEqual(t.fieldPath) && ((0 === t.kind && 'asc' === e.dir) || (1 === t.kind && 'desc' === e.dir));
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function tl(e) {
        var t, n;
        if ((si(e instanceof Ds || e instanceof Ls), e instanceof Ds)) {
          if (e instanceof Qs) {
            const r =
              (null === (n = null === (t = e.value.arrayValue) || void 0 === t ? void 0 : t.values) || void 0 === n
                ? void 0
                : n.map(t => Ds.create(e.field, '==', t))) || [];
            return Ls.create(r, 'or');
          }
          return e;
        }
        const r = e.filters.map(e => tl(e));
        return Ls.create(r, e.op);
      }
      function nl(e) {
        if (0 === e.getFilters().length) return [];
        const t = sl(tl(e));
        return si(ol(t)), rl(t) || il(t) ? [t] : t.getFilters();
      }
      function rl(e) {
        return e instanceof Ds;
      }
      function il(e) {
        return e instanceof Ls && Fs(e);
      }
      function ol(e) {
        return (
          rl(e) ||
          il(e) ||
          (function (e) {
            if (e instanceof Ls && Ms(e)) {
              for (const t of e.getFilters()) if (!rl(t) && !il(t)) return !1;
              return !0;
            }
            return !1;
          })(e)
        );
      }
      function sl(e) {
        if ((si(e instanceof Ds || e instanceof Ls), e instanceof Ds)) return e;
        if (1 === e.filters.length) return sl(e.filters[0]);
        const t = e.filters.map(e => sl(e));
        let n = Ls.create(t, e.op);
        return (n = cl(n)), ol(n) ? n : (si(n instanceof Ls), si(js(n)), si(n.filters.length > 1), n.filters.reduce((e, t) => al(e, t)));
      }
      function al(e, t) {
        let n;
        return (
          si(e instanceof Ds || e instanceof Ls),
          si(t instanceof Ds || t instanceof Ls),
          (n =
            e instanceof Ds
              ? t instanceof Ds
                ? (function (e, t) {
                    return Ls.create([e, t], 'and');
                  })(e, t)
                : ul(e, t)
              : t instanceof Ds
                ? ul(t, e)
                : (function (e, t) {
                    if ((si(e.filters.length > 0 && t.filters.length > 0), js(e) && js(t))) return $s(e, t.getFilters());
                    const n = Ms(e) ? e : t,
                      r = Ms(e) ? t : e,
                      i = n.filters.map(e => al(e, r));
                    return Ls.create(i, 'or');
                  })(e, t)),
          cl(n)
        );
      }
      function ul(e, t) {
        if (js(t)) return $s(t, e.getFilters());
        {
          const n = t.filters.map(t => al(e, t));
          return Ls.create(n, 'or');
        }
      }
      function cl(e) {
        if ((si(e instanceof Ds || e instanceof Ls), e instanceof Ds)) return e;
        const t = e.getFilters();
        if (1 === t.length) return cl(t[0]);
        if (Us(e)) return e;
        const n = t.map(e => cl(e)),
          r = [];
        return (
          n.forEach(t => {
            t instanceof Ds ? r.push(t) : t instanceof Ls && (t.op === e.op ? r.push(...t.filters) : r.push(t));
          }),
          1 === r.length ? r[0] : Ls.create(r, e.op)
        );
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class ll {
        constructor() {
          this.rn = new hl();
        }
        addToCollectionParentIndex(e, t) {
          return this.rn.add(t), zi.resolve();
        }
        getCollectionParents(e, t) {
          return zi.resolve(this.rn.getEntries(t));
        }
        addFieldIndex(e, t) {
          return zi.resolve();
        }
        deleteFieldIndex(e, t) {
          return zi.resolve();
        }
        getDocumentsMatchingTarget(e, t) {
          return zi.resolve(null);
        }
        getIndexType(e, t) {
          return zi.resolve(0);
        }
        getFieldIndexes(e, t) {
          return zi.resolve([]);
        }
        getNextCollectionGroupToUpdate(e) {
          return zi.resolve(null);
        }
        getMinOffset(e, t) {
          return zi.resolve(Ui.min());
        }
        getMinOffsetFromCollectionGroup(e, t) {
          return zi.resolve(Ui.min());
        }
        updateCollectionGroup(e, t, n) {
          return zi.resolve();
        }
        updateIndexEntries(e, t) {
          return zi.resolve();
        }
      }
      class hl {
        constructor() {
          this.index = {};
        }
        add(e) {
          const t = e.lastSegment(),
            n = e.popLast(),
            r = this.index[t] || new $o(Ci.comparator),
            i = !r.has(n);
          return (this.index[t] = r.add(n)), i;
        }
        has(e) {
          const t = e.lastSegment(),
            n = e.popLast(),
            r = this.index[t];
          return r && r.has(n);
        }
        getEntries(e) {
          return (this.index[e] || new $o(Ci.comparator)).toArray();
        }
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const fl = new Uint8Array(0);
      class dl {
        constructor(e, t) {
          (this.user = e),
            (this.databaseId = t),
            (this.on = new hl()),
            (this.un = new Sa(
              e => ea(e),
              (e, t) => ta(e, t)
            )),
            (this.uid = e.uid || '');
        }
        addToCollectionParentIndex(e, t) {
          if (!this.on.has(t)) {
            const n = t.lastSegment(),
              r = t.popLast();
            e.addOnCommittedListener(() => {
              this.on.add(t);
            });
            const i = { collectionId: n, parent: so(r) };
            return pl(e).put(i);
          }
          return zi.resolve();
        }
        getCollectionParents(e, t) {
          const n = [],
            r = IDBKeyRange.bound([t, ''], [Si(t), ''], !1, !0);
          return pl(e)
            .j(r)
            .next(e => {
              for (const r of e) {
                if (r.collectionId !== t) break;
                n.push(co(r.parent));
              }
              return n;
            });
        }
        addFieldIndex(e, t) {
          const n = ml(e),
            r = (function (e) {
              return { indexId: e.indexId, collectionGroup: e.collectionGroup, fields: e.fields.map(e => [e.fieldPath.canonicalString(), e.kind]) };
            })(t);
          delete r.indexId;
          const i = n.add(r);
          if (t.indexState) {
            const n = vl(e);
            return i.next(e => {
              n.put(Fc(e, this.user, t.indexState.sequenceNumber, t.indexState.offset));
            });
          }
          return i.next();
        }
        deleteFieldIndex(e, t) {
          const n = ml(e),
            r = vl(e),
            i = gl(e);
          return n
            .delete(t.indexId)
            .next(() => r.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)))
            .next(() => i.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)));
        }
        getDocumentsMatchingTarget(e, t) {
          const n = gl(e);
          let r = !0;
          const i = new Map();
          return zi
            .forEach(this.cn(t), t =>
              this.an(e, t).next(e => {
                r && (r = !!e), i.set(t, e);
              })
            )
            .next(() => {
              if (r) {
                let e = La();
                const r = [];
                return zi
                  .forEach(i, (i, o) => {
                    var s;
                    ti(
                      'IndexedDbIndexManager',
                      `Using index ${((s = i), `id=${s.indexId}|cg=${s.collectionGroup}|f=${s.fields.map(e => `${e.fieldPath}:${e.kind}`).join(',')}`)} to execute ${ea(t)}`
                    );
                    const a = (function (e, t) {
                        const n = Pi(t);
                        if (void 0 === n) return null;
                        for (const r of ra(e, n.fieldPath))
                          switch (r.op) {
                            case 'array-contains-any':
                              return r.value.arrayValue.values || [];
                            case 'array-contains':
                              return [r.value];
                          }
                        return null;
                      })(o, i),
                      u = (function (e, t) {
                        const n = new Map();
                        for (const r of Di(t))
                          for (const t of ra(e, r.fieldPath))
                            switch (t.op) {
                              case '==':
                              case 'in':
                                n.set(r.fieldPath.canonicalString(), t.value);
                                break;
                              case 'not-in':
                              case '!=':
                                return n.set(r.fieldPath.canonicalString(), t.value), Array.from(n.values());
                            }
                        return null;
                      })(o, i),
                      c = (function (e, t) {
                        const n = [];
                        let r = !0;
                        for (const i of Di(t)) {
                          const t = 0 === i.kind ? ia(e, i.fieldPath, e.startAt) : oa(e, i.fieldPath, e.startAt);
                          n.push(t.value), r && (r = t.inclusive);
                        }
                        return new Cs(n, r);
                      })(o, i),
                      l = (function (e, t) {
                        const n = [];
                        let r = !0;
                        for (const i of Di(t)) {
                          const t = 0 === i.kind ? oa(e, i.fieldPath, e.endAt) : ia(e, i.fieldPath, e.endAt);
                          n.push(t.value), r && (r = t.inclusive);
                        }
                        return new Cs(n, r);
                      })(o, i),
                      h = this.hn(i, o, c),
                      f = this.hn(i, o, l),
                      d = this.ln(i, o, u),
                      p = this.fn(i.indexId, a, h, c.inclusive, f, l.inclusive, d);
                    return zi.forEach(p, i =>
                      n.H(i, t.limit).next(t => {
                        t.forEach(t => {
                          const n = Ni.fromSegments(t.documentKey);
                          e.has(n) || ((e = e.add(n)), r.push(n));
                        });
                      })
                    );
                  })
                  .next(() => r);
              }
              return zi.resolve(null);
            });
        }
        cn(e) {
          let t = this.un.get(e);
          return (
            t ||
            ((t =
              0 === e.filters.length
                ? [e]
                : nl(Ls.create(e.filters, 'and')).map(t => Zs(e.path, e.collectionGroup, e.orderBy, t.getFilters(), e.limit, e.startAt, e.endAt))),
            this.un.set(e, t),
            t)
          );
        }
        fn(e, t, n, r, i, o, s) {
          const a = (null != t ? t.length : 1) * Math.max(n.length, i.length),
            u = a / (null != t ? t.length : 1),
            c = [];
          for (let l = 0; l < a; ++l) {
            const a = t ? this.dn(t[l / u]) : fl,
              h = this.wn(e, a, n[l % u], r),
              f = this._n(e, a, i[l % u], o),
              d = s.map(t => this.wn(e, a, t, !0));
            c.push(...this.createRange(h, f, d));
          }
          return c;
        }
        wn(e, t, n, r) {
          const i = new Xc(e, Ni.empty(), t, n);
          return r ? i : i.Je();
        }
        _n(e, t, n, r) {
          const i = new Xc(e, Ni.empty(), t, n);
          return r ? i.Je() : i;
        }
        an(e, t) {
          const n = new el(t),
            r = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment();
          return this.getFieldIndexes(e, r).next(e => {
            let t = null;
            for (const r of e) n.tn(r) && (!t || r.fields.length > t.fields.length) && (t = r);
            return t;
          });
        }
        getIndexType(e, t) {
          let n = 2;
          const r = this.cn(t);
          return zi
            .forEach(r, t =>
              this.an(e, t).next(e => {
                e
                  ? 0 !== n &&
                    e.fields.length <
                      (function (e) {
