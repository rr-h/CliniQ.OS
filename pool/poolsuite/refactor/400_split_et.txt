          this.Cu = new Uo(Ni.comparator);
        }
        track(e) {
          const t = e.doc.key,
            n = this.Cu.get(t);
          n
            ? 0 !== e.type && 3 === n.type
              ? (this.Cu = this.Cu.insert(t, e))
              : 3 === e.type && 1 !== n.type
                ? (this.Cu = this.Cu.insert(t, { type: n.type, doc: e.doc }))
                : 2 === e.type && 2 === n.type
                  ? (this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }))
                  : 2 === e.type && 0 === n.type
                    ? (this.Cu = this.Cu.insert(t, { type: 0, doc: e.doc }))
                    : 1 === e.type && 0 === n.type
                      ? (this.Cu = this.Cu.remove(t))
                      : 1 === e.type && 2 === n.type
                        ? (this.Cu = this.Cu.insert(t, { type: 1, doc: n.doc }))
                        : 0 === e.type && 1 === n.type
                          ? (this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }))
                          : oi()
            : (this.Cu = this.Cu.insert(t, e));
        }
        xu() {
          const e = [];
          return (
            this.Cu.inorderTraversal((t, n) => {
              e.push(n);
            }),
            e
          );
        }
      }
      class Vf {
        constructor(e, t, n, r, i, o, s, a, u) {
          (this.query = e),
            (this.docs = t),
            (this.oldDocs = n),
            (this.docChanges = r),
            (this.mutatedKeys = i),
            (this.fromCache = o),
            (this.syncStateChanged = s),
            (this.excludesMetadataChanges = a),
            (this.hasCachedResults = u);
        }
        static fromInitialDocuments(e, t, n, r, i) {
          const o = [];
          return (
            t.forEach(e => {
              o.push({ type: 0, doc: e });
            }),
            new Vf(e, t, Ff.emptySet(t), o, n, r, !0, !1, i)
          );
        }
        get hasPendingWrites() {
          return !this.mutatedKeys.isEmpty();
        }
        isEqual(e) {
          if (
            !(
              this.fromCache === e.fromCache &&
              this.hasCachedResults === e.hasCachedResults &&
              this.syncStateChanged === e.syncStateChanged &&
              this.mutatedKeys.isEqual(e.mutatedKeys) &&
              va(this.query, e.query) &&
              this.docs.isEqual(e.docs) &&
              this.oldDocs.isEqual(e.oldDocs)
            )
          )
            return !1;
          const t = this.docChanges,
            n = e.docChanges;
          if (t.length !== n.length) return !1;
          for (let r = 0; r < t.length; r++) if (t[r].type !== n[r].type || !t[r].doc.isEqual(n[r].doc)) return !1;
          return !0;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Bf {
        constructor() {
          (this.Nu = void 0), (this.listeners = []);
        }
      }
      class $f {
        constructor() {
          (this.queries = new Sa(e => ya(e), va)), (this.onlineState = 'Unknown'), (this.ku = new Set());
        }
      }
      async function qf(e, t) {
        const n = ui(e),
          r = t.query;
        let i = !1,
          o = n.queries.get(r);
        if ((o || ((i = !0), (o = new Bf())), i))
          try {
            o.Nu = await n.onListen(r);
          } catch (e) {
            const n = Mf(e, `Initialization of query '${wa(t.query)}' failed`);
            return void t.onError(n);
          }
        n.queries.set(r, o), o.listeners.push(t), t.Mu(n.onlineState), o.Nu && t.$u(o.Nu) && Hf(n);
      }
      async function zf(e, t) {
        const n = ui(e),
          r = t.query;
        let i = !1;
        const o = n.queries.get(r);
        if (o) {
          const e = o.listeners.indexOf(t);
          e >= 0 && (o.listeners.splice(e, 1), (i = 0 === o.listeners.length));
        }
        if (i) return n.queries.delete(r), n.onUnlisten(r);
      }
      function Gf(e, t) {
        const n = ui(e);
        let r = !1;
        for (const i of t) {
          const e = i.query,
            t = n.queries.get(e);
          if (t) {
            for (const e of t.listeners) e.$u(i) && (r = !0);
            t.Nu = i;
          }
        }
        r && Hf(n);
      }
      function Wf(e, t, n) {
        const r = ui(e),
          i = r.queries.get(t);
        if (i) for (const o of i.listeners) o.onError(n);
        r.queries.delete(t);
      }
      function Hf(e) {
        e.ku.forEach(e => {
          e.next();
        });
      }
      class Kf {
        constructor(e, t, n) {
          (this.query = e), (this.Ou = t), (this.Fu = !1), (this.Bu = null), (this.onlineState = 'Unknown'), (this.options = n || {});
        }
        $u(e) {
          if (!this.options.includeMetadataChanges) {
            const t = [];
            for (const n of e.docChanges) 3 !== n.type && t.push(n);
            e = new Vf(e.query, e.docs, e.oldDocs, t, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults);
          }
          let t = !1;
          return this.Fu ? this.Lu(e) && (this.Ou.next(e), (t = !0)) : this.qu(e, this.onlineState) && (this.Uu(e), (t = !0)), (this.Bu = e), t;
        }
        onError(e) {
          this.Ou.error(e);
        }
        Mu(e) {
          this.onlineState = e;
          let t = !1;
          return this.Bu && !this.Fu && this.qu(this.Bu, e) && (this.Uu(this.Bu), (t = !0)), t;
        }
        qu(e, t) {
          if (!e.fromCache) return !0;
          const n = 'Offline' !== t;
          return (!this.options.Ku || !n) && (!e.docs.isEmpty() || e.hasCachedResults || 'Offline' === t);
        }
        Lu(e) {
          if (e.docChanges.length > 0) return !0;
          const t = this.Bu && this.Bu.hasPendingWrites !== e.hasPendingWrites;
          return !(!e.syncStateChanged && !t) && !0 === this.options.includeMetadataChanges;
        }
        Uu(e) {
          (e = Vf.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults)), (this.Fu = !0), this.Ou.next(e);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Qf {
        constructor(e, t) {
          (this.Gu = e), (this.byteLength = t);
        }
        Qu() {
          return 'metadata' in this.Gu;
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Yf {
        constructor(e) {
          this.serializer = e;
        }
        rr(e) {
          return ec(this.serializer, e);
        }
        ur(e) {
          return e.metadata.exists ? sc(this.serializer, e.document, !1) : xs.newNoDocument(this.rr(e.metadata.name), this.cr(e.metadata.readTime));
        }
        cr(e) {
          return Yu(e);
        }
      }
      class Xf {
        constructor(e, t, n) {
          (this.ju = e),
            (this.localStore = t),
            (this.serializer = n),
            (this.queries = []),
            (this.documents = []),
            (this.collectionGroups = new Set()),
            (this.progress = Jf(e));
        }
        zu(e) {
          this.progress.bytesLoaded += e.byteLength;
          let t = this.progress.documentsLoaded;
          if (e.Gu.namedQuery) this.queries.push(e.Gu.namedQuery);
          else if (e.Gu.documentMetadata) {
            this.documents.push({ metadata: e.Gu.documentMetadata }), e.Gu.documentMetadata.exists || ++t;
            const n = Ci.fromString(e.Gu.documentMetadata.name);
            this.collectionGroups.add(n.get(n.length - 2));
          } else e.Gu.document && ((this.documents[this.documents.length - 1].document = e.Gu.document), ++t);
          return t !== this.progress.documentsLoaded ? ((this.progress.documentsLoaded = t), Object.assign({}, this.progress)) : null;
        }
        Wu(e) {
          const t = new Map(),
            n = new Yf(this.serializer);
          for (const r of e)
            if (r.metadata.queries) {
              const e = n.rr(r.metadata.name);
              for (const n of r.metadata.queries) {
                const r = (t.get(n) || La()).add(e);
                t.set(n, r);
              }
            }
          return t;
        }
        async complete() {
          const e = await Nh(this.localStore, new Yf(this.serializer), this.documents, this.ju.id),
            t = this.Wu(this.documents);
          for (const n of this.queries) await Rh(this.localStore, n, t.get(n.name));
          return (this.progress.taskState = 'Success'), { progress: this.progress, Hu: this.collectionGroups, Ju: e };
        }
      }
      function Jf(e) {
        return { taskState: 'Running', documentsLoaded: 0, bytesLoaded: 0, totalDocuments: e.totalDocuments, totalBytes: e.totalBytes };
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Zf {
        constructor(e) {
          this.key = e;
        }
      }
      class ed {
        constructor(e) {
          this.key = e;
        }
      }
      class td {
        constructor(e, t) {
          (this.query = e),
            (this.Yu = t),
            (this.Xu = null),
            (this.hasCachedResults = !1),
            (this.current = !1),
            (this.Zu = La()),
            (this.mutatedKeys = La()),
            (this.tc = Ia(e)),
            (this.ec = new Ff(this.tc));
        }
        get nc() {
          return this.Yu;
        }
        sc(e, t) {
          const n = t ? t.ic : new Uf(),
            r = t ? t.ec : this.ec;
          let i = t ? t.mutatedKeys : this.mutatedKeys,
            o = r,
            s = !1;
          const a = 'F' === this.query.limitType && r.size === this.query.limit ? r.last() : null,
            u = 'L' === this.query.limitType && r.size === this.query.limit ? r.first() : null;
          if (
            (e.inorderTraversal((e, t) => {
              const c = r.get(e),
                l = ba(this.query, t) ? t : null,
                h = !!c && this.mutatedKeys.has(c.key),
                f = !!l && (l.hasLocalMutations || (this.mutatedKeys.has(l.key) && l.hasCommittedMutations));
              let d = !1;
              c && l
                ? c.data.isEqual(l.data)
                  ? h !== f && (n.track({ type: 3, doc: l }), (d = !0))
                  : this.rc(c, l) || (n.track({ type: 2, doc: l }), (d = !0), ((a && this.tc(l, a) > 0) || (u && this.tc(l, u) < 0)) && (s = !0))
                : !c && l
                  ? (n.track({ type: 0, doc: l }), (d = !0))
                  : c && !l && (n.track({ type: 1, doc: c }), (d = !0), (a || u) && (s = !0)),
                d && (l ? ((o = o.add(l)), (i = f ? i.add(e) : i.delete(e))) : ((o = o.delete(e)), (i = i.delete(e))));
            }),
            null !== this.query.limit)
          )
            for (; o.size > this.query.limit; ) {
              const e = 'F' === this.query.limitType ? o.last() : o.first();
              (o = o.delete(e.key)), (i = i.delete(e.key)), n.track({ type: 1, doc: e });
            }
          return { ec: o, ic: n, zi: s, mutatedKeys: i };
        }
        rc(e, t) {
          return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations;
        }
        applyChanges(e, t, n) {
          const r = this.ec;
          (this.ec = e.ec), (this.mutatedKeys = e.mutatedKeys);
          const i = e.ic.xu();
          i.sort(
            (e, t) =>
              (function (e, t) {
                const n = e => {
                  switch (e) {
                    case 0:
                      return 1;
                    case 2:
                    case 3:
                      return 2;
                    case 1:
                      return 0;
                    default:
                      return oi();
                  }
                };
                return n(e) - n(t);
              })(
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */ e.type,
                t.type
              ) || this.tc(e.doc, t.doc)
          ),
            this.oc(n);
          const o = t ? this.uc() : [],
