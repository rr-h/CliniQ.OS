            (this.enrolledFactors = []),
            e._onReload(t => {
              t.mfaInfo && (this.enrolledFactors = t.mfaInfo.map(t => en._fromServerResponse(e.auth, t)));
            });
        }
        static _fromUser(e) {
          return new Vn(e);
        }
        async getSession() {
          return Rn._fromIdtoken(await this.user.getIdToken(), this.user.auth);
        }
        async enroll(e, t) {
          const n = e,
            r = await this.getSession(),
            i = await J(this.user, n._process(this.user.auth, r, t));
          return await this.user._updateTokensIfNecessary(i), this.user.reload();
        }
        async unenroll(e) {
          const t = 'string' === typeof e ? e : e.uid,
            n = await this.user.getIdToken();
          try {
            const e = await J(this.user, Un(this.user.auth, { idToken: n, mfaEnrollmentId: t }));
            (this.enrolledFactors = this.enrolledFactors.filter(({ uid: e }) => e !== t)),
              await this.user._updateTokensIfNecessary(e),
              await this.user.reload();
          } catch (r) {
            throw r;
          }
        }
      }
      const Bn = new WeakMap();
      function $n(e) {
        const t = (0, i.m9)(e);
        return Bn.has(t) || Bn.set(t, Vn._fromUser(t)), Bn.get(t);
      }
      const qn = '__sak';
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class zn {
        constructor(e, t) {
          (this.storageRetriever = e), (this.type = t);
        }
        _isAvailable() {
          try {
            return this.storage ? (this.storage.setItem(qn, '1'), this.storage.removeItem(qn), Promise.resolve(!0)) : Promise.resolve(!1);
          } catch (e) {
            return Promise.resolve(!1);
          }
        }
        _set(e, t) {
          return this.storage.setItem(e, JSON.stringify(t)), Promise.resolve();
        }
        _get(e) {
          const t = this.storage.getItem(e);
          return Promise.resolve(t ? JSON.parse(t) : null);
        }
        _remove(e) {
          return this.storage.removeItem(e), Promise.resolve();
        }
        get storage() {
          return this.storageRetriever();
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Gn() {
        const e = (0, i.z$)();
        return ye(e) || Se(e);
      }
      const Wn = 1e3,
        Hn = 10;
      class Kn extends zn {
        constructor() {
          super(() => window.localStorage, 'LOCAL'),
            (this.boundEventHandler = (e, t) => this.onStorageEvent(e, t)),
            (this.listeners = {}),
            (this.localCache = {}),
            (this.pollTimer = null),
            (this.safariLocalStorageNotSynced = Gn() && ke()),
            (this.fallbackToPolling = Ce()),
            (this._shouldAllowMigration = !0);
        }
        forAllChangedKeys(e) {
          for (const t of Object.keys(this.listeners)) {
            const n = this.storage.getItem(t),
              r = this.localCache[t];
            n !== r && e(t, r, n);
          }
        }
        onStorageEvent(e, t = !1) {
          if (!e.key)
            return void this.forAllChangedKeys((e, t, n) => {
              this.notifyListeners(e, n);
            });
          const n = e.key;
          if ((t ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced)) {
            const r = this.storage.getItem(n);
            if (e.newValue !== r) null !== e.newValue ? this.storage.setItem(n, e.newValue) : this.storage.removeItem(n);
            else if (this.localCache[n] === e.newValue && !t) return;
          }
          const r = () => {
              const e = this.storage.getItem(n);
              (t || this.localCache[n] !== e) && this.notifyListeners(n, e);
            },
            i = this.storage.getItem(n);
          xe() && i !== e.newValue && e.newValue !== e.oldValue ? setTimeout(r, Hn) : r();
        }
        notifyListeners(e, t) {
          this.localCache[e] = t;
          const n = this.listeners[e];
          if (n) for (const r of Array.from(n)) r(t ? JSON.parse(t) : t);
        }
        startPolling() {
          this.stopPolling(),
            (this.pollTimer = setInterval(() => {
              this.forAllChangedKeys((e, t, n) => {
                this.onStorageEvent(new StorageEvent('storage', { key: e, oldValue: t, newValue: n }), !0);
              });
            }, Wn));
        }
        stopPolling() {
          this.pollTimer && (clearInterval(this.pollTimer), (this.pollTimer = null));
        }
        attachListener() {
          window.addEventListener('storage', this.boundEventHandler);
        }
        detachListener() {
          window.removeEventListener('storage', this.boundEventHandler);
        }
        _addListener(e, t) {
          0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()),
            this.listeners[e] || ((this.listeners[e] = new Set()), (this.localCache[e] = this.storage.getItem(e))),
            this.listeners[e].add(t);
        }
        _removeListener(e, t) {
          this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]),
            0 === Object.keys(this.listeners).length && (this.detachListener(), this.stopPolling());
        }
        async _set(e, t) {
          await super._set(e, t), (this.localCache[e] = JSON.stringify(t));
        }
        async _get(e) {
          const t = await super._get(e);
          return (this.localCache[e] = JSON.stringify(t)), t;
        }
        async _remove(e) {
          await super._remove(e), delete this.localCache[e];
        }
      }
      Kn.type = 'LOCAL';
      const Qn = Kn;
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Yn extends zn {
        constructor() {
          super(() => window.sessionStorage, 'SESSION');
        }
        _addListener(e, t) {}
        _removeListener(e, t) {}
      }
      Yn.type = 'SESSION';
      const Xn = Yn;
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Jn(e) {
        return Promise.all(
          e.map(async e => {
            try {
              const t = await e;
              return { fulfilled: !0, value: t };
            } catch (t) {
              return { fulfilled: !1, reason: t };
            }
          })
        );
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Zn {
        constructor(e) {
          (this.eventTarget = e), (this.handlersMap = {}), (this.boundEventHandler = this.handleEvent.bind(this));
        }
        static _getInstance(e) {
          const t = this.receivers.find(t => t.isListeningto(e));
          if (t) return t;
          const n = new Zn(e);
          return this.receivers.push(n), n;
        }
        isListeningto(e) {
          return this.eventTarget === e;
        }
        async handleEvent(e) {
          const t = e,
            { eventId: n, eventType: r, data: i } = t.data,
            o = this.handlersMap[r];
          if (!(null === o || void 0 === o ? void 0 : o.size)) return;
          t.ports[0].postMessage({ status: 'ack', eventId: n, eventType: r });
          const s = Array.from(o).map(async e => e(t.origin, i)),
            a = await Jn(s);
          t.ports[0].postMessage({ status: 'done', eventId: n, eventType: r, response: a });
        }
        _subscribe(e, t) {
          0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener('message', this.boundEventHandler),
            this.handlersMap[e] || (this.handlersMap[e] = new Set()),
            this.handlersMap[e].add(t);
        }
        _unsubscribe(e, t) {
          this.handlersMap[e] && t && this.handlersMap[e].delete(t),
            (t && 0 !== this.handlersMap[e].size) || delete this.handlersMap[e],
            0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener('message', this.boundEventHandler);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function er(e = '', t = 10) {
        let n = '';
        for (let r = 0; r < t; r++) n += Math.floor(10 * Math.random());
        return e + n;
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ Zn.receivers = [];
      class tr {
        constructor(e) {
          (this.target = e), (this.handlers = new Set());
        }
        removeMessageHandler(e) {
          e.messageChannel && (e.messageChannel.port1.removeEventListener('message', e.onMessage), e.messageChannel.port1.close()),
            this.handlers.delete(e);
        }
        async _send(e, t, n = 50) {
          const r = 'undefined' !== typeof MessageChannel ? new MessageChannel() : null;
          if (!r) throw new Error('connection_unavailable');
          let i, o;
          return new Promise((s, a) => {
            const u = er('', 20);
            r.port1.start();
            const c = setTimeout(() => {
              a(new Error('unsupported_event'));
            }, n);
            (o = {
              messageChannel: r,
              onMessage(e) {
                const t = e;
                if (t.data.eventId === u)
                  switch (t.data.status) {
                    case 'ack':
                      clearTimeout(c),
                        (i = setTimeout(() => {
                          a(new Error('timeout'));
                        }, 3e3));
                      break;
                    case 'done':
                      clearTimeout(i), s(t.data.response);
                      break;
                    default:
                      clearTimeout(c), clearTimeout(i), a(new Error('invalid_response'));
                      break;
                  }
              }
            }),
              this.handlers.add(o),
              r.port1.addEventListener('message', o.onMessage),
              this.target.postMessage({ eventType: e, eventId: u, data: t }, [r.port2]);
          }).finally(() => {
            o && this.removeMessageHandler(o);
          });
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function nr() {
        return window;
      }
      function rr(e) {
        nr().location.href = e;
      }
      /**
       * @license
       * Copyright 2020 Google LLC.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function ir() {
        return 'undefined' !== typeof nr()['WorkerGlobalScope'] && 'function' === typeof nr()['importScripts'];
      }
      async function or() {
        if (!(null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker)) return null;
        try {
          const e = await navigator.serviceWorker.ready;
          return e.active;
        } catch (e) {
          return null;
        }
      }
      function sr() {
        var e;
        return (
          (null === (e = null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker) || void 0 === e ? void 0 : e.controller) ||
          null
        );
      }
      function ar() {
        return ir() ? self : null;
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const ur = 'firebaseLocalStorageDb',
        cr = 1,
        lr = 'firebaseLocalStorage',
        hr = 'fbase_key';
      class fr {
        constructor(e) {
          this.request = e;
        }
        toPromise() {
          return new Promise((e, t) => {
            this.request.addEventListener('success', () => {
              e(this.request.result);
            }),
              this.request.addEventListener('error', () => {
                t(this.request.error);
              });
          });
        }
      }
      function dr(e, t) {
        return e.transaction([lr], t ? 'readwrite' : 'readonly').objectStore(lr);
      }
      function pr() {
        const e = indexedDB.deleteDatabase(ur);
        return new fr(e).toPromise();
      }
      function gr() {
        const e = indexedDB.open(ur, cr);
        return new Promise((t, n) => {
          e.addEventListener('error', () => {
            n(e.error);
          }),
            e.addEventListener('upgradeneeded', () => {
              const t = e.result;
              try {
                t.createObjectStore(lr, { keyPath: hr });
              } catch (r) {
                n(r);
              }
            }),
            e.addEventListener('success', async () => {
              const n = e.result;
              n.objectStoreNames.contains(lr) ? t(n) : (n.close(), await pr(), t(await gr()));
            });
        });
      }
      async function mr(e, t, n) {
        const r = dr(e, !0).put({ [hr]: t, value: n });
        return new fr(r).toPromise();
      }
      async function vr(e, t) {
        const n = dr(e, !1).get(t),
          r = await new fr(n).toPromise();
        return void 0 === r ? null : r.value;
      }
      function yr(e, t) {
        const n = dr(e, !0).delete(t);
        return new fr(n).toPromise();
      }
      const wr = 800,
        br = 3;
      class _r {
        constructor() {
          (this.type = 'LOCAL'),
            (this._shouldAllowMigration = !0),
            (this.listeners = {}),
