        }
      }
      class ed {
        constructor(e) {
          this.key = e;
        }
      }
      class td {
        constructor(e, t) {
          (this.query = e),
            (this.Yu = t),
            (this.Xu = null),
            (this.hasCachedResults = !1),
            (this.current = !1),
            (this.Zu = La()),
            (this.mutatedKeys = La()),
            (this.tc = Ia(e)),
            (this.ec = new Ff(this.tc));
        }
        get nc() {
          return this.Yu;
        }
        sc(e, t) {
          const n = t ? t.ic : new Uf(),
            r = t ? t.ec : this.ec;
          let i = t ? t.mutatedKeys : this.mutatedKeys,
            o = r,
            s = !1;
          const a = 'F' === this.query.limitType && r.size === this.query.limit ? r.last() : null,
            u = 'L' === this.query.limitType && r.size === this.query.limit ? r.first() : null;
          if (
            (e.inorderTraversal((e, t) => {
              const c = r.get(e),
                l = ba(this.query, t) ? t : null,
                h = !!c && this.mutatedKeys.has(c.key),
                f = !!l && (l.hasLocalMutations || (this.mutatedKeys.has(l.key) && l.hasCommittedMutations));
              let d = !1;
              c && l
                ? c.data.isEqual(l.data)
                  ? h !== f && (n.track({ type: 3, doc: l }), (d = !0))
                  : this.rc(c, l) || (n.track({ type: 2, doc: l }), (d = !0), ((a && this.tc(l, a) > 0) || (u && this.tc(l, u) < 0)) && (s = !0))
                : !c && l
                  ? (n.track({ type: 0, doc: l }), (d = !0))
                  : c && !l && (n.track({ type: 1, doc: c }), (d = !0), (a || u) && (s = !0)),
                d && (l ? ((o = o.add(l)), (i = f ? i.add(e) : i.delete(e))) : ((o = o.delete(e)), (i = i.delete(e))));
            }),
            null !== this.query.limit)
          )
            for (; o.size > this.query.limit; ) {
              const e = 'F' === this.query.limitType ? o.last() : o.first();
              (o = o.delete(e.key)), (i = i.delete(e.key)), n.track({ type: 1, doc: e });
            }
          return { ec: o, ic: n, zi: s, mutatedKeys: i };
        }
        rc(e, t) {
          return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations;
        }
        applyChanges(e, t, n) {
          const r = this.ec;
          (this.ec = e.ec), (this.mutatedKeys = e.mutatedKeys);
          const i = e.ic.xu();
          i.sort(
            (e, t) =>
              (function (e, t) {
                const n = e => {
                  switch (e) {
                    case 0:
                      return 1;
                    case 2:
                    case 3:
                      return 2;
                    case 1:
                      return 0;
                    default:
                      return oi();
                  }
                };
                return n(e) - n(t);
              })(
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */ e.type,
                t.type
              ) || this.tc(e.doc, t.doc)
          ),
            this.oc(n);
          const o = t ? this.uc() : [],
            s = 0 === this.Zu.size && this.current ? 1 : 0,
            a = s !== this.Xu;
          return (
            (this.Xu = s),
            0 !== i.length || a
              ? { snapshot: new Vf(this.query, e.ec, r, i, e.mutatedKeys, 0 === s, a, !1, !!n && n.resumeToken.approximateByteSize() > 0), cc: o }
              : { cc: o }
          );
        }
        Mu(e) {
          return this.current && 'Offline' === e
            ? ((this.current = !1), this.applyChanges({ ec: this.ec, ic: new Uf(), mutatedKeys: this.mutatedKeys, zi: !1 }, !1))
            : { cc: [] };
        }
        ac(e) {
          return !this.Yu.has(e) && !!this.ec.has(e) && !this.ec.get(e).hasLocalMutations;
        }
        oc(e) {
          e &&
            (e.addedDocuments.forEach(e => (this.Yu = this.Yu.add(e))),
            e.modifiedDocuments.forEach(e => {}),
            e.removedDocuments.forEach(e => (this.Yu = this.Yu.delete(e))),
            (this.current = e.current));
        }
        uc() {
          if (!this.current) return [];
          const e = this.Zu;
          (this.Zu = La()),
            this.ec.forEach(e => {
              this.ac(e.key) && (this.Zu = this.Zu.add(e.key));
            });
          const t = [];
          return (
            e.forEach(e => {
              this.Zu.has(e) || t.push(new ed(e));
            }),
            this.Zu.forEach(n => {
              e.has(n) || t.push(new Zf(n));
            }),
            t
          );
        }
        hc(e) {
          (this.Yu = e.ir), (this.Zu = La());
          const t = this.sc(e.documents);
          return this.applyChanges(t, !0);
        }
        lc() {
          return Vf.fromInitialDocuments(this.query, this.ec, this.mutatedKeys, 0 === this.Xu, this.hasCachedResults);
        }
      }
      class nd {
        constructor(e, t, n) {
          (this.query = e), (this.targetId = t), (this.view = n);
        }
      }
      class rd {
        constructor(e) {
          (this.key = e), (this.fc = !1);
        }
      }
      class id {
        constructor(e, t, n, r, i, o) {
          (this.localStore = e),
            (this.remoteStore = t),
            (this.eventManager = n),
            (this.sharedClientState = r),
            (this.currentUser = i),
            (this.maxConcurrentLimboResolutions = o),
            (this.dc = {}),
            (this.wc = new Sa(e => ya(e), va)),
            (this._c = new Map()),
            (this.mc = new Set()),
            (this.gc = new Uo(Ni.comparator)),
            (this.yc = new Map()),
            (this.Ic = new Zl()),
            (this.Tc = {}),
            (this.Ec = new Map()),
            (this.Ac = Cl.Mn()),
            (this.onlineState = 'Unknown'),
            (this.vc = void 0);
        }
        get isPrimaryClient() {
          return !0 === this.vc;
        }
      }
      async function od(e, t) {
        const n = Dd(e);
        let r, i;
        const o = n.wc.get(t);
        if (o) (r = o.targetId), n.sharedClientState.addLocalQueryTarget(r), (i = o.view.lc());
        else {
          const e = await Th(n.localStore, pa(t)),
            o = n.sharedClientState.addLocalQueryTarget(e.targetId);
          (r = e.targetId), (i = await sd(n, t, r, 'current' === o, e.resumeToken)), n.isPrimaryClient && lf(n.remoteStore, e);
        }
        return i;
      }
      async function sd(e, t, n, r, i) {
        e.Rc = (t, n, r) =>
          (async function (e, t, n, r) {
            let i = t.view.sc(n);
            i.zi && (i = await xh(e.localStore, t.query, !1).then(({ documents: e }) => t.view.sc(e, i)));
            const o = r && r.targetChanges.get(t.targetId),
              s = t.view.applyChanges(i, e.isPrimaryClient, o);
            return wd(e, t.targetId, s.cc), s.snapshot;
          })(e, t, n, r);
        const o = await xh(e.localStore, t, !0),
          s = new td(t, o.ir),
          a = s.sc(o.documents),
          u = Du.createSynthesizedTargetChangeForCurrentChange(n, r && 'Offline' !== e.onlineState, i),
          c = s.applyChanges(a, e.isPrimaryClient, u);
        wd(e, n, c.cc);
        const l = new nd(t, n, s);
        return e.wc.set(t, l), e._c.has(n) ? e._c.get(n).push(t) : e._c.set(n, [t]), c.snapshot;
      }
      async function ad(e, t) {
        const n = ui(e),
          r = n.wc.get(t),
          i = n._c.get(r.targetId);
        if (i.length > 1)
          return (
            n._c.set(
              r.targetId,
              i.filter(e => !va(e, t))
            ),
            void n.wc.delete(t)
          );
        n.isPrimaryClient
          ? (n.sharedClientState.removeLocalQueryTarget(r.targetId),
            n.sharedClientState.isActiveQueryTarget(r.targetId) ||
              (await Ah(n.localStore, r.targetId, !1)
                .then(() => {
                  n.sharedClientState.clearQueryState(r.targetId), hf(n.remoteStore, r.targetId), vd(n, r.targetId);
                })
                .catch(qi)))
          : (vd(n, r.targetId), await Ah(n.localStore, r.targetId, !0));
      }
      async function ud(e, t, n) {
        const r = Ld(e);
        try {
          const e = await (function (e, t) {
            const n = ui(e),
              r = Ti.now(),
              i = t.reduce((e, t) => e.add(t.key), La());
            let o, s;
            return n.persistence
              .runTransaction('Locally write mutations', 'readwrite', e => {
                let a = Aa(),
                  u = La();
                return n.Zi.getEntries(e, i)
                  .next(e => {
                    (a = e),
                      a.forEach((e, t) => {
                        t.isValidDocument() || (u = u.add(e));
                      });
                  })
                  .next(() => n.localDocuments.getOverlayedDocuments(e, a))
                  .next(i => {
                    o = i;
                    const s = [];
                    for (const e of t) {
                      const t = uu(e, o.get(e.key).overlayedDocument);
                      null != t && s.push(new hu(e.key, t, As(t.value.mapValue), nu.exists(!0)));
                    }
                    return n.mutationQueue.addMutationBatch(e, r, s, t);
                  })
                  .next(t => {
                    s = t;
                    const r = t.applyToLocalDocumentSet(o, u);
                    return n.documentOverlayCache.saveOverlays(e, t.batchId, r);
                  });
              })
              .then(() => ({ batchId: s.batchId, changes: ka(o) }));
          })(r.localStore, t);
          r.sharedClientState.addPendingMutation(e.batchId),
            (function (e, t, n) {
              let r = e.Tc[e.currentUser.toKey()];
              r || (r = new Uo(Ii)), (r = r.insert(t, n)), (e.Tc[e.currentUser.toKey()] = r);
            })(r, e.batchId, n),
            await Id(r, e.changes),
            await Ef(r.remoteStore);
        } catch (e) {
          const t = Mf(e, 'Failed to persist write');
          n.reject(t);
        }
      }
      async function cd(e, t) {
        const n = ui(e);
        try {
          const e = await Ih(n.localStore, t);
          t.targetChanges.forEach((e, t) => {
            const r = n.yc.get(t);
            r &&
              (si(e.addedDocuments.size + e.modifiedDocuments.size + e.removedDocuments.size <= 1),
              e.addedDocuments.size > 0
                ? (r.fc = !0)
                : e.modifiedDocuments.size > 0
                  ? si(r.fc)
                  : e.removedDocuments.size > 0 && (si(r.fc), (r.fc = !1)));
          }),
            await Id(n, e, t);
        } catch (e) {
          await qi(e);
        }
      }
      function ld(e, t, n) {
        const r = ui(e);
        if ((r.isPrimaryClient && 0 === n) || (!r.isPrimaryClient && 1 === n)) {
          const e = [];
          r.wc.forEach((n, r) => {
            const i = r.view.Mu(t);
            i.snapshot && e.push(i.snapshot);
          }),
            (function (e, t) {
              const n = ui(e);
              n.onlineState = t;
              let r = !1;
              n.queries.forEach((e, n) => {
                for (const i of n.listeners) i.Mu(t) && (r = !0);
              }),
                r && Hf(n);
            })(r.eventManager, t),
            e.length && r.dc.nu(e),
            (r.onlineState = t),
            r.isPrimaryClient && r.sharedClientState.setOnlineState(t);
        }
      }
      async function hd(e, t, n) {
        const r = ui(e);
        r.sharedClientState.updateQueryState(t, 'rejected', n);
        const i = r.yc.get(t),
          o = i && i.key;
        if (o) {
          let e = new Uo(Ni.comparator);
          e = e.insert(o, xs.newNoDocument(o, Ai.min()));
          const n = La().add(o),
            i = new Pu(Ai.min(), new Map(), new Uo(Ii), e, n);
          await cd(r, i), (r.gc = r.gc.remove(o)), r.yc.delete(t), _d(r);
        } else
          await Ah(r.localStore, t, !1)
            .then(() => vd(r, t, n))
            .catch(qi);
      }
      async function fd(e, t) {
        const n = ui(e),
          r = t.batch.batchId;
        try {
          const e = await bh(n.localStore, t);
          md(n, r, null), gd(n, r), n.sharedClientState.updateMutationState(r, 'acknowledged'), await Id(n, e);
        } catch (e) {
          await qi(e);
        }
      }
      async function dd(e, t, n) {
        const r = ui(e);
        try {
          const e = await (function (e, t) {
            const n = ui(e);
            return n.persistence.runTransaction('Reject batch', 'readwrite-primary', e => {
              let r;
              return n.mutationQueue
                .lookupMutationBatch(e, t)
                .next(t => (si(null !== t), (r = t.keys()), n.mutationQueue.removeMutationBatch(e, t)))
                .next(() => n.mutationQueue.performConsistencyCheck(e))
                .next(() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t))
                .next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, r))
                .next(() => n.localDocuments.getDocuments(e, r));
            });
          })(r.localStore, t);
          md(r, t, n), gd(r, t), r.sharedClientState.updateMutationState(t, 'rejected', n), await Id(r, e);
        } catch (n) {
          await qi(n);
        }
      }
      async function pd(e, t) {
        const n = ui(e);
        mf(n.remoteStore) ||
          ti('SyncEngine', "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
        try {
          const e = await (function (e) {
            const t = ui(e);
            return t.persistence.runTransaction('Get highest unacknowledged batch id', 'readonly', e =>
              t.mutationQueue.getHighestUnacknowledgedBatchId(e)
            );
          })(n.localStore);
          if (-1 === e) return void t.resolve();
          const r = n.Ec.get(e) || [];
          r.push(t), n.Ec.set(e, r);
        } catch (e) {
          const n = Mf(e, 'Initialization of waitForPendingWrites() operation failed');
          t.reject(n);
        }
      }
      function gd(e, t) {
        (e.Ec.get(t) || []).forEach(e => {
          e.resolve();
        }),
          e.Ec.delete(t);
      }
      function md(e, t, n) {
        const r = ui(e);
        let i = r.Tc[r.currentUser.toKey()];
        if (i) {
          const e = i.get(t);
          e && (n ? e.reject(n) : e.resolve(), (i = i.remove(t))), (r.Tc[r.currentUser.toKey()] = i);
        }
      }
      function vd(e, t, n = null) {
        e.sharedClientState.removeLocalQueryTarget(t);
        for (const r of e._c.get(t)) e.wc.delete(r), n && e.dc.Pc(r, n);
        e._c.delete(t),
          e.isPrimaryClient &&
            e.Ic.Is(t).forEach(t => {
              e.Ic.containsKey(t) || yd(e, t);
            });
      }
      function yd(e, t) {
        e.mc.delete(t.path.canonicalString());
        const n = e.gc.get(t);
        null !== n && (hf(e.remoteStore, n), (e.gc = e.gc.remove(t)), e.yc.delete(n), _d(e));
      }
      function wd(e, t, n) {
        for (const r of n)
          r instanceof Zf
            ? (e.Ic.addReference(r.key, t), bd(e, r))
            : r instanceof ed
              ? (ti('SyncEngine', 'Document no longer in limbo: ' + r.key), e.Ic.removeReference(r.key, t), e.Ic.containsKey(r.key) || yd(e, r.key))
              : oi();
      }
      function bd(e, t) {
        const n = t.key,
          r = n.path.canonicalString();
        e.gc.get(n) || e.mc.has(r) || (ti('SyncEngine', 'New document in limbo: ' + n), e.mc.add(r), _d(e));
      }
      function _d(e) {
        for (; e.mc.size > 0 && e.gc.size < e.maxConcurrentLimboResolutions; ) {
          const t = e.mc.values().next().value;
          e.mc.delete(t);
          const n = new Ni(Ci.fromString(t)),
            r = e.Ac.next();
          e.yc.set(r, new rd(n)), (e.gc = e.gc.insert(n, r)), lf(e.remoteStore, new Tc(pa(ua(n.path)), r, 'TargetPurposeLimboResolution', no.ct));
        }
      }
      async function Id(e, t, n) {
        const r = ui(e),
          i = [],
          o = [],
          s = [];
        r.wc.isEmpty() ||
          (r.wc.forEach((e, a) => {
            s.push(
              r.Rc(a, t, n).then(e => {
                if (
                  ((e || n) &&
                    r.isPrimaryClient &&
                    r.sharedClientState.updateQueryState(a.targetId, (null == e ? void 0 : e.fromCache) ? 'not-current' : 'current'),
                  e)
                ) {
                  i.push(e);
                  const t = gh.Li(a.targetId, e);
                  o.push(t);
                }
              })
            );
          }),
          await Promise.all(s),
          r.dc.nu(i),
          await (async function (e, t) {
            const n = ui(e);
            try {
              await n.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', e =>
                zi.forEach(t, t =>
                  zi
                    .forEach(t.Fi, r => n.persistence.referenceDelegate.addReference(e, t.targetId, r))
                    .next(() => zi.forEach(t.Bi, r => n.persistence.referenceDelegate.removeReference(e, t.targetId, r)))
                )
              );
            } catch (e) {
              if (!Qi(e)) throw e;
              ti('LocalStore', 'Failed to update sequence numbers: ' + e);
            }
            for (const r of t) {
              const e = r.targetId;
              if (!r.fromCache) {
                const t = n.Ji.get(e),
                  r = t.snapshotVersion,
                  i = t.withLastLimboFreeSnapshotVersion(r);
                n.Ji = n.Ji.insert(e, i);
              }
            }
          })(r.localStore, o));
      }
      async function Ed(e, t) {
        const n = ui(e);
        if (!n.currentUser.isEqual(t)) {
          ti('SyncEngine', 'User change. New user:', t.toKey());
          const e = await wh(n.localStore, t);
          (n.currentUser = t),
            (function (e, t) {
