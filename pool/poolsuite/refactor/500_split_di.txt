                if (n instanceof Ka) return { fieldPath: t.field.canonicalString(), removeAllFromArray: { values: n.elements } };
                if (n instanceof Ya) return { fieldPath: t.field.canonicalString(), increment: n.gt };
                throw oi();
              })(0, e)
            )),
          t.precondition.isNone ||
            (n.currentDocument = (function (e, t) {
              return void 0 !== t.updateTime ? { updateTime: Qu(e, t.updateTime) } : void 0 !== t.exists ? { exists: t.exists } : oi();
            })(e, t.precondition)),
          n
        );
      }
      function lc(e, t) {
        const n = t.currentDocument
            ? (function (e) {
                return void 0 !== e.updateTime ? nu.updateTime(Yu(e.updateTime)) : void 0 !== e.exists ? nu.exists(e.exists) : nu.none();
              })(t.currentDocument)
            : nu.none(),
          r = t.updateTransforms
            ? t.updateTransforms.map(t =>
                (function (e, t) {
                  let n = null;
                  if ('setToServerValue' in t) si('REQUEST_TIME' === t.setToServerValue), (n = new Ga());
                  else if ('appendMissingElements' in t) {
                    const e = t.appendMissingElements.values || [];
                    n = new Wa(e);
                  } else if ('removeAllFromArray' in t) {
                    const e = t.removeAllFromArray.values || [];
                    n = new Ka(e);
                  } else 'increment' in t ? (n = new Ya(e, t.increment)) : oi();
                  const r = Oi.fromServerFormat(t.fieldPath);
                  return new Za(r, n);
                })(e, t)
              )
            : [];
        if (t.update) {
          t.update.name;
          const i = ec(e, t.update.name),
            o = new Ts({ mapValue: { fields: t.update.fields } });
          if (t.updateMask) {
            const e = (function (e) {
              const t = e.fieldPaths || [];
              return new Go(t.map(e => Oi.fromServerFormat(e)));
            })(t.updateMask);
            return new hu(i, o, e, n, r);
          }
          return new lu(i, o, n, r);
        }
        if (t.delete) {
          const r = ec(e, t.delete);
          return new gu(r, n);
        }
        if (t.verify) {
          const r = ec(e, t.verify);
          return new mu(r, n);
        }
        return oi();
      }
      function hc(e, t) {
        return e && e.length > 0
          ? (si(void 0 !== t),
            e.map(e =>
              (function (e, t) {
                let n = e.updateTime ? Yu(e.updateTime) : Yu(t);
                return n.isEqual(Ai.min()) && (n = Yu(t)), new tu(n, e.transformResults || []);
              })(e, t)
            ))
          : [];
      }
      function fc(e, t) {
        return { documents: [tc(e, t.path)] };
      }
      function dc(e, t) {
        const n = { structuredQuery: {} },
          r = t.path;
        null !== t.collectionGroup
          ? ((n.parent = tc(e, r)), (n.structuredQuery.from = [{ collectionId: t.collectionGroup, allDescendants: !0 }]))
          : ((n.parent = tc(e, r.popLast())), (n.structuredQuery.from = [{ collectionId: r.lastSegment() }]));
        const i = (function (e) {
          if (0 !== e.length) return Ic(Ls.create(e, 'and'));
        })(t.filters);
        i && (n.structuredQuery.where = i);
        const o = (function (e) {
          if (0 !== e.length)
            return e.map(e =>
              (function (e) {
                return { field: bc(e.field), direction: vc(e.dir) };
              })(e)
            );
        })(t.orderBy);
        o && (n.structuredQuery.orderBy = o);
        const s = Wu(e, t.limit);
        var a;
        return (
          null !== s && (n.structuredQuery.limit = s),
          t.startAt && (n.structuredQuery.startAt = { before: (a = t.startAt).inclusive, values: a.position }),
          t.endAt &&
            (n.structuredQuery.endAt = (function (e) {
              return { before: !e.inclusive, values: e.position };
            })(t.endAt)),
          n
        );
      }
      function pc(e) {
        let t = nc(e.parent);
        const n = e.structuredQuery,
          r = n.from ? n.from.length : 0;
        let i = null;
        if (r > 0) {
          si(1 === r);
          const e = n.from[0];
          e.allDescendants ? (i = e.collectionId) : (t = t.child(e.collectionId));
        }
        let o = [];
        n.where &&
          (o = (function (e) {
            const t = mc(e);
            return t instanceof Ls && Fs(t) ? t.getFilters() : [t];
          })(n.where));
        let s = [];
        n.orderBy &&
          (s = n.orderBy.map(e =>
            (function (e) {
              return new Ns(
                _c(e.field),
                (function (e) {
                  switch (e) {
                    case 'ASCENDING':
                      return 'asc';
                    case 'DESCENDING':
                      return 'desc';
                    default:
                      return;
                  }
                })(e.direction)
              );
            })(e)
          ));
        let a = null;
        n.limit &&
          (a = (function (e) {
            let t;
            return (t = 'object' == typeof e ? e.value : e), ro(t) ? null : t;
          })(n.limit));
        let u = null;
        n.startAt &&
          (u = (function (e) {
            const t = !!e.before,
              n = e.values || [];
            return new Cs(n, t);
          })(n.startAt));
        let c = null;
        return (
          n.endAt &&
            (c = (function (e) {
              const t = !e.before,
                n = e.values || [];
              return new Cs(n, t);
            })(n.endAt)),
          aa(t, i, s, o, a, 'F', u, c)
        );
      }
      function gc(e, t) {
        const n = (function (e) {
          switch (e) {
            case 'TargetPurposeListen':
              return null;
            case 'TargetPurposeExistenceFilterMismatch':
              return 'existence-filter-mismatch';
            case 'TargetPurposeExistenceFilterMismatchBloom':
              return 'existence-filter-mismatch-bloom';
            case 'TargetPurposeLimboResolution':
              return 'limbo-document';
            default:
              return oi();
          }
        })(t.purpose);
        return null == n ? null : { 'goog-listen-tags': n };
      }
      function mc(e) {
        return void 0 !== e.unaryFilter
          ? (function (e) {
              switch (e.unaryFilter.op) {
                case 'IS_NAN':
                  const t = _c(e.unaryFilter.field);
                  return Ds.create(t, '==', { doubleValue: NaN });
                case 'IS_NULL':
                  const n = _c(e.unaryFilter.field);
                  return Ds.create(n, '==', { nullValue: 'NULL_VALUE' });
                case 'IS_NOT_NAN':
                  const r = _c(e.unaryFilter.field);
                  return Ds.create(r, '!=', { doubleValue: NaN });
                case 'IS_NOT_NULL':
                  const i = _c(e.unaryFilter.field);
                  return Ds.create(i, '!=', { nullValue: 'NULL_VALUE' });
                default:
                  return oi();
              }
            })(e)
          : void 0 !== e.fieldFilter
            ? (function (e) {
                return Ds.create(
                  _c(e.fieldFilter.field),
                  (function (e) {
                    switch (e) {
                      case 'EQUAL':
                        return '==';
                      case 'NOT_EQUAL':
                        return '!=';
                      case 'GREATER_THAN':
                        return '>';
                      case 'GREATER_THAN_OR_EQUAL':
                        return '>=';
                      case 'LESS_THAN':
                        return '<';
                      case 'LESS_THAN_OR_EQUAL':
                        return '<=';
                      case 'ARRAY_CONTAINS':
                        return 'array-contains';
                      case 'IN':
                        return 'in';
                      case 'NOT_IN':
                        return 'not-in';
                      case 'ARRAY_CONTAINS_ANY':
                        return 'array-contains-any';
                      default:
                        return oi();
                    }
                  })(e.fieldFilter.op),
                  e.fieldFilter.value
                );
              })(e)
            : void 0 !== e.compositeFilter
              ? (function (e) {
                  return Ls.create(
                    e.compositeFilter.filters.map(e => mc(e)),
                    (function (e) {
                      switch (e) {
                        case 'AND':
                          return 'and';
                        case 'OR':
                          return 'or';
                        default:
                          return oi();
                      }
                    })(e.compositeFilter.op)
                  );
                })(e)
              : oi();
      }
      function vc(e) {
        return $u[e];
      }
      function yc(e) {
        return qu[e];
      }
      function wc(e) {
        return zu[e];
      }
      function bc(e) {
        return { fieldPath: e.canonicalString() };
      }
      function _c(e) {
        return Oi.fromServerFormat(e.fieldPath);
      }
      function Ic(e) {
        return e instanceof Ds
          ? (function (e) {
              if ('==' === e.op) {
                if (vs(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NAN' } };
                if (ms(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NULL' } };
              } else if ('!=' === e.op) {
                if (vs(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NOT_NAN' } };
                if (ms(e.value)) return { unaryFilter: { field: bc(e.field), op: 'IS_NOT_NULL' } };
              }
              return { fieldFilter: { field: bc(e.field), op: yc(e.op), value: e.value } };
            })(e)
          : e instanceof Ls
            ? (function (e) {
                const t = e.getFilters().map(e => Ic(e));
                return 1 === t.length ? t[0] : { compositeFilter: { op: wc(e.op), filters: t } };
              })(e)
            : oi();
      }
      function Ec(e) {
        const t = [];
        return e.fields.forEach(e => t.push(e.canonicalString())), { fieldPaths: t };
      }
      function Sc(e) {
        return e.length >= 4 && 'projects' === e.get(0) && 'databases' === e.get(2);
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tc {
        constructor(e, t, n, r, i = Ai.min(), o = Ai.min(), s = Ko.EMPTY_BYTE_STRING, a = null) {
          (this.target = e),
            (this.targetId = t),
            (this.purpose = n),
            (this.sequenceNumber = r),
            (this.snapshotVersion = i),
            (this.lastLimboFreeSnapshotVersion = o),
            (this.resumeToken = s),
            (this.expectedCount = a);
        }
        withSequenceNumber(e) {
          return new Tc(
            this.target,
            this.targetId,
            this.purpose,
            e,
            this.snapshotVersion,
            this.lastLimboFreeSnapshotVersion,
            this.resumeToken,
            this.expectedCount
          );
        }
        withResumeToken(e, t) {
          return new Tc(this.target, this.targetId, this.purpose, this.sequenceNumber, t, this.lastLimboFreeSnapshotVersion, e, null);
        }
        withExpectedCount(e) {
          return new Tc(
            this.target,
            this.targetId,
            this.purpose,
            this.sequenceNumber,
            this.snapshotVersion,
            this.lastLimboFreeSnapshotVersion,
            this.resumeToken,
            e
          );
        }
        withLastLimboFreeSnapshotVersion(e) {
          return new Tc(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ac {
        constructor(e) {
          this.fe = e;
        }
      }
      function xc(e, t) {
        let n;
        if (t.document) n = sc(e.fe, t.document, !!t.hasCommittedMutations);
        else if (t.noDocument) {
          const e = Ni.fromSegments(t.noDocument.path),
            r = Nc(t.noDocument.readTime);
          (n = xs.newNoDocument(e, r)), t.hasCommittedMutations && n.setHasCommittedMutations();
        } else {
          if (!t.unknownDocument) return oi();
          {
            const e = Ni.fromSegments(t.unknownDocument.path),
              r = Nc(t.unknownDocument.version);
            n = xs.newUnknownDocument(e, r);
          }
        }
        return (
          t.readTime &&
            n.setReadTime(
              (function (e) {
                const t = new Ti(e[0], e[1]);
                return Ai.fromTimestamp(t);
              })(t.readTime)
            ),
          n
        );
      }
      function Cc(e, t) {
        const n = t.key,
          r = {
            prefixPath: n.getCollectionPath().popLast().toArray(),
            collectionGroup: n.collectionGroup,
            documentId: n.path.lastSegment(),
            readTime: kc(t.readTime),
            hasCommittedMutations: t.hasCommittedMutations
          };
        if (t.isFoundDocument())
          r.document = (function (e, t) {
            return {
              name: Zu(e, t.key),
              fields: t.data.value.mapValue.fields,
              updateTime: Hu(e, t.version.toTimestamp()),
              createTime: Hu(e, t.createTime.toTimestamp())
            };
          })(e.fe, t);
        else if (t.isNoDocument()) r.noDocument = { path: n.path.toArray(), readTime: Oc(t.version) };
        else {
          if (!t.isUnknownDocument()) return oi();
          r.unknownDocument = { path: n.path.toArray(), version: Oc(t.version) };
        }
        return r;
      }
      function kc(e) {
        const t = e.toTimestamp();
        return [t.seconds, t.nanoseconds];
      }
      function Oc(e) {
        const t = e.toTimestamp();
        return { seconds: t.seconds, nanoseconds: t.nanoseconds };
      }
      function Nc(e) {
        const t = new Ti(e.seconds, e.nanoseconds);
        return Ai.fromTimestamp(t);
      }
      function Rc(e, t) {
        const n = (t.baseMutations || []).map(t => lc(e.fe, t));
        for (let o = 0; o < t.mutations.length - 1; ++o) {
          const e = t.mutations[o];
          if (o + 1 < t.mutations.length && void 0 !== t.mutations[o + 1].transform) {
            const n = t.mutations[o + 1];
            (e.updateTransforms = n.transform.fieldTransforms), t.mutations.splice(o + 1, 1), ++o;
          }
        }
        const r = t.mutations.map(t => lc(e.fe, t)),
          i = Ti.fromMillis(t.localWriteTimeMs);
        return new vu(t.batchId, i, n, r);
      }
      function Pc(e) {
        const t = Nc(e.readTime),
          n = void 0 !== e.lastLimboFreeSnapshotVersion ? Nc(e.lastLimboFreeSnapshotVersion) : Ai.min();
        let r;
        var i;
        return (
          void 0 !== e.query.documents
            ? (si(1 === (i = e.query).documents.length), (r = pa(ua(nc(i.documents[0])))))
            : (r = (function (e) {
                return pa(pc(e));
              })(e.query)),
          new Tc(r, e.targetId, 'TargetPurposeListen', e.lastListenSequenceNumber, t, n, Ko.fromBase64String(e.resumeToken))
        );
      }
      function Dc(e, t) {
        const n = Oc(t.snapshotVersion),
          r = Oc(t.lastLimboFreeSnapshotVersion);
        let i;
        i = na(t.target) ? fc(e.fe, t.target) : dc(e.fe, t.target);
        const o = t.resumeToken.toBase64();
        return {
          targetId: t.targetId,
          canonicalId: ea(t.target),
          readTime: n,
          resumeToken: o,
          lastListenSequenceNumber: t.sequenceNumber,
          lastLimboFreeSnapshotVersion: r,
          query: i
        };
      }
      function Lc(e) {
        const t = pc({ parent: e.parent, structuredQuery: e.structuredQuery });
        return 'LAST' === e.limitType ? ma(t, t.limit, 'L') : t;
      }
      function jc(e, t) {
        return new wu(t.largestBatchId, lc(e.fe, t.overlayMutation));
      }
      function Mc(e, t) {
        const n = t.path.lastSegment();
        return [e, so(t.path.popLast()), n];
      }
      function Fc(e, t, n, r) {
        return {
          indexId: e,
          uid: t.uid || '',
          sequenceNumber: n,
          readTime: Oc(r.readTime),
          documentKey: so(r.documentKey.path),
          largestBatchId: r.largestBatchId
        };
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
