  const t = e.mc.values().next().value;
          e.mc.delete(t);
          const n = new Ni(Ci.fromString(t)),
            r = e.Ac.next();
          e.yc.set(r, new rd(n)), (e.gc = e.gc.insert(n, r)), lf(e.remoteStore, new Tc(pa(ua(n.path)), r, 'TargetPurposeLimboResolution', no.ct));
        }
      }
      async function Id(e, t, n) {
        const r = ui(e),
          i = [],
          o = [],
          s = [];
        r.wc.isEmpty() ||
          (r.wc.forEach((e, a) => {
            s.push(
              r.Rc(a, t, n).then(e => {
                if (
                  ((e || n) &&
                    r.isPrimaryClient &&
                    r.sharedClientState.updateQueryState(a.targetId, (null == e ? void 0 : e.fromCache) ? 'not-current' : 'current'),
                  e)
                ) {
                  i.push(e);
                  const t = gh.Li(a.targetId, e);
                  o.push(t);
                }
              })
            );
          }),
          await Promise.all(s),
          r.dc.nu(i),
          await (async function (e, t) {
            const n = ui(e);
            try {
              await n.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', e =>
                zi.forEach(t, t =>
                  zi
                    .forEach(t.Fi, r => n.persistence.referenceDelegate.addReference(e, t.targetId, r))
                    .next(() => zi.forEach(t.Bi, r => n.persistence.referenceDelegate.removeReference(e, t.targetId, r)))
                )
              );
            } catch (e) {
              if (!Qi(e)) throw e;
              ti('LocalStore', 'Failed to update sequence numbers: ' + e);
            }
            for (const r of t) {
              const e = r.targetId;
              if (!r.fromCache) {
                const t = n.Ji.get(e),
                  r = t.snapshotVersion,
                  i = t.withLastLimboFreeSnapshotVersion(r);
                n.Ji = n.Ji.insert(e, i);
              }
            }
          })(r.localStore, o));
      }
      async function Ed(e, t) {
        const n = ui(e);
        if (!n.currentUser.isEqual(t)) {
          ti('SyncEngine', 'User change. New user:', t.toKey());
          const e = await wh(n.localStore, t);
          (n.currentUser = t),
            (function (e, t) {
              e.Ec.forEach(e => {
                e.forEach(e => {
                  e.reject(new li(ci.CANCELLED, t));
                });
              }),
                e.Ec.clear();
            })(n, "'waitForPendingWrites' promise is rejected due to a user change."),
            n.sharedClientState.handleUserChange(t, e.removedBatchIds, e.addedBatchIds),
            await Id(n, e.er);
        }
      }
      function Sd(e, t) {
        const n = ui(e),
          r = n.yc.get(t);
        if (r && r.fc) return La().add(r.key);
        {
          let e = La();
          const r = n._c.get(t);
          if (!r) return e;
          for (const t of r) {
            const r = n.wc.get(t);
            e = e.unionWith(r.view.nc);
          }
          return e;
        }
      }
      async function Td(e, t) {
        const n = ui(e),
          r = await xh(n.localStore, t.query, !0),
          i = t.view.hc(r);
        return n.isPrimaryClient && wd(n, t.targetId, i.cc), i;
      }
      async function Ad(e, t) {
        const n = ui(e);
        return kh(n.localStore, t).then(e => Id(n, e));
      }
      async function xd(e, t, n, r) {
        const i = ui(e),
          o = await (function (e, t) {
            const n = ui(e),
              r = ui(n.mutationQueue);
            return n.persistence.runTransaction('Lookup mutation documents', 'readonly', e =>
              r.Sn(e, t).next(t => (t ? n.localDocuments.getDocuments(e, t) : zi.resolve(null)))
            );
          })(i.localStore, t);
        null !== o
          ? ('pending' === n
              ? await Ef(i.remoteStore)
              : 'acknowledged' === n || 'rejected' === n
                ? (md(i, t, r || null),
                  gd(i, t),
                  (function (e, t) {
                    ui(ui(e).mutationQueue).Cn(t);
                  })(i.localStore, t))
                : oi(),
            await Id(i, o))
          : ti('SyncEngine', 'Cannot apply mutation batch with id: ' + t);
      }
      async function Cd(e, t) {
        const n = ui(e);
        if ((Dd(n), Ld(n), !0 === t && !0 !== n.vc)) {
          const e = n.sharedClientState.getAllActiveQueryTargets(),
            t = await kd(n, e.toArray());
          (n.vc = !0), await Pf(n.remoteStore, !0);
          for (const r of t) lf(n.remoteStore, r);
        } else if (!1 === t && !1 !== n.vc) {
          const e = [];
          let t = Promise.resolve();
          n._c.forEach((r, i) => {
            n.sharedClientState.isLocalQueryTarget(i) ? e.push(i) : (t = t.then(() => (vd(n, i), Ah(n.localStore, i, !0)))), hf(n.remoteStore, i);
          }),
            await t,
            await kd(n, e),
            (function (e) {
              const t = ui(e);
              t.yc.forEach((e, n) => {
                hf(t.remoteStore, n);
              }),
                t.Ic.Ts(),
                (t.yc = new Map()),
                (t.gc = new Uo(Ni.comparator));
            })(n),
            (n.vc = !1),
            await Pf(n.remoteStore, !1);
        }
      }
      async function kd(e, t, n) {
        const r = ui(e),
          i = [],
          o = [];
        for (const s of t) {
          let e;
          const t = r._c.get(s);
          if (t && 0 !== t.length) {
            e = await Th(r.localStore, pa(t[0]));
            for (const e of t) {
              const t = r.wc.get(e),
                n = await Td(r, t);
              n.snapshot && o.push(n.snapshot);
            }
          } else {
            const t = await Ch(r.localStore, s);
            (e = await Th(r.localStore, t)), await sd(r, Od(t), s, !1, e.resumeToken);
          }
          i.push(e);
        }
        return r.dc.nu(o), i;
      }
      function Od(e) {
        return aa(e.path, e.collectionGroup, e.orderBy, e.filters, e.limit, 'F', e.startAt, e.endAt);
      }
      function Nd(e) {
        const t = ui(e);
        return ui(ui(t.localStore).persistence).$i();
      }
      async function Rd(e, t, n, r) {
        const i = ui(e);
        if (i.vc) return void ti('SyncEngine', 'Ignoring unexpected query state notification.');
        const o = i._c.get(t);
        if (o && o.length > 0)
          switch (n) {
            case 'current':
            case 'not-current': {
              const e = await kh(i.localStore, _a(o[0])),
                r = Pu.createSynthesizedRemoteEventForCurrentChange(t, 'current' === n, Ko.EMPTY_BYTE_STRING);
              await Id(i, e, r);
              break;
            }
            case 'rejected':
              await Ah(i.localStore, t, !0), vd(i, t, r);
              break;
            default:
              oi();
          }
      }
      async function Pd(e, t, n) {
        const r = Dd(e);
        if (r.vc) {
          for (const e of t) {
            if (r._c.has(e)) {
              ti('SyncEngine', 'Adding an already active target ' + e);
              continue;
            }
            const t = await Ch(r.localStore, e),
              n = await Th(r.localStore, t);
            await sd(r, Od(t), n.targetId, !1, n.resumeToken), lf(r.remoteStore, n);
          }
          for (const e of n)
            r._c.has(e) &&
              (await Ah(r.localStore, e, !1)
                .then(() => {
                  hf(r.remoteStore, e), vd(r, e);
                })
                .catch(qi));
        }
      }
      function Dd(e) {
        const t = ui(e);
        return (
          (t.remoteStore.remoteSyncer.applyRemoteEvent = cd.bind(null, t)),
          (t.remoteStore.remoteSyncer.getRemoteKeysForTarget = Sd.bind(null, t)),
          (t.remoteStore.remoteSyncer.rejectListen = hd.bind(null, t)),
          (t.dc.nu = Gf.bind(null, t.eventManager)),
          (t.dc.Pc = Wf.bind(null, t.eventManager)),
          t
        );
      }
      function Ld(e) {
        const t = ui(e);
        return (
          (t.remoteStore.remoteSyncer.applySuccessfulWrite = fd.bind(null, t)), (t.remoteStore.remoteSyncer.rejectFailedWrite = dd.bind(null, t)), t
        );
      }
      function jd(e, t, n) {
        const r = ui(e);
        (async function (e, t, n) {
          try {
            const r = await t.getMetadata();
            if (
              await (function (e, t) {
                const n = ui(e),
                  r = Yu(t.createTime);
                return n.persistence
                  .runTransaction('hasNewerBundle', 'readonly', e => n.qs.getBundleMetadata(e, t.id))
                  .then(e => !!e && e.createTime.compareTo(r) >= 0);
              })(e.localStore, r)
            )
              return (
                await t.close(),
                n._completeWith(
                  (function (e) {
                    return {
                      taskState: 'Success',
                      documentsLoaded: e.totalDocuments,
                      bytesLoaded: e.totalBytes,
                      totalDocuments: e.totalDocuments,
                      totalBytes: e.totalBytes
                    };
                  })(r)
                ),
                Promise.resolve(new Set())
              );
            n._updateProgress(Jf(r));
            const i = new Xf(r, e.localStore, t.serializer);
            let o = await t.bc();
            for (; o; ) {
              const e = await i.zu(o);
              e && n._updateProgress(e), (o = await t.bc());
            }
            const s = await i.complete();
            return (
              await Id(e, s.Ju, void 0),
              await (function (e, t) {
                const n = ui(e);
                return n.persistence.runTransaction('Save bundle', 'readwrite', e => n.qs.saveBundleMetadata(e, t));
              })(e.localStore, r),
              n._completeWith(s.progress),
              Promise.resolve(s.Hu)
            );
          } catch (e) {
            return ri('SyncEngine', `Loading bundle failed with ${e}`), n._failWith(e), Promise.resolve(new Set());
          }
        })(
          /**
           * @license
           * Copyright 2020 Google LLC
           *
           * Licensed under the Apache License, Version 2.0 (the "License");
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *   http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an "AS IS" BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */ r,
          t,
          n
        ).then(e => {
          r.sharedClientState.notifyBundleLoaded(e);
        });
      }
      class Md {
        constructor() {
          this.synchronizeTabs = !1;
        }
        async initialize(e) {
          (this.serializer = Zh(e.databaseInfo.databaseId)),
            (this.sharedClientState = this.createSharedClientState(e)),
            (this.persistence = this.createPersistence(e)),
            await this.persistence.start(),
            (this.localStore = this.createLocalStore(e)),
            (this.gcScheduler = this.createGarbageCollectionScheduler(e, this.localStore)),
            (this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(e, this.localStore));
        }
        createGarbageCollectionScheduler(e, t) {
          return null;
        }
        createIndexBackfillerScheduler(e, t) {
          return null;
        }
        createLocalStore(e) {
          return yh(this.persistence, new mh(), e.initialUser, this.serializer);
        }
        createPersistence(e) {
          return new oh(ah.zs, this.serializer);
        }
        createSharedClientState(e) {
          return new $h();
        }
        async terminate() {
          this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
        }
      }
      class Fd extends Md {
        constructor(e, t, n) {
          super(), (this.Vc = e), (this.cacheSizeBytes = t), (this.forceOwnership = n), (this.synchronizeTabs = !1);
        }
        async initialize(e) {
          await super.initialize(e),
            await this.Vc.initialize(this, e),
            await Ld(this.Vc.syncEngine),
            await Ef(this.Vc.remoteStore),
            await this.persistence.Ii(
              () => (
                this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(),
                this.indexBackfillerScheduler && !this.indexBackfillerScheduler.started && this.indexBackfillerScheduler.start(),
                Promise.resolve()
              )
            );
        }
        createLocalStore(e) {
          return yh(this.persistence, new mh(), e.initialUser, this.serializer);
        }
        createGarbageCollectionScheduler(e, t) {
          const n = this.persistence.referenceDelegate.garbageCollector;
          return new Ll(n, e.asyncQueue, t);
        }
        createIndexBackfillerScheduler(e, t) {
          const n = new to(t, this.persistence);
          return new eo(e.asyncQueue, n);
        }
        createPersistence(e) {
          const t = ph(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey),
            n = void 0 !== this.cacheSizeBytes ? bl.withCacheSize(this.cacheSizeBytes) : bl.DEFAULT;
          return new hh(
            this.synchronizeTabs,
            t,
            e.clientId,
            n,
            e.asyncQueue,
            Xh(),
            Jh(),
            this.serializer,
            this.sharedClientState,
            !!this.forceOwnership
          );
        }
        createSharedClientState(e) {
          return new $h();
        }
      }
      class Ud extends Fd {
        constructor(e, t) {
          super(e, t, !1), (this.Vc = e), (this.cacheSizeBytes = t), (this.synchronizeTabs = !0);
        }
        async initialize(e) {
          await super.initialize(e);
          const t = this.Vc.syncEngine;
          this.sharedClientState instanceof Bh &&
            ((this.sharedClientState.syncEngine = {
              jr: xd.bind(null, t),
              zr: Rd.bind(null, t),
              Wr: Pd.bind(null, t),
              $i: Nd.bind(null, t),
              Qr: Ad.bind(null, t)
            }),
            await this.sharedClientState.start()),
            await this.persistence.Ii(async e => {
              await Cd(this.Vc.syncEngine, e),
                this.gcScheduler && (e && !this.gcScheduler.started ? this.gcScheduler.start() : e || this.gcScheduler.stop()),
                this.indexBackfillerScheduler &&
                  (e && !this.indexBackfillerScheduler.started ? this.indexBackfillerScheduler.start() : e || this.indexBackfillerScheduler.stop());
            });
        }
        createSharedClientState(e) {
          const t = Xh();
          if (!Bh.D(t)) throw new li(ci.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');
          const n = ph(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey);
          return new Bh(t, e.asyncQueue, n, e.clientId, e.initialUser);
        }
      }
      class Vd {
        async initialize(e, t) {
          this.localStore ||
            ((this.localStore = e.localStore),
            (this.sharedClientState = e.sharedClientState),
            (this.datastore = this.createDatastore(t)),
            (this.remoteStore = this.createRemoteStore(t)),
            (this.eventManager = this.createEventManager(t)),
            (this.syncEngine = this.createSyncEngine(t, !e.synchronizeTabs)),
            (this.sharedClientState.onlineStateHandler = e => ld(this.syncEngine, e, 1)),
            (this.remoteStore.remoteSyncer.handleCredentialChange = Ed.bind(null, this.syncEngine)),
            await Pf(this.remoteStore, this.syncEngine.isPrimaryClient));
        }
        createEventManager(e) {
          return new $f();
        }
        createDatastore(e) {
          const t = Zh(e.databaseInfo.databaseId),
            n = ((r = e.databaseInfo), new Yh(r));
          var r;
          return (function (e, t, n, r) {
            return new of(e, t, n, r);
          })(e.authCredentials, e.appCheckCredentials, n, t);
        }
        createRemoteStore(e) {
          return (
            (t = this.localStore),
            (n = this.datastore),
            (r = e.asyncQueue),
            (i = e => ld(this.syncEngine, e, 0)),
            (o = zh.D() ? new zh() : new qh()),
            new af(t, n, r, i, o)
          );
          var t, n, r, i, o;
        }
        createSyncEngine(e, t) {
          return (function (e, t, n, r, i, o, s) {
            const a = new id(e, t, n, r, i, o);
            return s && (a.vc = !0), a;
          })(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t);
        }
        terminate() {
          return (async function (e) {
            const t = ui(e);
            ti('RemoteStore', 'RemoteStore shutting down.'), t.vu.add(5), await cf(t), t.Pu.shutdown(), t.bu.set('Unknown');
          })(this.remoteStore);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Bd(e, t = 10240) {
        let n = 0;
        return {
          async read() {
            if (n < e.byteLength) {
              const r = { value: e.slice(n, n + t), done: !1 };
              return (n += t), r;
            }
            return { done: !0 };
          },
          async cancel() {},
          releaseLock() {},
          closed: Promise.resolve()
        };
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class $d {
        constructor(e) {
          (this.observer = e), (this.muted = !1);
        }
        next(e) {
          this.observer.next && this.Sc(this.observer.next, e);
        }
        error(e) {
          this.observer.error ? this.Sc(this.observer.error, e) : ni('Uncaught Error in snapshot listener:', e.toString());
        }
        Dc() {
          this.muted = !0;
        }
        Sc(e, t) {
          this.muted ||
            setTimeout(() => {
              this.muted || e(t);
            }, 0);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class qd {
        constructor(e, t) {
          (this.Cc = e),
            (this.serializer = t),
            (this.metadata = new hi()),
            (this.buffer = new Uint8Array()),
            (this.xc = new TextDecoder('utf-8')),
            this.Nc().then(
              e => {
                e && e.Qu()
                  ? this.metadata.resolve(e.Gu.metadata)
                  : this.metadata.reject(
                      new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(null == e ? void 0 : e.Gu)}`)
                    );
              },
              e => this.metadata.reject(e)
            );
        }
        close() {
          return this.Cc.cancel();
        }
        async getMetadata() {
          return this.metadata.promise;
        }
        async bc() {
          return await this.getMetadata(), this.Nc();
        }
        async Nc() {
          const e = await this.kc();
          if (null === e) return null;
          const t = this.xc.decode(e),
            n = Number(t);
          isNaN(n) && this.Mc(`length string (${t}) is not valid number`);
          const r = await this.$c(n);
          return new Qf(JSON.parse(r), e.length + n);
        }
        Oc() {
          return this.buffer.findIndex(e => e === '{'.charCodeAt(0));
        }
        async kc() {
          for (; this.Oc() < 0; ) if (await this.Fc()) break;
          if (0 === this.buffer.length) return null;
          const e = this.Oc();
          e < 0 && this.Mc('Reached the end of bundle when a length string is expected.');
          const t = this.buffer.slice(0, e);
          return (this.buffer = this.buffer.slice(e)), t;
        }
        async $c(e) {
          for (; this.buffer.length < e; ) (await this.Fc()) && this.Mc('Reached the end of bundle when more is expected.');
          const t = this.xc.decode(this.buffer.slice(0, e));
          return (this.buffer = this.buffer.slice(e)), t;
        }
        Mc(e) {
          throw (this.Cc.cancel(), new Error(`Invalid bundle format: ${e}`));
        }
        async Fc() {
          const e = await this.Cc.read();
          if (!e.done) {
            const t = new Uint8Array(this.buffer.length + e.value.length);
            t.set(this.buffer), t.set(e.value, this.buffer.length), (this.buffer = t);
          }
          return e.done;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class zd {
        constructor(e) {
          (this.datastore = e),
            (this.readVersions = new Map()),
            (this.mutations = []),
            (this.committed = !1),
            (this.lastWriteError = null),
            (this.writtenDocs = new Set());
        }
        async lookup(e) {
          if ((this.ensureCommitNotCalled(), this.mutations.length > 0))
            throw new li(ci.INVALID_ARGUMENT, 'Firestore transactions require all reads to be executed before all writes.');
          const t = await (async function (e, t) {
            const n = ui(e),
              r = rc(n.serializer) + '/documents',
              i = { documents: t.map(e => Zu(n.serializer, e)) },
              o = await n.vo('BatchGetDocuments', r, i, t.length),
              s = new Map();
            o.forEach(e => {
              const t = ac(n.serializer, e);
              s.set(t.key.toString(), t);
            });
            const a = [];
            return (
              t.forEach(e => {
                const t = s.get(e.toString());
                si(!!t), a.push(t);
              }),
              a
            );
          })(this.datastore, e);
          return t.forEach(e => this.recordVersion(e)), t;
        }
        set(e, t) {
          this.write(t.toMutation(e, this.precondition(e))), this.writtenDocs.add(e.toString());
        }
        update(e, t) {
          try {
            this.write(t.toMutation(e, this.preconditionForUpdate(e)));
          } catch (e) {
            this.lastWriteError = e;
          }
          this.writtenDocs.add(e.toString());
        }
        delete(e) {
          this.write(new gu(e, this.precondition(e))), this.writtenDocs.add(e.toString());
        }
        async commit() {
          if ((this.ensureCommitNotCalled(), this.lastWriteError)) throw this.lastWriteError;
          const e = this.readVersions;
          this.mutations.forEach(t => {
            e.delete(t.key.toString());
          }),
            e.forEach((e, t) => {
              const n = Ni.fromPath(t);
              this.mutations.push(new mu(n, this.precondition(n)));
            }),
            await (async function (e, t) {
              const n = ui(e),
                r = rc(n.serializer) + '/documents',
                i = { writes: t.map(e => cc(n.serializer, e)) };
              await n.Io('Commit', r, i);
            })(this.datastore, this.mutations),
            (this.committed = !0);
        }
        recordVersion(e) {
          let t;
          if (e.isFoundDocument()) t = e.version;
          else {
            if (!e.isNoDocument()) throw oi();
            t = Ai.min();
          }
          const n = this.readVersions.get(e.key.toString());
          if (n) {
            if (!t.isEqual(n)) throw new li(ci.ABORTED, 'Document version changed between two reads.');
          } else this.readVersions.set(e.key.toString(), t);
        }
        precondition(e) {
          const t = this.readVersions.get(e.toString());
          return !this.writtenDocs.has(e.toString()) && t ? (t.isEqual(Ai.min()) ? nu.exists(!1) : nu.updateTime(t)) : nu.none();
        }
        preconditionForUpdate(e) {
          const t = this.readVersions.get(e.toString());
          if (!this.writtenDocs.has(e.toString()) && t) {
            if (t.isEqual(Ai.min())) throw new li(ci.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
            return nu.updateTime(t);
          }
          return nu.exists(!0);
        }
        write(e) {
          this.ensureCommitNotCalled(), this.mutations.push(e);
        }
        ensureCommitNotCalled() {}
      }
      /**
       * @license
       * Copyright 2019 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Gd {
        constructor(e, t, n, r, i) {
          (this.asyncQueue = e),
            (this.datastore = t),
            (this.options = n),
            (this.updateFunction = r),
            (this.deferred = i),
            (this.Bc = n.maxAttempts),
            (this.qo = new ef(this.asyncQueue, 'transaction_retry'));
        }
        run() {
          (this.Bc -= 1), this.Lc();
        }
        Lc() {
          this.qo.No(async () => {
            const e = new zd(this.datastore),
              t = this.qc(e);
            t &&
              t
                .then(t => {
                  this.asyncQueue.enqueueAndForget(() =>
                    e
                      .commit()
                      .then(() => {
                        this.deferred.resolve(t);
                      })
                      .catch(e => {
                        this.Uc(e);
                      })
                  );
                })
                .catch(e => {
                  this.Uc(e);
                });
          });
        }
        qc(e) {
          try {
            const t = this.updateFunction(e);
            return !ro(t) && t.catch && t.then ? t : (this.deferred.reject(Error('Transaction callback must return a Promise')), null);
          } catch (e) {
            return this.deferred.reject(e), null;
          }
        }
        Uc(e) {
          this.Bc > 0 && this.Kc(e)
            ? ((this.Bc -= 1), this.asyncQueue.enqueueAndForget(() => (this.Lc(), Promise.resolve())))
            : this.deferred.reject(e);
        }
        Kc(e) {
          if ('FirebaseError' === e.name) {
            const t = e.code;
            return 'aborted' === t || 'failed-precondition' === t || 'already-exists' === t || !Eu(t);
          }
          return !1;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Wd {
        constructor(e, t, n, r) {
          (this.authCredentials = e),
            (this.appCheckCredentials = t),
            (this.asyncQueue = n),
            (this.databaseInfo = r),
            (this.user = Yr.UNAUTHENTICATED),
            (this.clientId = _i.A()),
            (this.authCredentialListener = () => Promise.resolve()),
            (this.appCheckCredentialListener = () => Promise.resolve()),
            this.authCredentials.start(n, async e => {
              ti('FirestoreClient', 'Received user=', e.uid), await this.authCredentialListener(e), (this.user = e);
            }),
            this.appCheckCredentials.start(
              n,
              e => (ti('FirestoreClient', 'Received new app check token=', e), this.appCheckCredentialListener(e, this.user))
            );
        }
        async getConfiguration() {
          return {
            asyncQueue: this.asyncQueue,
            databaseInfo: this.databaseInfo,
            clientId: this.clientId,
            authCredentials: this.authCredentials,
            appCheckCredentials: this.appCheckCredentials,
            initialUser: this.user,
            maxConcurrentLimboResolutions: 100
          };
        }
        setCredentialChangeListener(e) {
          this.authCredentialListener = e;
        }
        setAppCheckTokenChangeListener(e) {
          this.appCheckCredentialListener = e;
        }
        verifyNotTerminated() {
          if (this.asyncQueue.isShuttingDown) throw new li(ci.FAILED_PRECONDITION, 'The client has already been terminated.');
        }
        terminate() {
          this.asyncQueue.enterRestrictedMode();
          const e = new hi();
          return (
            this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
              try {
                this._onlineComponents && (await this._onlineComponents.terminate()),
                  this._offlineComponents && (await this._offlineComponents.terminate()),
                  this.authCredentials.shutdown(),
                  this.appCheckCredentials.shutdown(),
                  e.resolve();
              } catch (t) {
                const n = Mf(t, 'Failed to shutdown persistence');
                e.reject(n);
              }
            }),
            e.promise
          );
        }
      }
      async function Hd(e, t) {
        e.asyncQueue.verifyOperationInProgress(), ti('FirestoreClient', 'Initializing OfflineComponentProvider');
        const n = await e.getConfiguration();
        await t.initialize(n);
        let r = n.initialUser;
        e.setCredentialChangeListener(async e => {
          r.isEqual(e) || (await wh(t.localStore, e), (r = e));
        }),
          t.persistence.setDatabaseDeletedListener(() => e.terminate()),
          (e._offlineComponents = t);
      }
      async function Kd(e, t) {
        e.asyncQueue.verifyOperationInProgress();
        const n = await Yd(e);
        ti('FirestoreClient', 'Initializing OnlineComponentProvider');
        const r = await e.getConfiguration();
        await t.initialize(n, r),
          e.setCredentialChangeListener(e => Rf(t.remoteStore, e)),
          e.setAppCheckTokenChangeListener((e, n) => Rf(t.remoteStore, n)),
          (e._onlineComponents = t);
      }
      function Qd(e) {
        return 'FirebaseError' === e.name
          ? e.code === ci.FAILED_PRECONDITION || e.code === ci.UNIMPLEMENTED
          : !('undefined' != typeof DOMException && e instanceof DOMException) || 22 === e.code || 20 === e.code || 11 === e.code;
      }
      async function Yd(e) {
        if (!e._offlineComponents)
          if (e._uninitializedComponentsProvider) {
            ti('FirestoreClient', 'Using user provided OfflineComponentProvider');
            try {
              await Hd(e, e._uninitializedComponentsProvider._offline);
            } catch (t) {
              const n = t;
              if (!Qd(n)) throw n;
              ri('Error using user provided cache. Falling back to memory cache: ' + n), await Hd(e, new Md());
            }
          } else ti('FirestoreClient', 'Using default OfflineComponentProvider'), await Hd(e, new Md());
        return e._offlineComponents;
      }
      async function Xd(e) {
        return (
          e._onlineComponents ||
            (e._uninitializedComponentsProvider
              ? (ti('FirestoreClient', 'Using user provided OnlineComponentProvider'), await Kd(e, e._uninitializedComponentsProvider._online))
              : (ti('FirestoreClient', 'Using default OnlineComponentProvider'), await Kd(e, new Vd()))),
          e._onlineComponents
        );
      }
      function Jd(e) {
        return Yd(e).then(e => e.persistence);
      }
      function Zd(e) {
        return Yd(e).then(e => e.localStore);
      }
      function ep(e) {
        return Xd(e).then(e => e.remoteStore);
      }
      function tp(e) {
        return Xd(e).then(e => e.syncEngine);
      }
      function np(e) {
        return Xd(e).then(e => e.datastore);
      }
      async function rp(e) {
        const t = await Xd(e),
          n = t.eventManager;
        return (n.onListen = od.bind(null, t.syncEngine)), (n.onUnlisten = ad.bind(null, t.syncEngine)), n;
      }
      function ip(e) {
        return e.asyncQueue.enqueue(async () => {
          const t = await Jd(e),
            n = await ep(e);
          return (
            t.setNetworkEnabled(!0),
            (function (e) {
              const t = ui(e);
              return t.vu.delete(0), uf(t);
            })(n)
          );
        });
      }
      function op(e) {
        return e.asyncQueue.enqueue(async () => {
          const t = await Jd(e),
            n = await ep(e);
          return (
            t.setNetworkEnabled(!1),
            (async function (e) {
              const t = ui(e);
              t.vu.add(0), await cf(t), t.bu.set('Offline');
            })(n)
          );
        });
      }
      function sp(e, t) {
        const n = new hi();
        return (
          e.asyncQueue.enqueueAndForget(async () =>
            (async function (e, t, n) {
              try {
                const r = await (function (e, t) {
                  const n = ui(e);
                  return n.persistence.runTransaction('read document', 'readonly', e => n.localDocuments.getDocument(e, t));
                })(e, t);
                r.isFoundDocument()
                  ? n.resolve(r)
                  : r.isNoDocument()
                    ? n.resolve(null)
                    : n.reject(
                        new li(
                          ci.UNAVAILABLE,
                          "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"
                        )
                      );
              } catch (e) {
                const r = Mf(e, `Failed to get document '${t} from cache`);
                n.reject(r);
              }
            })(await Zd(e), t, n)
          ),
          n.promise
        );
      }
      function ap(e, t, n = {}) {
        const r = new hi();
        return (
          e.asyncQueue.enqueueAndForget(async () =>
            (function (e, t, n, r, i) {
              const o = new $d({
                  next: o => {
                    t.enqueueAndForget(() => zf(e, s));
                    const a = o.docs.has(n);
                    !a && o.fromCache
                      ? i.reject(new li(ci.UNAVAILABLE, 'Failed to get document because the client is offline.'))
                      : a && o.fromCache && r && 'server' === r.source
                        ? i.reject(
                            new li(
                              ci.UNAVAILABLE,
                              'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)'
                            )
                          )
                        : i.resolve(o);
                  },
                  error: e => i.reject(e)
                }),
                s = new Kf(ua(n.path), o, { includeMetadataChanges: !0, Ku: !0 });
              return qf(e, s);
            })(await rp(e), e.asyncQueue, t, n, r)
          ),
          r.promise
        );
      }
      function up(e, t) {
        const n = new hi();
        return (
          e.asyncQueue.enqueueAndForget(async () =>
            (async function (e, t, n) {
              try {
                const r = await xh(e, t, !0),
                  i = new td(t, r.ir),
                  o = i.sc(r.documents),
                  s = i.applyChanges(o, !1);
                n.resolve(s.snapshot);
              } catch (e) {
                const r = Mf(e, `Failed to execute query '${t} against cache`);
                n.reject(r);
              }
            })(await Zd(e), t, n)
          ),
          n.promise
        );
      }
      function cp(e, t, n = {}) {
        const r = new hi();
        return (
          e.asyncQueue.enqueueAndForget(async () =>
            (function (e, t, n, r, i) {
              const o = new $d({
                  next: n => {
                    t.enqueueAndForget(() => zf(e, s)),
                      n.fromCache && 'server' === r.source
                        ? i.reject(
                            new li(
                              ci.UNAVAILABLE,
                              'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)'
                            )
                          )
                        : i.resolve(n);
                  },
                  error: e => i.reject(e)
                }),
                s = new Kf(n, o, { includeMetadataChanges: !0, Ku: !0 });
              return qf(e, s);
            })(await rp(e), e.asyncQueue, t, n, r)
          ),
          r.promise
        );
      }
      function lp(e, t) {
        const n = new $d(t);
        return (
          e.asyncQueue.enqueueAndForget(async () =>
            (function (e, t) {
              ui(e).ku.add(t), t.next();
            })(await rp(e), n)
          ),
          () => {
            n.Dc(),
              e.asyncQueue.enqueueAndForget(async () =>
                (function (e, t) {
                  ui(e).ku.delete(t);
                })(await rp(e), n)
              );
          }
        );
      }
      function hp(e, t, n, r) {
        const i = (function (e, t) {
          let n;
          return (
            (n = 'string' == typeof e ? xu().encode(e) : e),
            (function (e, t) {
              return new qd(e, t);
            })(
              (function (e, t) {
                if (e instanceof Uint8Array) return Bd(e, t);
                if (e instanceof ArrayBuffer) return Bd(new Uint8Array(e), t);
                if (e instanceof ReadableStream) return e.getReader();
                throw new Error('Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream');
              })(n),
              t
            )
          );
        })(n, Zh(t));
        e.asyncQueue.enqueueAndForget(async () => {
          jd(await tp(e), i, r);
        });
      }
      function fp(e, t) {
        return e.asyncQueue.enqueue(async () =>
          (function (e, t) {
            const n = ui(e);
            return n.persistence.runTransaction('Get named query', 'readonly', e => n.qs.getNamedQuery(e, t));
          })(await Zd(e), t)
        );
      }
      /**
       * @license
       * Copyright 2023 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function dp(e) {
        const t = {};
        return void 0 !== e.timeoutSeconds && (t.timeoutSeconds = e.timeoutSeconds), t;
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      const pp = new Map();
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function gp(e, t, n) {
        if (!n) throw new li(ci.INVALID_ARGUMENT, `Function ${e}() cannot be called with an empty ${t}.`);
      }
      function mp(e, t, n, r) {
        if (!0 === t && !0 === r) throw new li(ci.INVALID_ARGUMENT, `${e} and ${n} cannot be used together.`);
      }
      function vp(e) {
        if (!Ni.isDocumentKey(e))
          throw new li(
            ci.INVALID_ARGUMENT,
            `Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`
          );
      }
      function yp(e) {
        if (Ni.isDocumentKey(e))
          throw new li(
            ci.INVALID_ARGUMENT,
            `Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`
          );
      }
      function wp(e) {
        if (void 0 === e) return 'undefined';
        if (null === e) return 'null';
        if ('string' == typeof e) return e.length > 20 && (e = `${e.substring(0, 20)}...`), JSON.stringify(e);
        if ('number' == typeof e || 'boolean' == typeof e) return '' + e;
        if ('object' == typeof e) {
          if (e instanceof Array) return 'an array';
          {
            const t = (function (e) {
              return e.constructor ? e.constructor.name : null;
            })(e);
            return t ? `a custom ${t} object` : 'an object';
          }
        }
        return 'function' == typeof e ? 'a function' : oi();
      }
      function bp(e, t) {
        if (('_delegate' in e && (e = e._delegate), !(e instanceof t))) {
          if (t.name === e.constructor.name)
            throw new li(ci.INVALID_ARGUMENT, 'Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?');
          {
            const n = wp(e);
            throw new li(ci.INVALID_ARGUMENT, `Expected type '${t.name}', but it was: ${n}`);
          }
        }
        return e;
      }
      function _p(e, t) {
        if (t <= 0) throw new li(ci.INVALID_ARGUMENT, `Function ${e}() requires a positive number, but it was: ${t}.`);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ip {
        constructor(e) {
          var t, n;
          if (void 0 === e.host) {
            if (void 0 !== e.ssl) throw new li(ci.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
            (this.host = 'firestore.googleapis.com'), (this.ssl = !0);
          } else (this.host = e.host), (this.ssl = null === (t = e.ssl) || void 0 === t || t);
          if (
            ((this.credentials = e.credentials),
            (this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties),
            (this.cache = e.localCache),
            void 0 === e.cacheSizeBytes)
          )
            this.cacheSizeBytes = 41943040;
          else {
            if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576) throw new li(ci.INVALID_ARGUMENT, 'cacheSizeBytes must be at least 1048576');
            this.cacheSizeBytes = e.cacheSizeBytes;
          }
          mp(
            'experimentalForceLongPolling',
            e.experimentalForceLongPolling,
            'experimentalAutoDetectLongPolling',
            e.experimentalAutoDetectLongPolling
          ),
            (this.experimentalForceLongPolling = !!e.experimentalForceLongPolling),
            this.experimentalForceLongPolling
              ? (this.experimentalAutoDetectLongPolling = !1)
              : void 0 === e.experimentalAutoDetectLongPolling
                ? (this.experimentalAutoDetectLongPolling = !0)
                : (this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling),
            (this.experimentalLongPollingOptions = dp(null !== (n = e.experimentalLongPollingOptions) && void 0 !== n ? n : {})),
            (function (e) {
              if (void 0 !== e.timeoutSeconds) {
                if (isNaN(e.timeoutSeconds)) throw new li(ci.INVALID_ARGUMENT, `invalid long polling timeout: ${e.timeoutSeconds} (must not be NaN)`);
                if (e.timeoutSeconds < 5)
                  throw new li(ci.INVALID_ARGUMENT, `invalid long polling timeout: ${e.timeoutSeconds} (minimum allowed value is 5)`);
                if (e.timeoutSeconds > 30)
                  throw new li(ci.INVALID_ARGUMENT, `invalid long polling timeout: ${e.timeoutSeconds} (maximum allowed value is 30)`);
              }
            })(
              /**
               * @license
               * Copyright 2020 Google LLC
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *   http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */ this.experimentalLongPollingOptions
            ),
            (this.useFetchStreams = !!e.useFetchStreams);
        }
        isEqual(e) {
          return (
            this.host === e.host &&
            this.ssl === e.ssl &&
            this.credentials === e.credentials &&
            this.cacheSizeBytes === e.cacheSizeBytes &&
            this.experimentalForceLongPolling === e.experimentalForceLongPolling &&
            this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling &&
            ((t = this.experimentalLongPollingOptions), (n = e.experimentalLongPollingOptions), t.timeoutSeconds === n.timeoutSeconds) &&
            this.ignoreUndefinedProperties === e.ignoreUndefinedProperties &&
            this.useFetchStreams === e.useFetchStreams
          );
          var t, n;
        }
      }
      class Ep {
        constructor(e, t, n, r) {
          (this._authCredentials = e),
            (this._appCheckCredentials = t),
            (this._databaseId = n),
            (this._app = r),
            (this.type = 'firestore-lite'),
            (this._persistenceKey = '(lite)'),
            (this._settings = new Ip({})),
            (this._settingsFrozen = !1);
        }
        get app() {
          if (!this._app) throw new li(ci.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
          return this._app;
        }
        get _initialized() {
          return this._settingsFrozen;
        }
        get _terminated() {
          return void 0 !== this._terminateTask;
        }
        _setSettings(e) {
          if (this._settingsFrozen)
            throw new li(
              ci.FAILED_PRECONDITION,
              'Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.'
            );
          (this._settings = new Ip(e)),
            void 0 !== e.credentials &&
              (this._authCredentials = (function (e) {
                if (!e) return new di();
                switch (e.type) {
                  case 'firstParty':
                    return new vi(e.sessionIndex || '0', e.iamToken || null, e.authTokenFactory || null);
                  case 'provider':
                    return e.client;
                  default:
                    throw new li(ci.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type');
                }
              })(e.credentials));
        }
        _getSettings() {
          return this._settings;
        }
        _freezeSettings() {
          return (this._settingsFrozen = !0), this._settings;
        }
        _delete() {
          return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
        }
        toJSON() {
          return { app: this._app, databaseId: this._databaseId, settings: this._settings };
        }
        _terminate() {
          return (
            (function (e) {
              const t = pp.get(e);
              t && (ti('ComponentProvider', 'Removing Datastore'), pp.delete(e), t.terminate());
            })(this),
            Promise.resolve()
          );
        }
      }
      function Sp(e, t, n, r = {}) {
        var i;
        const o = (e = bp(e, Ep))._getSettings(),
          s = `${t}:${n}`;
        if (
          ('firestore.googleapis.com' !== o.host &&
            o.host !== s &&
            ri('Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used.'),
          e._setSettings(Object.assign(Object.assign({}, o), { host: s, ssl: !1 })),
          r.mockUserToken)
        ) {
          let t, n;
          if ('string' == typeof r.mockUserToken) (t = r.mockUserToken), (n = Yr.MOCK_USER);
          else {
            t = (0, u.Sg)(r.mockUserToken, null === (i = e._app) || void 0 === i ? void 0 : i.options.projectId);
            const o = r.mockUserToken.sub || r.mockUserToken.user_id;
            if (!o) throw new li(ci.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
            n = new Yr(o);
          }
          e._authCredentials = new pi(new fi(t, n));
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tp {
        constructor(e, t, n) {
          (this.converter = t), (this._key = n), (this.type = 'document'), (this.firestore = e);
        }
        get _path() {
          return this._key.path;
        }
        get id() {
          return this._key.path.lastSegment();
        }
        get path() {
          return this._key.path.canonicalString();
        }
        get parent() {
          return new xp(this.firestore, this.converter, this._key.path.popLast());
        }
        withConverter(e) {
          return new Tp(this.firestore, e, this._key);
        }
      }
      class Ap {
        constructor(e, t, n) {
          (this.converter = t), (this._query = n), (this.type = 'query'), (this.firestore = e);
        }
        withConverter(e) {
          return new Ap(this.firestore, e, this._query);
        }
      }
      class xp extends Ap {
        constructor(e, t, n) {
          super(e, t, ua(n)), (this._path = n), (this.type = 'collection');
        }
        get id() {
          return this._query.path.lastSegment();
        }
        get path() {
          return this._query.path.canonicalString();
        }
        get parent() {
          const e = this._path.popLast();
          return e.isEmpty() ? null : new Tp(this.firestore, null, new Ni(e));
        }
        withConverter(e) {
          return new xp(this.firestore, e, this._path);
        }
      }
      function Cp(e, t, ...n) {
        if (((e = (0, u.m9)(e)), gp('collection', 'path', t), e instanceof Ep)) {
          const r = Ci.fromString(t, ...n);
          return yp(r), new xp(e, null, r);
        }
        {
          if (!(e instanceof Tp || e instanceof xp))
            throw new li(
              ci.INVALID_ARGUMENT,
              'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore'
            );
          const r = e._path.child(Ci.fromString(t, ...n));
          return yp(r), new xp(e.firestore, null, r);
        }
      }
      function kp(e, t) {
        if (((e = bp(e, Ep)), gp('collectionGroup', 'collection id', t), t.indexOf('/') >= 0))
          throw new li(
            ci.INVALID_ARGUMENT,
            `Invalid collection ID '${t}' passed to function collectionGroup(). Collection IDs must not contain '/'.`
          );
        return new Ap(
          e,
          null,
          (function (e) {
            return new sa(Ci.emptyPath(), e);
          })(t)
        );
      }
      function Op(e, t, ...n) {
        if (((e = (0, u.m9)(e)), 1 === arguments.length && (t = _i.A()), gp('doc', 'path', t), e instanceof Ep)) {
          const r = Ci.fromString(t, ...n);
          return vp(r), new Tp(e, null, new Ni(r));
        }
        {
          if (!(e instanceof Tp || e instanceof xp))
            throw new li(
              ci.INVALID_ARGUMENT,
              'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore'
            );
          const r = e._path.child(Ci.fromString(t, ...n));
          return vp(r), new Tp(e.firestore, e instanceof xp ? e.converter : null, new Ni(r));
        }
      }
      function Np(e, t) {
        return (
          (e = (0, u.m9)(e)),
          (t = (0, u.m9)(t)),
          (e instanceof Tp || e instanceof xp) &&
            (t instanceof Tp || t instanceof xp) &&
            e.firestore === t.firestore &&
            e.path === t.path &&
            e.converter === t.converter
        );
      }
      function Rp(e, t) {
        return (
          (e = (0, u.m9)(e)),
          (t = (0, u.m9)(t)),
          e instanceof Ap && t instanceof Ap && e.firestore === t.firestore && va(e._query, t._query) && e.converter === t.converter
        );
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
      }
      class Pp {
        constructor() {
          (this.Gc = Promise.resolve()),
            (this.Qc = []),
            (this.jc = !1),
            (this.zc = []),
            (this.Wc = null),
            (this.Hc = !1),
            (this.Jc = !1),
            (this.Yc = []),
            (this.qo = new ef(this, 'async_queue_retry')),
            (this.Xc = () => {
              const e = Jh();
              e && ti('AsyncQueue', 'Visibility state changed to ' + e.visibilityState), this.qo.Mo();
            });
          const e = Jh();
          e && 'function' == typeof e.addEventListener && e.addEventListener('visibilitychange', this.Xc);
        }
        get isShuttingDown() {
          return this.jc;
        }
        enqueueAndForget(e) {
          this.enqueue(e);
        }
        enqueueAndForgetEvenWhileRestricted(e) {
          this.Zc(), this.ta(e);
        }
        enterRestrictedMode(e) {
          if (!this.jc) {
            (this.jc = !0), (this.Jc = e || !1);
            const t = Jh();
            t && 'function' == typeof t.removeEventListener && t.removeEventListener('visibilitychange', this.Xc);
          }
        }
        enqueue(e) {
          if ((this.Zc(), this.jc)) return new Promise(() => {});
          const t = new hi();
          return this.ta(() => (this.jc && this.Jc ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise))).then(() => t.promise);
        }
        enqueueRetryable(e) {
          this.enqueueAndForget(() => (this.Qc.push(e), this.ea()));
        }
        async ea() {
          if (0 !== this.Qc.length) {
            try {
              await this.Qc[0](), this.Qc.shift(), this.qo.reset();
            } catch (e) {
              if (!Qi(e)) throw e;
              ti('AsyncQueue', 'Operation failed with retryable error: ' + e);
            }
            this.Qc.length > 0 && this.qo.No(() => this.ea());
          }
        }
        ta(e) {
          const t = this.Gc.then(
            () => (
              (this.Hc = !0),
              e()
                .catch(e => {
                  (this.Wc = e), (this.Hc = !1);
                  const t = (function (e) {
                    let t = e.message || '';
                    return e.stack && (t = e.stack.includes(e.message) ? e.stack : e.message + '\n' + e.stack), t;
                  })(
                    /**
                     * @license
                     * Copyright 2017 Google LLC
                     *
                     * Licensed under the Apache License, Version 2.0 (the "License");
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *   http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an "AS IS" BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */ e
                  );
                  throw (ni('INTERNAL UNHANDLED ERROR: ', t), e);
                })
                .then(e => ((this.Hc = !1), e))
            )
          );
          return (this.Gc = t), t;
        }
        enqueueAfterDelay(e, t, n) {
          this.Zc(), this.Yc.indexOf(e) > -1 && (t = 0);
          const r = jf.createAndSchedule(this, e, t, n, e => this.na(e));
          return this.zc.push(r), r;
        }
        Zc() {
          this.Wc && oi();
        }
        verifyOperationInProgress() {}
        async sa() {
          let e;
          do {
            (e = this.Gc), await e;
          } while (e !== this.Gc);
        }
        ia(e) {
          for (const t of this.zc) if (t.timerId === e) return !0;
          return !1;
        }
        ra(e) {
          return this.sa().then(() => {
            this.zc.sort((e, t) => e.targetTimeMs - t.targetTimeMs);
            for (const t of this.zc) if ((t.skipDelay(), 'all' !== e && t.timerId === e)) break;
            return this.sa();
          });
        }
        oa(e) {
          this.Yc.push(e);
        }
        na(e) {
          const t = this.zc.indexOf(e);
          this.zc.splice(t, 1);
        }
      }
      function Dp(e) {
        return (function (e, t) {
          if ('object' != typeof e || null === e) return !1;
          const n = e;
          for (const r of t) if (r in n && 'function' == typeof n[r]) return !0;
          return !1;
        })(
          /**
           * @license
           * Copyright 2020 Google LLC
           *
           * Licensed under the Apache License, Version 2.0 (the "License");
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *   http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an "AS IS" BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */ e,
          ['next', 'error', 'complete']
        );
      }
      class Lp {
        constructor() {
          (this._progressObserver = {}),
            (this._taskCompletionResolver = new hi()),
            (this._lastProgress = { taskState: 'Running', totalBytes: 0, totalDocuments: 0, bytesLoaded: 0, documentsLoaded: 0 });
        }
        onProgress(e, t, n) {
          this._progressObserver = { next: e, error: t, complete: n };
        }
        catch(e) {
          return this._taskCompletionResolver.promise.catch(e);
        }
        then(e, t) {
          return this._taskCompletionResolver.promise.then(e, t);
        }
        _completeWith(e) {
          this._updateProgress(e), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(e);
        }
        _failWith(e) {
          (this._lastProgress.taskState = 'Error'),
            this._progressObserver.next && this._progressObserver.next(this._lastProgress),
            this._progressObserver.error && this._progressObserver.error(e),
            this._taskCompletionResolver.reject(e);
        }
        _updateProgress(e) {
          (this._lastProgress = e), this._progressObserver.next && this._progressObserver.next(e);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const jp = -1;
      class Mp extends Ep {
        constructor(e, t, n, r) {
          super(e, t, n, r),
            (this.type = 'firestore'),
            (this._queue = new Pp()),
            (this._persistenceKey = (null == r ? void 0 : r.name) || '[DEFAULT]');
        }
        _terminate() {
          return this._firestoreClient || Up(this), this._firestoreClient.terminate();
        }
      }
      function Fp(e) {
        return e._firestoreClient || Up(e), e._firestoreClient.verifyNotTerminated(), e._firestoreClient;
      }
      function Up(e) {
        var t, n, r;
        const i = e._freezeSettings(),
          o = (function (e, t, n, r) {
            return new ns(
              e,
              t,
              n,
              r.host,
              r.ssl,
              r.experimentalForceLongPolling,
              r.experimentalAutoDetectLongPolling,
              dp(r.experimentalLongPollingOptions),
              r.useFetchStreams
            );
          })(e._databaseId, (null === (t = e._app) || void 0 === t ? void 0 : t.options.appId) || '', e._persistenceKey, i);
        (e._firestoreClient = new Wd(e._authCredentials, e._appCheckCredentials, e._queue, o)),
          (null === (n = i.cache) || void 0 === n ? void 0 : n._offlineComponentProvider) &&
            (null === (r = i.cache) || void 0 === r ? void 0 : r._onlineComponentProvider) &&
            (e._firestoreClient._uninitializedComponentsProvider = {
              _offlineKind: i.cache.kind,
              _offline: i.cache._offlineComponentProvider,
              _online: i.cache._onlineComponentProvider
            });
      }
      function Vp(e, t) {
        Qp((e = bp(e, Mp)));
        const n = Fp(e);
        if (n._uninitializedComponentsProvider) throw new li(ci.FAILED_PRECONDITION, 'SDK cache is already specified.');
        ri('enableIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead.');
        const r = e._freezeSettings(),
          i = new Vd();
        return $p(n, i, new Fd(i, r.cacheSizeBytes, null == t ? void 0 : t.forceOwnership));
      }
      function Bp(e) {
        Qp((e = bp(e, Mp)));
        const t = Fp(e);
        if (t._uninitializedComponentsProvider) throw new li(ci.FAILED_PRECONDITION, 'SDK cache is already specified.');
        ri('enableMultiTabIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead.');
        const n = e._freezeSettings(),
          r = new Vd();
        return $p(t, r, new Ud(r, n.cacheSizeBytes));
      }
      function $p(e, t, n) {
        const r = new hi();
        return e.asyncQueue
          .enqueue(async () => {
            try {
              await Hd(e, n), await Kd(e, t), r.resolve();
            } catch (e) {
              const n = e;
              if (!Qd(n)) throw n;
              ri('Error enabling indexeddb cache. Falling back to memory cache: ' + n), r.reject(n);
            }
          })
          .then(() => r.promise);
      }
      function qp(e) {
        if (e._initialized && !e._terminated)
          throw new li(
            ci.FAILED_PRECONDITION,
            'Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.'
          );
        const t = new hi();
        return (
          e._queue.enqueueAndForgetEvenWhileRestricted(async () => {
            try {
              await (async function (e) {
                if (!Wi.D()) return Promise.resolve();
                const t = e + 'main';
                await Wi.delete(t);
              })(ph(e._databaseId, e._persistenceKey)),
                t.resolve();
            } catch (e) {
              t.reject(e);
            }
          }),
          t.promise
        );
      }
      function zp(e) {
        return (function (e) {
          const t = new hi();
          return e.asyncQueue.enqueueAndForget(async () => pd(await tp(e), t)), t.promise;
        })(Fp((e = bp(e, Mp))));
      }
      function Gp(e) {
        return ip(Fp((e = bp(e, Mp))));
      }
      function Wp(e) {
        return op(Fp((e = bp(e, Mp))));
      }
      function Hp(e, t) {
        const n = Fp((e = bp(e, Mp))),
          r = new Lp();
        return hp(n, e._databaseId, t, r), r;
      }
      function Kp(e, t) {
        return fp(Fp((e = bp(e, Mp))), t).then(t => (t ? new Ap(e, null, t.query) : null));
      }
      function Qp(e) {
        if (e._initialized || e._terminated)
          throw new li(
            ci.FAILED_PRECONDITION,
            'Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.'
          );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class Yp {
        constructor(e) {
          this._byteString = e;
        }
        static fromBase64String(e) {
          try {
            return new Yp(Ko.fromBase64String(e));
          } catch (e) {
            throw new li(ci.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + e);
          }
        }
        static fromUint8Array(e) {
          return new Yp(Ko.fromUint8Array(e));
        }
        toBase64() {
          return this._byteString.toBase64();
        }
        toUint8Array() {
          return this._byteString.toUint8Array();
        }
        toString() {
          return 'Bytes(base64: ' + this.toBase64() + ')';
        }
        isEqual(e) {
          return this._byteString.isEqual(e._byteString);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Xp {
        constructor(...e) {
          for (let t = 0; t < e.length; ++t)
            if (0 === e[t].length) throw new li(ci.INVALID_ARGUMENT, 'Invalid field name at argument $(i + 1). Field names must not be empty.');
          this._internalPath = new Oi(e);
        }
        isEqual(e) {
          return this._internalPath.isEqual(e._internalPath);
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class Jp {
        constructor(e) {
          this._methodName = e;
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Zp {
        constructor(e, t) {
          if (!isFinite(e) || e < -90 || e > 90) throw new li(ci.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + e);
          if (!isFinite(t) || t < -180 || t > 180)
            throw new li(ci.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + t);
          (this._lat = e), (this._long = t);
        }
        get latitude() {
          return this._lat;
        }
        get longitude() {
          return this._long;
        }
        isEqual(e) {
          return this._lat === e._lat && this._long === e._long;
        }
        toJSON() {
          return { latitude: this._lat, longitude: this._long };
        }
        _compareTo(e) {
          return Ii(this._lat, e._lat) || Ii(this._long, e._long);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const eg = /^__.*__$/;
      class tg {
        constructor(e, t, n) {
          (this.data = e), (this.fieldMask = t), (this.fieldTransforms = n);
        }
        toMutation(e, t) {
          return null !== this.fieldMask
            ? new hu(e, this.data, this.fieldMask, t, this.fieldTransforms)
            : new lu(e, this.data, t, this.fieldTransforms);
        }
      }
      class ng {
        constructor(e, t, n) {
          (this.data = e), (this.fieldMask = t), (this.fieldTransforms = n);
        }
        toMutation(e, t) {
          return new hu(e, this.data, this.fieldMask, t, this.fieldTransforms);
        }
      }
      function rg(e) {
        switch (e) {
          case 0:
          case 2:
          case 1:
            return !0;
          case 3:
          case 4:
            return !1;
          default:
            throw oi();
        }
      }
      class ig {
        constructor(e, t, n, r, i, o) {
          (this.settings = e),
            (this.databaseId = t),
            (this.serializer = n),
            (this.ignoreUndefinedProperties = r),
            void 0 === i && this.ua(),
            (this.fieldTransforms = i || []),
            (this.fieldMask = o || []);
        }
        get path() {
          return this.settings.path;
        }
        get ca() {
          return this.settings.ca;
        }
        aa(e) {
          return new ig(
            Object.assign(Object.assign({}, this.settings), e),
            this.databaseId,
            this.serializer,
            this.ignoreUndefinedProperties,
            this.fieldTransforms,
            this.fieldMask
          );
        }
        ha(e) {
          var t;
          const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e),
            r = this.aa({ path: n, la: !1 });
          return r.fa(e), r;
        }
        da(e) {
          var t;
          const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e),
            r = this.aa({ path: n, la: !1 });
          return r.ua(), r;
        }
        wa(e) {
          return this.aa({ path: void 0, la: !0 });
        }
        _a(e) {
          return Sg(e, this.settings.methodName, this.settings.ma || !1, this.path, this.settings.ga);
        }
        contains(e) {
          return void 0 !== this.fieldMask.find(t => e.isPrefixOf(t)) || void 0 !== this.fieldTransforms.find(t => e.isPrefixOf(t.field));
        }
        ua() {
          if (this.path) for (let e = 0; e < this.path.length; e++) this.fa(this.path.get(e));
        }
        fa(e) {
          if (0 === e.length) throw this._a('Document fields must not be empty');
          if (rg(this.ca) && eg.test(e)) throw this._a('Document fields cannot begin and end with "__"');
        }
      }
      class og {
        constructor(e, t, n) {
          (this.databaseId = e), (this.ignoreUndefinedProperties = t), (this.serializer = n || Zh(e));
        }
        ya(e, t, n, r = !1) {
          return new ig(
            { ca: e, methodName: t, ga: n, path: Oi.emptyPath(), la: !1, ma: r },
            this.databaseId,
            this.serializer,
            this.ignoreUndefinedProperties
          );
        }
      }
      function sg(e) {
        const t = e._freezeSettings(),
          n = Zh(e._databaseId);
        return new og(e._databaseId, !!t.ignoreUndefinedProperties, n);
      }
      function ag(e, t, n, r, i, o = {}) {
        const s = e.ya(o.merge || o.mergeFields ? 2 : 0, t, n, i);
        bg('Data must be an object, but it was:', s, r);
        const a = yg(r, s);
        let u, c;
        if (o.merge) (u = new Go(s.fieldMask)), (c = s.fieldTransforms);
        else if (o.mergeFields) {
          const e = [];
          for (const r of o.mergeFields) {
            const i = _g(t, r, n);
            if (!s.contains(i)) throw new li(ci.INVALID_ARGUMENT, `Field '${i}' is specified in your field mask but missing from your input data.`);
            Tg(e, i) || e.push(i);
          }
          (u = new Go(e)), (c = s.fieldTransforms.filter(e => u.covers(e.field)));
        } else (u = null), (c = s.fieldTransforms);
        return new tg(new Ts(a), u, c);
      }
      class ug extends Jp {
        _toFieldTransform(e) {
          if (2 !== e.ca)
            throw 1 === e.ca
              ? e._a(`${this._methodName}() can only appear at the top level of your update data`)
              : e._a(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
          return e.fieldMask.push(e.path), null;
        }
        isEqual(e) {
          return e instanceof ug;
        }
      }
      function cg(e, t, n) {
        return new ig({ ca: 3, ga: t.settings.ga, methodName: e._methodName, la: n }, t.databaseId, t.serializer, t.ignoreUndefinedProperties);
      }
      class lg extends Jp {
        _toFieldTransform(e) {
          return new Za(e.path, new Ga());
        }
        isEqual(e) {
          return e instanceof lg;
        }
      }
      class hg extends Jp {
        constructor(e, t) {
          super(e), (this.pa = t);
        }
        _toFieldTransform(e) {
          const t = cg(this, e, !0),
            n = this.pa.map(e => vg(e, t)),
            r = new Wa(n);
          return new Za(e.path, r);
        }
        isEqual(e) {
          return this === e;
        }
      }
      class fg extends Jp {
        constructor(e, t) {
          super(e), (this.pa = t);
        }
        _toFieldTransform(e) {
          const t = cg(this, e, !0),
            n = this.pa.map(e => vg(e, t)),
            r = new Ka(n);
          return new Za(e.path, r);
        }
        isEqual(e) {
          return this === e;
        }
      }
      class dg extends Jp {
        constructor(e, t) {
          super(e), (this.Ia = t);
        }
        _toFieldTransform(e) {
          const t = new Ya(e.serializer, Va(e.serializer, this.Ia));
          return new Za(e.path, t);
        }
        isEqual(e) {
          return this === e;
        }
      }
      function pg(e, t, n, r) {
        const i = e.ya(1, t, n);
        bg('Data must be an object, but it was:', i, r);
        const o = [],
          s = Ts.empty();
        Mo(r, (e, r) => {
          const a = Eg(t, e, n);
          r = (0, u.m9)(r);
          const c = i.da(a);
          if (r instanceof ug) o.push(a);
          else {
            const e = vg(r, c);
            null != e && (o.push(a), s.set(a, e));
          }
        });
        const a = new Go(o);
        return new ng(s, a, i.fieldTransforms);
      }
      function gg(e, t, n, r, i, o) {
        const s = e.ya(1, t, n),
          a = [_g(t, r, n)],
          c = [i];
        if (o.length % 2 != 0)
          throw new li(
            ci.INVALID_ARGUMENT,
            `Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`
          );
        for (let u = 0; u < o.length; u += 2) a.push(_g(t, o[u])), c.push(o[u + 1]);
        const l = [],
          h = Ts.empty();
        for (let d = a.length - 1; d >= 0; --d)
          if (!Tg(l, a[d])) {
            const e = a[d];
            let t = c[d];
            t = (0, u.m9)(t);
            const n = s.da(e);
            if (t instanceof ug) l.push(e);
            else {
              const r = vg(t, n);
              null != r && (l.push(e), h.set(e, r));
            }
          }
        const f = new Go(l);
        return new ng(h, f, s.fieldTransforms);
      }
      function mg(e, t, n, r = !1) {
        return vg(n, e.ya(r ? 4 : 3, t));
      }
      function vg(e, t) {
        if (wg((e = (0, u.m9)(e)))) return bg('Unsupported field value:', t, e), yg(e, t);
        if (e instanceof Jp)
          return (
            (function (e, t) {
              if (!rg(t.ca)) throw t._a(`${e._methodName}() can only be used with update() and set()`);
              if (!t.path) throw t._a(`${e._methodName}() is not currently supported inside arrays`);
              const n = e._toFieldTransform(t);
              n && t.fieldTransforms.push(n);
            })(e, t),
            null
          );
        if (void 0 === e && t.ignoreUndefinedProperties) return null;
        if ((t.path && t.fieldMask.push(t.path), e instanceof Array)) {
          if (t.settings.la && 4 !== t.ca) throw t._a('Nested arrays are not supported');
          return (function (e, t) {
            const n = [];
            let r = 0;
            for (const i of e) {
              let e = vg(i, t.wa(r));
              null == e && (e = { nullValue: 'NULL_VALUE' }), n.push(e), r++;
            }
            return { arrayValue: { values: n } };
          })(e, t);
        }
        return (function (e, t) {
          if (null === (e = (0, u.m9)(e))) return { nullValue: 'NULL_VALUE' };
          if ('number' == typeof e) return Va(t.serializer, e);
          if ('boolean' == typeof e) return { booleanValue: e };
          if ('string' == typeof e) return { stringValue: e };
          if (e instanceof Date) {
            const n = Ti.fromDate(e);
            return { timestampValue: Hu(t.serializer, n) };
          }
          if (e instanceof Ti) {
            const n = new Ti(e.seconds, 1e3 * Math.floor(e.nanoseconds / 1e3));
            return { timestampValue: Hu(t.serializer, n) };
          }
          if (e instanceof Zp) return { geoPointValue: { latitude: e.latitude, longitude: e.longitude } };
          if (e instanceof Yp) return { bytesValue: Ku(t.serializer, e._byteString) };
          if (e instanceof Tp) {
            const n = t.databaseId,
              r = e.firestore._databaseId;
            if (!r.isEqual(n))
              throw t._a(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);
            return { referenceValue: Xu(e.firestore._databaseId || t.databaseId, e._key.path) };
          }
          throw t._a(`Unsupported field value: ${wp(e)}`);
        })(e, t);
      }
      function yg(e, t) {
        const n = {};
        return (
          Fo(e)
            ? t.path && t.path.length > 0 && t.fieldMask.push(t.path)
            : Mo(e, (e, r) => {
                const i = vg(r, t.ha(e));
                null != i && (n[e] = i);
              }),
          { mapValue: { fields: n } }
        );
      }
      function wg(e) {
        return !(
          'object' != typeof e ||
          null === e ||
          e instanceof Array ||
          e instanceof Date ||
          e instanceof Ti ||
          e instanceof Zp ||
          e instanceof Yp ||
          e instanceof Tp ||
          e instanceof Jp
        );
      }
      function bg(e, t, n) {
        if (
          !wg(n) ||
          !(function (e) {
            return 'object' == typeof e && null !== e && (Object.getPrototypeOf(e) === Object.prototype || null === Object.getPrototypeOf(e));
          })(n)
        ) {
          const r = wp(n);
          throw 'an object' === r ? t._a(e + ' a custom object') : t._a(e + ' ' + r);
        }
      }
      function _g(e, t, n) {
        if ((t = (0, u.m9)(t)) instanceof Xp) return t._internalPath;
        if ('string' == typeof t) return Eg(e, t);
        throw Sg('Field path arguments must be of type string or ', e, !1, void 0, n);
      }
      const Ig = new RegExp('[~\\*/\\[\\]]');
      function Eg(e, t, n) {
        if (t.search(Ig) >= 0) throw Sg(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, n);
        try {
          return new Xp(...t.split('.'))._internalPath;
        } catch (r) {
          throw Sg(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, n);
        }
      }
      function Sg(e, t, n, r, i) {
        const o = r && !r.isEmpty(),
          s = void 0 !== i;
        let a = `Function ${t}() called with invalid data`;
        n && (a += ' (via `toFirestore()`)'), (a += '. ');
        let u = '';
        return (
          (o || s) && ((u += ' (found'), o && (u += ` in field ${r}`), s && (u += ` in document ${i}`), (u += ')')),
          new li(ci.INVALID_ARGUMENT, a + e + u)
        );
      }
      function Tg(e, t) {
        return e.some(e => e.isEqual(t));
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Ag {
        constructor(e, t, n, r, i) {
          (this._firestore = e), (this._userDataWriter = t), (this._key = n), (this._document = r), (this._converter = i);
        }
        get id() {
          return this._key.path.lastSegment();
        }
        get ref() {
          return new Tp(this._firestore, this._converter, this._key);
        }
        exists() {
          return null !== this._document;
        }
        data() {
          if (this._document) {
            if (this._converter) {
              const e = new xg(this._firestore, this._userDataWriter, this._key, this._document, null);
              return this._converter.fromFirestore(e);
            }
            return this._userDataWriter.convertValue(this._document.data.value);
          }
        }
        get(e) {
          if (this._document) {
            const t = this._document.data.field(Cg('DocumentSnapshot.get', e));
            if (null !== t) return this._userDataWriter.convertValue(t);
          }
        }
      }
      class xg extends Ag {
        data() {
          return super.data();
        }
      }
      function Cg(e, t) {
        return 'string' == typeof t ? Eg(e, t) : t instanceof Xp ? t._internalPath : t._delegate._internalPath;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function kg(e) {
        if ('L' === e.limitType && 0 === e.explicitOrderBy.length)
          throw new li(ci.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');
      }
      class Og {}
      class Ng extends Og {}
      function Rg(e, t, ...n) {
        let r = [];
        t instanceof Og && r.push(t),
          (r = r.concat(n)),
          (function (e) {
            const t = e.filter(e => e instanceof Lg).length,
              n = e.filter(e => e instanceof Pg).length;
            if (t > 1 || (t > 0 && n > 0))
              throw new li(
                ci.INVALID_ARGUMENT,
                'InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.'
              );
          })(
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ r
          );
        for (const i of r) e = i._apply(e);
        return e;
      }
      class Pg extends Ng {
        constructor(e, t, n) {
          super(), (this._field = e), (this._op = t), (this._value = n), (this.type = 'where');
        }
        static _create(e, t, n) {
          return new Pg(e, t, n);
        }
        _apply(e) {
          const t = this._parse(e);
          return Yg(e._query, t), new Ap(e.firestore, e.converter, ga(e._query, t));
        }
        _parse(e) {
          const t = sg(e.firestore),
            n = (function (e, t, n, r, i, o, s) {
              let a;
              if (i.isKeyField()) {
                if ('array-contains' === o || 'array-contains-any' === o)
                  throw new li(ci.INVALID_ARGUMENT, `Invalid Query. You can't perform '${o}' queries on documentId().`);
                if ('in' === o || 'not-in' === o) {
                  Qg(s, o);
                  const t = [];
                  for (const n of s) t.push(Kg(r, e, n));
                  a = { arrayValue: { values: t } };
                } else a = Kg(r, e, s);
              } else ('in' !== o && 'not-in' !== o && 'array-contains-any' !== o) || Qg(s, o), (a = mg(n, t, s, 'in' === o || 'not-in' === o));
              return Ds.create(i, o, a);
            })(e._query, 'where', t, e.firestore._databaseId, this._field, this._op, this._value);
          return n;
        }
      }
      function Dg(e, t, n) {
        const r = t,
          i = Cg('where', e);
        return Pg._create(i, r, n);
      }
      class Lg extends Og {
        constructor(e, t) {
          super(), (this.type = e), (this._queryConstraints = t);
        }
        static _create(e, t) {
          return new Lg(e, t);
        }
        _parse(e) {
          const t = this._queryConstraints.map(t => t._parse(e)).filter(e => e.getFilters().length > 0);
          return 1 === t.length ? t[0] : Ls.create(t, this._getOperator());
        }
        _apply(e) {
          const t = this._parse(e);
          return 0 === t.getFilters().length
            ? e
            : ((function (e, t) {
                let n = e;
                const r = t.getFlattenedFilters();
                for (const i of r) Yg(n, i), (n = ga(n, i));
              })(e._query, t),
              new Ap(e.firestore, e.converter, ga(e._query, t)));
        }
        _getQueryConstraints() {
          return this._queryConstraints;
        }
        _getOperator() {
          return 'and' === this.type ? 'and' : 'or';
        }
      }
      class jg extends Ng {
        constructor(e, t) {
          super(), (this._field = e), (this._direction = t), (this.type = 'orderBy');
        }
        static _create(e, t) {
          return new jg(e, t);
        }
        _apply(e) {
          const t = (function (e, t, n) {
            if (null !== e.startAt)
              throw new li(ci.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before calling orderBy().');
            if (null !== e.endAt)
              throw new li(ci.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before calling orderBy().');
            const r = new Ns(t, n);
            return (
              (function (e, t) {
                if (null === la(e)) {
                  const n = ha(e);
                  null !== n && Xg(e, n, t.field);
                }
              })(e, r),
              r
            );
          })(e._query, this._field, this._direction);
          return new Ap(
            e.firestore,
            e.converter,
            (function (e, t) {
              const n = e.explicitOrderBy.concat([t]);
              return new sa(e.path, e.collectionGroup, n, e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt);
            })(e._query, t)
          );
        }
      }
      function Mg(e, t = 'asc') {
        const n = t,
          r = Cg('orderBy', e);
        return jg._create(r, n);
      }
      class Fg extends Ng {
        constructor(e, t, n) {
          super(), (this.type = e), (this._limit = t), (this._limitType = n);
        }
        static _create(e, t, n) {
          return new Fg(e, t, n);
        }
        _apply(e) {
          return new Ap(e.firestore, e.converter, ma(e._query, this._limit, this._limitType));
        }
      }
      function Ug(e) {
        return _p('limit', e), Fg._create('limit', e, 'F');
      }
      function Vg(e) {
        return _p('limitToLast', e), Fg._create('limitToLast', e, 'L');
      }
      class Bg extends Ng {
        constructor(e, t, n) {
          super(), (this.type = e), (this._docOrFields = t), (this._inclusive = n);
        }
        static _create(e, t, n) {
          return new Bg(e, t, n);
        }
        _apply(e) {
          const t = Hg(e, this.type, this._docOrFields, this._inclusive);
          return new Ap(
            e.firestore,
            e.converter,
            (function (e, t) {
              return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, t, e.endAt);
            })(e._query, t)
          );
        }
      }
      function $g(...e) {
        return Bg._create('startAt', e, !0);
      }
      function qg(...e) {
        return Bg._create('startAfter', e, !1);
      }
      class zg extends Ng {
        constructor(e, t, n) {
          super(), (this.type = e), (this._docOrFields = t), (this._inclusive = n);
        }
        static _create(e, t, n) {
          return new zg(e, t, n);
        }
        _apply(e) {
          const t = Hg(e, this.type, this._docOrFields, this._inclusive);
          return new Ap(
            e.firestore,
            e.converter,
            (function (e, t) {
              return new sa(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, t);
            })(e._query, t)
          );
        }
      }
      function Gg(...e) {
        return zg._create('endBefore', e, !1);
      }
      function Wg(...e) {
        return zg._create('endAt', e, !0);
      }
      function Hg(e, t, n, r) {
        if (((n[0] = (0, u.m9)(n[0])), n[0] instanceof Ag))
          return (function (e, t, n, r, i) {
            if (!r) throw new li(ci.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n}().`);
            const o = [];
            for (const s of da(e))
              if (s.field.isKeyField()) o.push(ds(t, r.key));
              else {
                const e = r.data.field(s.field);
                if (Zo(e))
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    'Invalid query. You are trying to start or end a query using a document for which the field "' +
                      s.field +
                      '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)'
                  );
                if (null === e) {
                  const e = s.field.canonicalString();
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    `Invalid query. You are trying to start or end a query using a document for which the field '${e}' (used as the orderBy) does not exist.`
                  );
                }
                o.push(e);
              }
            return new Cs(o, i);
          })(e._query, e.firestore._databaseId, t, n[0]._document, r);
        {
          const i = sg(e.firestore);
          return (function (e, t, n, r, i, o) {
            const s = e.explicitOrderBy;
            if (i.length > s.length)
              throw new li(
                ci.INVALID_ARGUMENT,
                `Too many arguments provided to ${r}(). The number of arguments must be less than or equal to the number of orderBy() clauses`
              );
            const a = [];
            for (let u = 0; u < i.length; u++) {
              const o = i[u];
              if (s[u].field.isKeyField()) {
                if ('string' != typeof o)
                  throw new li(ci.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${r}(), but got a ${typeof o}`);
                if (!fa(e) && -1 !== o.indexOf('/'))
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${r}() must be a plain document ID, but '${o}' contains a slash.`
                  );
                const n = e.path.child(Ci.fromString(o));
                if (!Ni.isDocumentKey(n))
                  throw new li(
                    ci.INVALID_ARGUMENT,
                    `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${r}() must result in a valid document path, but '${n}' is not because it contains an odd number of segments.`
                  );
                const i = new Ni(n);
                a.push(ds(t, i));
              } else {
                const e = mg(n, r, o);
                a.push(e);
              }
            }
            return new Cs(a, o);
          })(e._query, e.firestore._databaseId, i, t, n, r);
        }
      }
      function Kg(e, t, n) {
        if ('string' == typeof (n = (0, u.m9)(n))) {
          if ('' === n)
            throw new li(
              ci.INVALID_ARGUMENT,
              'Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.'
            );
          if (!fa(t) && -1 !== n.indexOf('/'))
            throw new li(
              ci.INVALID_ARGUMENT,
              `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`
            );
          const r = t.path.child(Ci.fromString(n));
          if (!Ni.isDocumentKey(r))
            throw new li(
              ci.INVALID_ARGUMENT,
              `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`
            );
          return ds(e, new Ni(r));
        }
        if (n instanceof Tp) return ds(e, n._key);
        throw new li(
          ci.INVALID_ARGUMENT,
          `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${wp(n)}.`
        );
      }
      function Qg(e, t) {
        if (!Array.isArray(e) || 0 === e.length)
          throw new li(ci.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${t.toString()}' filters.`);
      }
      function Yg(e, t) {
        if (t.isInequality()) {
          const n = ha(e),
            r = t.field;
          if (null !== n && !n.isEqual(r))
            throw new li(
              ci.INVALID_ARGUMENT,
              `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n.toString()}' and '${r.toString()}'`
            );
          const i = la(e);
          null !== i && Xg(e, r, i);
        }
        const n = (function (e, t) {
          for (const n of e) for (const e of n.getFlattenedFilters()) if (t.indexOf(e.op) >= 0) return e.op;
          return null;
        })(
          e.filters,
          (function (e) {
            switch (e) {
              case '!=':
                return ['!=', 'not-in'];
              case 'array-contains-any':
              case 'in':
                return ['not-in'];
              case 'not-in':
                return ['array-contains-any', 'in', 'not-in', '!='];
              default:
                return [];
            }
          })(t.op)
        );
        if (null !== n)
          throw n === t.op
            ? new li(ci.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${t.op.toString()}' filter.`)
            : new li(ci.INVALID_ARGUMENT, `Invalid query. You cannot use '${t.op.toString()}' filters with '${n.toString()}' filters.`);
      }
      function Xg(e, t, n) {
        if (!n.isEqual(t))
          throw new li(
            ci.INVALID_ARGUMENT,
            `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${t.toString()}' and so you must also use '${t.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`
          );
      }
      class Jg {
        convertValue(e, t = 'none') {
          switch (ss(e)) {
            case 0:
              return null;
            case 1:
              return e.booleanValue;
            case 2:
              return Xo(e.integerValue || e.doubleValue);
            case 3:
              return this.convertTimestamp(e.timestampValue);
            case 4:
              return this.convertServerTimestamp(e, t);
            case 5:
              return e.stringValue;
            case 6:
              return this.convertBytes(Jo(e.bytesValue));
            case 7:
              return this.convertReference(e.referenceValue);
            case 8:
              return this.convertGeoPoint(e.geoPointValue);
            case 9:
              return this.convertArray(e.arrayValue, t);
            case 10:
              return this.convertObject(e.mapValue, t);
            default:
              throw oi();
          }
        }
        convertObject(e, t) {
          return this.convertObjectMap(e.fields, t);
        }
        convertObjectMap(e, t = 'none') {
          const n = {};
          return (
            Mo(e, (e, r) => {
              n[e] = this.convertValue(r, t);
            }),
            n
          );
        }
        convertGeoPoint(e) {
          return new Zp(Xo(e.latitude), Xo(e.longitude));
        }
        convertArray(e, t) {
          return (e.values || []).map(e => this.convertValue(e, t));
        }
        convertServerTimestamp(e, t) {
          switch (t) {
            case 'previous':
              const n = es(e);
              return null == n ? null : this.convertValue(n, t);
            case 'estimate':
              return this.convertTimestamp(ts(e));
            default:
              return null;
          }
        }
        convertTimestamp(e) {
          const t = Yo(e);
          return new Ti(t.seconds, t.nanos);
        }
        convertDocumentKey(e, t) {
          const n = Ci.fromString(e);
          si(Sc(n));
          const r = new rs(n.get(1), n.get(3)),
            i = new Ni(n.popFirst(5));
          return (
            r.isEqual(t) ||
              ni(
                `Document ${i} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`
              ),
            i
          );
        }
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Zg(e, t, n) {
        let r;
        return (r = e ? (n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t)) : t), r;
      }
      class em extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Yp(e);
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return new Tp(this.firestore, null, t);
        }
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      class tm {
        constructor(e, t) {
          (this.hasPendingWrites = e), (this.fromCache = t);
        }
        isEqual(e) {
          return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache;
        }
      }
      class nm extends Ag {
        constructor(e, t, n, r, i, o) {
          super(e, t, n, r, o), (this._firestore = e), (this._firestoreImpl = e), (this.metadata = i);
        }
        exists() {
          return super.exists();
        }
        data(e = {}) {
          if (this._document) {
            if (this._converter) {
              const t = new rm(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
              return this._converter.fromFirestore(t, e);
            }
            return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps);
          }
        }
        get(e, t = {}) {
          if (this._document) {
            const n = this._document.data.field(Cg('DocumentSnapshot.get', e));
            if (null !== n) return this._userDataWriter.convertValue(n, t.serverTimestamps);
          }
        }
      }
      class rm extends nm {
        data(e = {}) {
          return super.data(e);
        }
      }
      class im {
        constructor(e, t, n, r) {
          (this._firestore = e),
            (this._userDataWriter = t),
            (this._snapshot = r),
            (this.metadata = new tm(r.hasPendingWrites, r.fromCache)),
            (this.query = n);
        }
        get docs() {
          const e = [];
          return this.forEach(t => e.push(t)), e;
        }
        get size() {
          return this._snapshot.docs.size;
        }
        get empty() {
          return 0 === this.size;
        }
        forEach(e, t) {
          this._snapshot.docs.forEach(n => {
            e.call(
              t,
              new rm(
                this._firestore,
                this._userDataWriter,
                n.key,
                n,
                new tm(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache),
                this.query.converter
              )
            );
          });
        }
        docChanges(e = {}) {
          const t = !!e.includeMetadataChanges;
          if (t && this._snapshot.excludesMetadataChanges)
            throw new li(
              ci.INVALID_ARGUMENT,
              'To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().'
            );
          return (
            (this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t) ||
              ((this._cachedChanges = (function (e, t) {
                if (e._snapshot.oldDocs.isEmpty()) {
                  let t = 0;
                  return e._snapshot.docChanges.map(n => {
                    const r = new rm(
                      e._firestore,
                      e._userDataWriter,
                      n.doc.key,
                      n.doc,
                      new tm(e._snapshot.mutatedKeys.has(n.doc.key), e._snapshot.fromCache),
                      e.query.converter
                    );
                    return n.doc, { type: 'added', doc: r, oldIndex: -1, newIndex: t++ };
                  });
                }
                {
                  let n = e._snapshot.oldDocs;
                  return e._snapshot.docChanges
                    .filter(e => t || 3 !== e.type)
                    .map(t => {
                      const r = new rm(
                        e._firestore,
                        e._userDataWriter,
                        t.doc.key,
                        t.doc,
                        new tm(e._snapshot.mutatedKeys.has(t.doc.key), e._snapshot.fromCache),
                        e.query.converter
                      );
                      let i = -1,
                        o = -1;
                      return (
                        0 !== t.type && ((i = n.indexOf(t.doc.key)), (n = n.delete(t.doc.key))),
                        1 !== t.type && ((n = n.add(t.doc)), (o = n.indexOf(t.doc.key))),
                        { type: om(t.type), doc: r, oldIndex: i, newIndex: o }
                      );
                    });
                }
              })(this, t)),
              (this._cachedChangesIncludeMetadataChanges = t)),
            this._cachedChanges
          );
        }
      }
      function om(e) {
        switch (e) {
          case 0:
            return 'added';
          case 2:
          case 3:
            return 'modified';
          case 1:
            return 'removed';
          default:
            return oi();
        }
      }
      function sm(e, t) {
        return e instanceof nm && t instanceof nm
          ? e._firestore === t._firestore &&
              e._key.isEqual(t._key) &&
              (null === e._document ? null === t._document : e._document.isEqual(t._document)) &&
              e._converter === t._converter
          : e instanceof im &&
              t instanceof im &&
              e._firestore === t._firestore &&
              Rp(e.query, t.query) &&
              e.metadata.isEqual(t.metadata) &&
              e._snapshot.isEqual(t._snapshot);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function am(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp);
        return ap(Fp(t), e._key).then(n => _m(t, e, n));
      }
      class um extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Yp(e);
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return new Tp(this.firestore, null, t);
        }
      }
      function cm(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return sp(n, e._key).then(n => new nm(t, r, e._key, n, new tm(null !== n && n.hasLocalMutations, !0), e.converter));
      }
      function lm(e) {
        e = bp(e, Tp);
        const t = bp(e.firestore, Mp);
        return ap(Fp(t), e._key, { source: 'server' }).then(n => _m(t, e, n));
      }
      function hm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return kg(e._query), cp(n, e._query).then(n => new im(t, r, e, n));
      }
      function fm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return up(n, e._query).then(n => new im(t, r, e, n));
      }
      function dm(e) {
        e = bp(e, Ap);
        const t = bp(e.firestore, Mp),
          n = Fp(t),
          r = new um(t);
        return cp(n, e._query, { source: 'server' }).then(n => new im(t, r, e, n));
      }
      function pm(e, t, n) {
        e = bp(e, Tp);
        const r = bp(e.firestore, Mp),
          i = Zg(e.converter, t, n);
        return bm(r, [ag(sg(r), 'setDoc', e._key, i, null !== e.converter, n).toMutation(e._key, nu.none())]);
      }
      function gm(e, t, n, ...r) {
        e = bp(e, Tp);
        const i = bp(e.firestore, Mp),
          o = sg(i);
        let s;
        return (
          (s = 'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp ? gg(o, 'updateDoc', e._key, t, n, r) : pg(o, 'updateDoc', e._key, t)),
          bm(i, [s.toMutation(e._key, nu.exists(!0))])
        );
      }
      function mm(e) {
        return bm(bp(e.firestore, Mp), [new gu(e._key, nu.none())]);
      }
      function vm(e, t) {
        const n = bp(e.firestore, Mp),
          r = Op(e),
          i = Zg(e.converter, t);
        return bm(n, [ag(sg(e.firestore), 'addDoc', r._key, i, null !== e.converter, {}).toMutation(r._key, nu.exists(!1))]).then(() => r);
      }
      function ym(e, ...t) {
        var n, r, i;
        e = (0, u.m9)(e);
        let o = { includeMetadataChanges: !1 },
          s = 0;
        'object' != typeof t[s] || Dp(t[s]) || ((o = t[s]), s++);
        const a = { includeMetadataChanges: o.includeMetadataChanges };
        if (Dp(t[s])) {
          const e = t[s];
          (t[s] = null === (n = e.next) || void 0 === n ? void 0 : n.bind(e)),
            (t[s + 1] = null === (r = e.error) || void 0 === r ? void 0 : r.bind(e)),
            (t[s + 2] = null === (i = e.complete) || void 0 === i ? void 0 : i.bind(e));
        }
        let c, l, h;
        if (e instanceof Tp)
          (l = bp(e.firestore, Mp)),
            (h = ua(e._key.path)),
            (c = {
              next: n => {
                t[s] && t[s](_m(l, e, n));
              },
              error: t[s + 1],
              complete: t[s + 2]
            });
        else {
          const n = bp(e, Ap);
          (l = bp(n.firestore, Mp)), (h = n._query);
          const r = new um(l);
          (c = {
            next: e => {
              t[s] && t[s](new im(l, r, n, e));
            },
            error: t[s + 1],
            complete: t[s + 2]
          }),
            kg(e._query);
        }
        return (function (e, t, n, r) {
          const i = new $d(r),
            o = new Kf(t, i, n);
          return (
            e.asyncQueue.enqueueAndForget(async () => qf(await rp(e), o)),
            () => {
              i.Dc(), e.asyncQueue.enqueueAndForget(async () => zf(await rp(e), o));
            }
          );
        })(Fp(l), h, a, c);
      }
      function wm(e, t) {
        return lp(Fp((e = bp(e, Mp))), Dp(t) ? t : { next: t });
      }
      function bm(e, t) {
        return (function (e, t) {
          const n = new hi();
          return e.asyncQueue.enqueueAndForget(async () => ud(await tp(e), t, n)), n.promise;
        })(Fp(e), t);
      }
      function _m(e, t, n) {
        const r = n.docs.get(t._key),
          i = new um(e);
        return new nm(e, i, t._key, r, new tm(n.hasPendingWrites, n.fromCache), t.converter);
      }
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2022 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      const Im = { maxAttempts: 5 };
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Em {
        constructor(e, t) {
          (this._firestore = e), (this._commitHandler = t), (this._mutations = []), (this._committed = !1), (this._dataReader = sg(e));
        }
        set(e, t, n) {
          this._verifyNotCommitted();
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'WriteBatch.set', r._key, i, null !== r.converter, n);
          return this._mutations.push(o.toMutation(r._key, nu.none())), this;
        }
        update(e, t, n, ...r) {
          this._verifyNotCommitted();
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'WriteBatch.update', i._key, t, n, r)
                : pg(this._dataReader, 'WriteBatch.update', i._key, t)),
            this._mutations.push(o.toMutation(i._key, nu.exists(!0))),
            this
          );
        }
        delete(e) {
          this._verifyNotCommitted();
          const t = Sm(e, this._firestore);
          return (this._mutations = this._mutations.concat(new gu(t._key, nu.none()))), this;
        }
        commit() {
          return (
            this._verifyNotCommitted(), (this._committed = !0), this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
          );
        }
        _verifyNotCommitted() {
          if (this._committed) throw new li(ci.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() has been called.');
        }
      }
      function Sm(e, t) {
        if ((e = (0, u.m9)(e)).firestore !== t)
          throw new li(ci.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');
        return e;
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Tm extends class {
        constructor(e, t) {
          (this._firestore = e), (this._transaction = t), (this._dataReader = sg(e));
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new em(this._firestore);
          return this._transaction.lookup([t._key]).then(e => {
            if (!e || 1 !== e.length) return oi();
            const r = e[0];
            if (r.isFoundDocument()) return new Ag(this._firestore, n, r.key, r, t.converter);
            if (r.isNoDocument()) return new Ag(this._firestore, n, t._key, null, t.converter);
            throw oi();
          });
        }
        set(e, t, n) {
          const r = Sm(e, this._firestore),
            i = Zg(r.converter, t, n),
            o = ag(this._dataReader, 'Transaction.set', r._key, i, null !== r.converter, n);
          return this._transaction.set(r._key, o), this;
        }
        update(e, t, n, ...r) {
          const i = Sm(e, this._firestore);
          let o;
          return (
            (o =
              'string' == typeof (t = (0, u.m9)(t)) || t instanceof Xp
                ? gg(this._dataReader, 'Transaction.update', i._key, t, n, r)
                : pg(this._dataReader, 'Transaction.update', i._key, t)),
            this._transaction.update(i._key, o),
            this
          );
        }
        delete(e) {
          const t = Sm(e, this._firestore);
          return this._transaction.delete(t._key), this;
        }
      } {
        constructor(e, t) {
          super(e, t), (this._firestore = e);
        }
        get(e) {
          const t = Sm(e, this._firestore),
            n = new um(this._firestore);
          return super.get(e).then(e => new nm(this._firestore, n, t._key, e._document, new tm(!1, !1), t.converter));
        }
      }
      function Am(e, t, n) {
        e = bp(e, Mp);
        const r = Object.assign(Object.assign({}, Im), n);
        return (
          (function (e) {
            if (e.maxAttempts < 1) throw new li(ci.INVALID_ARGUMENT, 'Max attempts must be at least 1');
          })(r),
          (function (e, t, n) {
            const r = new hi();
            return (
              e.asyncQueue.enqueueAndForget(async () => {
                const i = await np(e);
                new Gd(e.asyncQueue, i, n, t, r).run();
              }),
              r.promise
            );
          })(Fp(e), n => t(new Tm(e, n)), r)
        );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function xm() {
        return new ug('deleteField');
      }
      function Cm() {
        return new lg('serverTimestamp');
      }
      function km(...e) {
        return new hg('arrayUnion', e);
      }
      function Om(...e) {
        return new fg('arrayRemove', e);
      }
      function Nm(e) {
        return new dg('increment', e);
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ !(function (e, t = !0) {
        !(function (e) {
          Xr = e;
        })(o.SDK_VERSION),
          (0, o._registerComponent)(
            new s.wA(
              'firestore',
              (e, { instanceIdentifier: n, options: r }) => {
                const i = e.getProvider('app').getImmediate(),
                  o = new Mp(
                    new gi(e.getProvider('auth-internal')),
                    new wi(e.getProvider('app-check-internal')),
                    (function (e, t) {
                      if (!Object.prototype.hasOwnProperty.apply(e.options, ['projectId']))
                        throw new li(ci.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
                      return new rs(e.options.projectId, t);
                    })(i, n),
                    i
                  );
                return (r = Object.assign({ useFetchStreams: t }, r)), o._setSettings(r), o;
              },
              'PUBLIC'
            ).setMultipleInstances(!0)
          ),
          (0, o.registerVersion)(Qr, '3.13.0', e),
          (0, o.registerVersion)(Qr, '3.13.0', 'esm2017');
      })();
      const Rm = '@firebase/firestore-compat',
        Pm = '0.3.12';
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */
      function Dm(e, t) {
        if (void 0 === t) return { merge: !1 };
        if (void 0 !== t.mergeFields && void 0 !== t.merge)
          throw new li('invalid-argument', `Invalid options passed to function ${e}(): You cannot specify both "merge" and "mergeFields".`);
        return t;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Lm() {
        if ('undefined' === typeof Uint8Array) throw new li('unimplemented', 'Uint8Arrays are not available in this environment.');
      }
      function jm() {
        if (!Ho()) throw new li('unimplemented', 'Blobs are unavailable in Firestore in this environment.');
      }
      class Mm {
        constructor(e) {
          this._delegate = e;
        }
        static fromBase64String(e) {
          return jm(), new Mm(Yp.fromBase64String(e));
        }
        static fromUint8Array(e) {
          return Lm(), new Mm(Yp.fromUint8Array(e));
        }
        toBase64() {
          return jm(), this._delegate.toBase64();
        }
        toUint8Array() {
          return Lm(), this._delegate.toUint8Array();
        }
        isEqual(e) {
          return this._delegate.isEqual(e._delegate);
        }
        toString() {
          return 'Blob(base64: ' + this.toBase64() + ')';
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function Fm(e) {
        return Um(e, ['next', 'error', 'complete']);
      }
      function Um(e, t) {
        if ('object' !== typeof e || null === e) return !1;
        const n = e;
        for (const r of t) if (r in n && 'function' === typeof n[r]) return !0;
        return !1;
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class Vm {
        enableIndexedDbPersistence(e, t) {
          return Vp(e._delegate, { forceOwnership: t });
        }
        enableMultiTabIndexedDbPersistence(e) {
          return Bp(e._delegate);
        }
        clearIndexedDbPersistence(e) {
          return qp(e._delegate);
        }
      }
      class Bm {
        constructor(e, t, n) {
          (this._delegate = t),
            (this._persistenceProvider = n),
            (this.INTERNAL = { delete: () => this.terminate() }),
            e instanceof rs || (this._appCompat = e);
        }
        get _databaseId() {
          return this._delegate._databaseId;
        }
        settings(e) {
          const t = this._delegate._getSettings();
          e.merge ||
            t.host === e.host ||
            ri('You are overriding the original host. If you did not intend to override your settings, use {merge: true}.'),
            e.merge && ((e = Object.assign(Object.assign({}, t), e)), delete e.merge),
            this._delegate._setSettings(e);
        }
        useEmulator(e, t, n = {}) {
          Sp(this._delegate, e, t, n);
        }
        enableNetwork() {
          return Gp(this._delegate);
        }
        disableNetwork() {
          return Wp(this._delegate);
        }
        enablePersistence(e) {
          let t = !1,
            n = !1;
          return (
            e && ((t = !!e.synchronizeTabs), (n = !!e.experimentalForceOwningTab), mp('synchronizeTabs', t, 'experimentalForceOwningTab', n)),
            t ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, n)
          );
        }
        clearPersistence() {
          return this._persistenceProvider.clearIndexedDbPersistence(this);
        }
        terminate() {
          return (
            this._appCompat && (this._appCompat._removeServiceInstance('firestore-compat'), this._appCompat._removeServiceInstance('firestore')),
            this._delegate._delete()
          );
        }
        waitForPendingWrites() {
          return zp(this._delegate);
        }
        onSnapshotsInSync(e) {
          return wm(this._delegate, e);
        }
        get app() {
          if (!this._appCompat) throw new li('failed-precondition', "Firestore was not initialized using the Firebase SDK. 'app' is not available");
          return this._appCompat;
        }
        collection(e) {
          try {
            return new nv(this, Cp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collection()', 'Firestore.collection()');
          }
        }
        doc(e) {
          try {
            return new Hm(this, Op(this._delegate, e));
          } catch (t) {
            throw Km(t, 'doc()', 'Firestore.doc()');
          }
        }
        collectionGroup(e) {
          try {
            return new Zm(this, kp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collectionGroup()', 'Firestore.collectionGroup()');
          }
        }
        runTransaction(e) {
          return Am(this._delegate, t => e(new zm(this, t)));
        }
        batch() {
          return Fp(this._delegate), new Gm(new Em(this._delegate, e => bm(this._delegate, e)));
        }
        loadBundle(e) {
          return Hp(this._delegate, e);
        }
        namedQuery(e) {
          return Kp(this._delegate, e).then(e => (e ? new Zm(this, e) : null));
        }
      }
      class $m extends Jg {
        constructor(e) {
          super(), (this.firestore = e);
        }
        convertBytes(e) {
          return new Mm(new Yp(e));
        }
        convertReference(e) {
          const t = this.convertDocumentKey(e, this.firestore._databaseId);
          return Hm.forKey(t, this.firestore, null);
        }
      }
      function qm(e) {
        ei(e);
      }
      class zm {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t), (this._userDataWriter = new $m(e));
        }
        get(e) {
          const t = rv(e);
          return this._delegate
            .get(t)
            .then(
              e => new Xm(this._firestore, new nm(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, t.converter))
            );
        }
        set(e, t, n) {
          const r = rv(e);
          return n ? (Dm('Transaction.set', n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this;
        }
        update(e, t, n, ...r) {
          const i = rv(e);
          return 2 === arguments.length ? this._delegate.update(i, t) : this._delegate.update(i, t, n, ...r), this;
        }
        delete(e) {
          const t = rv(e);
          return this._delegate.delete(t), this;
        }
      }
      class Gm {
        constructor(e) {
          this._delegate = e;
        }
        set(e, t, n) {
          const r = rv(e);
          return n ? (Dm('WriteBatch.set', n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this;
        }
        update(e, t, n, ...r) {
          const i = rv(e);
          return 2 === arguments.length ? this._delegate.update(i, t) : this._delegate.update(i, t, n, ...r), this;
        }
        delete(e) {
          const t = rv(e);
          return this._delegate.delete(t), this;
        }
        commit() {
          return this._delegate.commit();
        }
      }
      class Wm {
        constructor(e, t, n) {
          (this._firestore = e), (this._userDataWriter = t), (this._delegate = n);
        }
        fromFirestore(e, t) {
          const n = new rm(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, null);
          return this._delegate.fromFirestore(new Jm(this._firestore, n), null !== t && void 0 !== t ? t : {});
        }
        toFirestore(e, t) {
          return t ? this._delegate.toFirestore(e, t) : this._delegate.toFirestore(e);
        }
        static getInstance(e, t) {
          const n = Wm.INSTANCES;
          let r = n.get(e);
          r || ((r = new WeakMap()), n.set(e, r));
          let i = r.get(t);
          return i || ((i = new Wm(e, new $m(e), t)), r.set(t, i)), i;
        }
      }
      Wm.INSTANCES = new WeakMap();
      class Hm {
        constructor(e, t) {
          (this.firestore = e), (this._delegate = t), (this._userDataWriter = new $m(e));
        }
        static forPath(e, t, n) {
          if (e.length % 2 !== 0)
            throw new li(
              'invalid-argument',
              `Invalid document reference. Document references must have an even number of segments, but ${e.canonicalString()} has ${e.length}`
            );
          return new Hm(t, new Tp(t._delegate, n, new Ni(e)));
        }
        static forKey(e, t, n) {
          return new Hm(t, new Tp(t._delegate, n, e));
        }
        get id() {
          return this._delegate.id;
        }
        get parent() {
          return new nv(this.firestore, this._delegate.parent);
        }
        get path() {
          return this._delegate.path;
        }
        collection(e) {
          try {
            return new nv(this.firestore, Cp(this._delegate, e));
          } catch (t) {
            throw Km(t, 'collection()', 'DocumentReference.collection()');
          }
        }
        isEqual(e) {
          return (e = (0, u.m9)(e)), e instanceof Tp && Np(this._delegate, e);
        }
        set(e, t) {
          t = Dm('DocumentReference.set', t);
          try {
            return t ? pm(this._delegate, e, t) : pm(this._delegate, e);
          } catch (n) {
            throw Km(n, 'setDoc()', 'DocumentReference.set()');
          }
        }
        update(e, t, ...n) {
          try {
            return 1 === arguments.length ? gm(this._delegate, e) : gm(this._delegate, e, t, ...n);
          } catch (r) {
            throw Km(r, 'updateDoc()', 'DocumentReference.update()');
          }
        }
        delete() {
          return mm(this._delegate);
        }
        onSnapshot(...e) {
          const t = Qm(e),
            n = Ym(
              e,
              e =>
                new Xm(
                  this.firestore,
                  new nm(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter)
                )
            );
          return ym(this._delegate, t, n);
        }
        get(e) {
          let t;
          return (
            (t =
              'cache' === (null === e || void 0 === e ? void 0 : e.source)
                ? cm(this._delegate)
                : 'server' === (null === e || void 0 === e ? void 0 : e.source)
                  ? lm(this._delegate)
                  : am(this._delegate)),
            t.then(
              e =>
                new Xm(
                  this.firestore,
                  new nm(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter)
                )
            )
          );
        }
        withConverter(e) {
          return new Hm(this.firestore, e ? this._delegate.withConverter(Wm.getInstance(this.firestore, e)) : this._delegate.withConverter(null));
        }
      }
      function Km(e, t, n) {
        return (e.message = e.message.replace(t, n)), e;
      }
      function Qm(e) {
        for (const t of e) if ('object' === typeof t && !Fm(t)) return t;
        return {};
      }
      function Ym(e, t) {
        var n, r;
        let i;
        return (
          (i = Fm(e[0])
            ? e[0]
            : Fm(e[1])
              ? e[1]
              : 'function' === typeof e[0]
                ? { next: e[0], error: e[1], complete: e[2] }
                : { next: e[1], error: e[2], complete: e[3] }),
          {
            next: e => {
              i.next && i.next(t(e));
            },
            error: null === (n = i.error) || void 0 === n ? void 0 : n.bind(i),
            complete: null === (r = i.complete) || void 0 === r ? void 0 : r.bind(i)
          }
        );
      }
      class Xm {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t);
        }
        get ref() {
          return new Hm(this._firestore, this._delegate.ref);
        }
        get id() {
          return this._delegate.id;
        }
        get metadata() {
          return this._delegate.metadata;
        }
        get exists() {
          return this._delegate.exists();
        }
        data(e) {
          return this._delegate.data(e);
        }
        get(e, t) {
          return this._delegate.get(e, t);
        }
        isEqual(e) {
          return sm(this._delegate, e._delegate);
        }
      }
      class Jm extends Xm {
        data(e) {
          const t = this._delegate.data(e);
          return ai(void 0 !== t, 'Document in a QueryDocumentSnapshot should exist'), t;
        }
      }
      class Zm {
        constructor(e, t) {
          (this.firestore = e), (this._delegate = t), (this._userDataWriter = new $m(e));
        }
        where(e, t, n) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Dg(e, t, n)));
          } catch (r) {
            throw Km(r, /(orderBy|where)\(\)/, 'Query.$1()');
          }
        }
        orderBy(e, t) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Mg(e, t)));
          } catch (n) {
            throw Km(n, /(orderBy|where)\(\)/, 'Query.$1()');
          }
        }
        limit(e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Ug(e)));
          } catch (t) {
            throw Km(t, 'limit()', 'Query.limit()');
          }
        }
        limitToLast(e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Vg(e)));
          } catch (t) {
            throw Km(t, 'limitToLast()', 'Query.limitToLast()');
          }
        }
        startAt(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, $g(...e)));
          } catch (t) {
            throw Km(t, 'startAt()', 'Query.startAt()');
          }
        }
        startAfter(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, qg(...e)));
          } catch (t) {
            throw Km(t, 'startAfter()', 'Query.startAfter()');
          }
        }
        endBefore(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Gg(...e)));
          } catch (t) {
            throw Km(t, 'endBefore()', 'Query.endBefore()');
          }
        }
        endAt(...e) {
          try {
            return new Zm(this.firestore, Rg(this._delegate, Wg(...e)));
          } catch (t) {
            throw Km(t, 'endAt()', 'Query.endAt()');
          }
        }
        isEqual(e) {
          return Rp(this._delegate, e._delegate);
        }
        get(e) {
          let t;
          return (
            (t =
              'cache' === (null === e || void 0 === e ? void 0 : e.source)
                ? fm(this._delegate)
                : 'server' === (null === e || void 0 === e ? void 0 : e.source)
                  ? dm(this._delegate)
                  : hm(this._delegate)),
            t.then(e => new tv(this.firestore, new im(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot)))
          );
        }
        onSnapshot(...e) {
          const t = Qm(e),
            n = Ym(e, e => new tv(this.firestore, new im(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot)));
          return ym(this._delegate, t, n);
        }
        withConverter(e) {
          return new Zm(this.firestore, e ? this._delegate.withConverter(Wm.getInstance(this.firestore, e)) : this._delegate.withConverter(null));
        }
      }
      class ev {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t);
        }
        get type() {
          return this._delegate.type;
        }
        get doc() {
          return new Jm(this._firestore, this._delegate.doc);
        }
        get oldIndex() {
          return this._delegate.oldIndex;
        }
        get newIndex() {
          return this._delegate.newIndex;
        }
      }
      class tv {
        constructor(e, t) {
          (this._firestore = e), (this._delegate = t);
        }
        get query() {
          return new Zm(this._firestore, this._delegate.query);
        }
        get metadata() {
          return this._delegate.metadata;
        }
        get size() {
          return this._delegate.size;
        }
        get empty() {
          return this._delegate.empty;
        }
        get docs() {
          return this._delegate.docs.map(e => new Jm(this._firestore, e));
        }
        docChanges(e) {
          return this._delegate.docChanges(e).map(e => new ev(this._firestore, e));
        }
        forEach(e, t) {
          this._delegate.forEach(n => {
            e.call(t, new Jm(this._firestore, n));
          });
        }
        isEqual(e) {
          return sm(this._delegate, e._delegate);
        }
      }
      class nv extends Zm {
        constructor(e, t) {
          super(e, t), (this.firestore = e), (this._delegate = t);
        }
        get id() {
          return this._delegate.id;
        }
        get path() {
          return this._delegate.path;
        }
        get parent() {
          const e = this._delegate.parent;
          return e ? new Hm(this.firestore, e) : null;
        }
        doc(e) {
          try {
            return new Hm(this.firestore, void 0 === e ? Op(this._delegate) : Op(this._delegate, e));
          } catch (t) {
            throw Km(t, 'doc()', 'CollectionReference.doc()');
          }
        }
        add(e) {
          return vm(this._delegate, e).then(e => new Hm(this.firestore, e));
        }
        isEqual(e) {
          return Np(this._delegate, e._delegate);
        }
        withConverter(e) {
          return new nv(this.firestore, e ? this._delegate.withConverter(Wm.getInstance(this.firestore, e)) : this._delegate.withConverter(null));
        }
      }
      function rv(e) {
        return bp(e, Tp);
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class iv {
        constructor(...e) {
          this._delegate = new Xp(...e);
        }
        static documentId() {
          return new iv(Oi.keyField().canonicalString());
        }
        isEqual(e) {
          return (e = (0, u.m9)(e)), e instanceof Xp && this._delegate._internalPath.isEqual(e._internalPath);
        }
      }
      /**
       * @license
       * Copyright 2017 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ class ov {
        constructor(e) {
          this._delegate = e;
        }
        static serverTimestamp() {
          const e = Cm();
          return (e._methodName = 'FieldValue.serverTimestamp'), new ov(e);
        }
        static delete() {
          const e = xm();
          return (e._methodName = 'FieldValue.delete'), new ov(e);
        }
        static arrayUnion(...e) {
          const t = km(...e);
          return (t._methodName = 'FieldValue.arrayUnion'), new ov(t);
        }
        static arrayRemove(...e) {
          const t = Om(...e);
          return (t._methodName = 'FieldValue.arrayRemove'), new ov(t);
        }
        static increment(e) {
          const t = Nm(e);
          return (t._methodName = 'FieldValue.increment'), new ov(t);
        }
        isEqual(e) {
          return this._delegate.isEqual(e._delegate);
        }
      }
      /**
       * @license
       * Copyright 2021 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ const sv = {
        Firestore: Bm,
        GeoPoint: Zp,
        Timestamp: Ti,
        Blob: Mm,
        Transaction: zm,
        WriteBatch: Gm,
        DocumentReference: Hm,
        DocumentSnapshot: Xm,
        Query: Zm,
        QueryDocumentSnapshot: Jm,
        QuerySnapshot: tv,
        CollectionReference: nv,
        FieldPath: iv,
        FieldValue: ov,
        setLogLevel: qm,
        CACHE_SIZE_UNLIMITED: jp
      };
      function av(e, t) {
        e.INTERNAL.registerComponent(
          new s.wA(
            'firestore-compat',
            e => {
              const n = e.getProvider('app-compat').getImmediate(),
                r = e.getProvider('firestore').getImmediate();
              return t(n, r);
            },
            'PUBLIC'
          ).setServiceProps(Object.assign({}, sv))
        );
      }
      /**
       * @license
       * Copyright 2020 Google LLC
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *   http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */ function uv(e) {
        av(e, (e, t) => new Bm(e, t, new Vm())), e.registerVersion(Rm, Pm);
      }
      uv(i.Z);
    }
  }
]);
